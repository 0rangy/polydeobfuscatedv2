(() => {
    var e = {
            1312: (e, t, n) => {
                var i;
                !function () {
                    'use strict';
                    var t = 'input is invalid type', r = 'object' == typeof window, a = r ? window : {};
                    a.JS_SHA256_NO_WINDOW && (r = !1);
                    var s = !r && 'object' == typeof self, o = !a.JS_SHA256_NO_NODE_JS && 'object' == typeof process && process.versions && process.versions.node;
                    o ? a = n.g : s && (a = self);
                    var l = !a.JS_SHA256_NO_COMMON_JS && e.exports, c = n.amdO, h = !a.JS_SHA256_NO_ARRAY_BUFFER && 'undefined' != typeof ArrayBuffer, d = '0123456789abcdef'.split(''), u = [
                            -2147483648,
                            8388608,
                            32768,
                            128
                        ], f = [
                            24,
                            16,
                            8,
                            0
                        ], p = [
                            1116352408,
                            1899447441,
                            3049323471,
                            3921009573,
                            961987163,
                            1508970993,
                            2453635748,
                            2870763221,
                            3624381080,
                            310598401,
                            607225278,
                            1426881987,
                            1925078388,
                            2162078206,
                            2614888103,
                            3248222580,
                            3835390401,
                            4022224774,
                            264347078,
                            604807628,
                            770255983,
                            1249150122,
                            1555081692,
                            1996064986,
                            2554220882,
                            2821834349,
                            2952996808,
                            3210313671,
                            3336571891,
                            3584528711,
                            113926993,
                            338241895,
                            666307205,
                            773529912,
                            1294757372,
                            1396182291,
                            1695183700,
                            1986661051,
                            2177026350,
                            2456956037,
                            2730485921,
                            2820302411,
                            3259730800,
                            3345764771,
                            3516065817,
                            3600352804,
                            4094571909,
                            275423344,
                            430227734,
                            506948616,
                            659060556,
                            883997877,
                            958139571,
                            1322822218,
                            1537002063,
                            1747873779,
                            1955562222,
                            2024104815,
                            2227730452,
                            2361852424,
                            2428436474,
                            2756734187,
                            3204031479,
                            3329325298
                        ], m = [
                            'hex',
                            'array',
                            'digest',
                            'arrayBuffer'
                        ], g = [];
                    !a.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function (e) {
                        return '[object Array]' === Object.prototype.toString.call(e);
                    }), !h || !a.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function (e) {
                        return 'object' == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer;
                    });
                    var A = function (e, t) {
                            return function (n) {
                                return new x(t, !0).update(n)[e]();
                            };
                        }, _ = function (e) {
                            var t = A('hex', e);
                            o && (t = v(t, e)), t.create = function () {
                                return new x(e);
                            }, t.update = function (e) {
                                return t.create().update(e);
                            };
                            for (var n = 0; n < m.length; ++n) {
                                var i = m[n];
                                t[i] = A(i, e);
                            }
                            return t;
                        }, v = function (e, i) {
                            var r, s = n(4394), o = n(1903).Buffer, l = i ? 'sha224' : 'sha256';
                            r = o.from && !a.JS_SHA256_NO_BUFFER_FROM ? o.from : function (e) {
                                return new o(e);
                            };
                            return function (n) {
                                if ('string' == typeof n)
                                    return s.createHash(l).update(n, 'utf8').digest('hex');
                                if (null == n)
                                    throw new Error(t);
                                return n.constructor === ArrayBuffer && (n = new Uint8Array(n)), Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === o ? s.createHash(l).update(r(n)).digest('hex') : e(n);
                            };
                        }, w = function (e, t) {
                            return function (n, i) {
                                return new b(n, t, !0).update(i)[e]();
                            };
                        }, y = function (e) {
                            var t = w('hex', e);
                            t.create = function (t) {
                                return new b(t, e);
                            }, t.update = function (e, n) {
                                return t.create(e).update(n);
                            };
                            for (var n = 0; n < m.length; ++n) {
                                var i = m[n];
                                t[i] = w(i, e);
                            }
                            return t;
                        };
                    function x(e, t) {
                        t ? (g[0] = g[16] = g[1] = g[2] = g[3] = g[4] = g[5] = g[6] = g[7] = g[8] = g[9] = g[10] = g[11] = g[12] = g[13] = g[14] = g[15] = 0, this.blocks = g) : this.blocks = [
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ], e ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = e;
                    }
                    function b(e, n, i) {
                        var r, a = typeof e;
                        if ('string' === a) {
                            var s, o = [], l = e.length, c = 0;
                            for (r = 0; r < l; ++r)
                                (s = e.charCodeAt(r)) < 128 ? o[c++] = s : s < 2048 ? (o[c++] = 192 | s >>> 6, o[c++] = 128 | 63 & s) : s < 55296 || s >= 57344 ? (o[c++] = 224 | s >>> 12, o[c++] = 128 | s >>> 6 & 63, o[c++] = 128 | 63 & s) : (s = 65536 + ((1023 & s) << 10 | 1023 & e.charCodeAt(++r)), o[c++] = 240 | s >>> 18, o[c++] = 128 | s >>> 12 & 63, o[c++] = 128 | s >>> 6 & 63, o[c++] = 128 | 63 & s);
                            e = o;
                        } else {
                            if ('object' !== a)
                                throw new Error(t);
                            if (null === e)
                                throw new Error(t);
                            if (h && e.constructor === ArrayBuffer)
                                e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                throw new Error(t);
                        }
                        e.length > 64 && (e = new x(n, !0).update(e).array());
                        var d = [], u = [];
                        for (r = 0; r < 64; ++r) {
                            var f = e[r] || 0;
                            d[r] = 92 ^ f, u[r] = 54 ^ f;
                        }
                        x.call(this, n, i), this.update(u), this.oKeyPad = d, this.inner = !0, this.sharedMemory = i;
                    }
                    x.prototype.update = function (e) {
                        if (!this.finalized) {
                            var n, i = typeof e;
                            if ('string' !== i) {
                                if ('object' !== i)
                                    throw new Error(t);
                                if (null === e)
                                    throw new Error(t);
                                if (h && e.constructor === ArrayBuffer)
                                    e = new Uint8Array(e);
                                else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                    throw new Error(t);
                                n = !0;
                            }
                            for (var r, a, s = 0, o = e.length, l = this.blocks; s < o;) {
                                if (this.hashed && (this.hashed = !1, l[0] = this.block, this.block = l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0), n)
                                    for (a = this.start; s < o && a < 64; ++s)
                                        l[a >>> 2] |= e[s] << f[3 & a++];
                                else
                                    for (a = this.start; s < o && a < 64; ++s)
                                        (r = e.charCodeAt(s)) < 128 ? l[a >>> 2] |= r << f[3 & a++] : r < 2048 ? (l[a >>> 2] |= (192 | r >>> 6) << f[3 & a++], l[a >>> 2] |= (128 | 63 & r) << f[3 & a++]) : r < 55296 || r >= 57344 ? (l[a >>> 2] |= (224 | r >>> 12) << f[3 & a++], l[a >>> 2] |= (128 | r >>> 6 & 63) << f[3 & a++], l[a >>> 2] |= (128 | 63 & r) << f[3 & a++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++s)), l[a >>> 2] |= (240 | r >>> 18) << f[3 & a++], l[a >>> 2] |= (128 | r >>> 12 & 63) << f[3 & a++], l[a >>> 2] |= (128 | r >>> 6 & 63) << f[3 & a++], l[a >>> 2] |= (128 | 63 & r) << f[3 & a++]);
                                this.lastByteIndex = a, this.bytes += a - this.start, a >= 64 ? (this.block = l[16], this.start = a - 64, this.hash(), this.hashed = !0) : this.start = a;
                            }
                            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 | 0, this.bytes = this.bytes % 4294967296), this;
                        }
                    }, x.prototype.finalize = function () {
                        if (!this.finalized) {
                            this.finalized = !0;
                            var e = this.blocks, t = this.lastByteIndex;
                            e[16] = this.block, e[t >>> 2] |= u[3 & t], this.block = e[16], t >= 56 && (this.hashed || this.hash(), e[0] = this.block, e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.hBytes << 3 | this.bytes >>> 29, e[15] = this.bytes << 3, this.hash();
                        }
                    }, x.prototype.hash = function () {
                        var e, t, n, i, r, a, s, o, l, c = this.h0, h = this.h1, d = this.h2, u = this.h3, f = this.h4, m = this.h5, g = this.h6, A = this.h7, _ = this.blocks;
                        for (e = 16; e < 64; ++e)
                            t = ((r = _[e - 15]) >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3, n = ((r = _[e - 2]) >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10, _[e] = _[e - 16] + t + _[e - 7] + n | 0;
                        for (l = h & d, e = 0; e < 64; e += 4)
                            this.first ? (this.is224 ? (a = 300032, A = (r = _[0] - 1413257819) - 150054599 | 0, u = r + 24177077 | 0) : (a = 704751109, A = (r = _[0] - 210244248) - 1521486534 | 0, u = r + 143694565 | 0), this.first = !1) : (t = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), i = (a = c & h) ^ c & d ^ l, A = u + (r = A + (n = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7)) + (f & m ^ ~f & g) + p[e] + _[e]) | 0, u = r + (t + i) | 0), t = (u >>> 2 | u << 30) ^ (u >>> 13 | u << 19) ^ (u >>> 22 | u << 10), i = (s = u & c) ^ u & h ^ a, g = d + (r = g + (n = (A >>> 6 | A << 26) ^ (A >>> 11 | A << 21) ^ (A >>> 25 | A << 7)) + (A & f ^ ~A & m) + p[e + 1] + _[e + 1]) | 0, t = ((d = r + (t + i) | 0) >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10), i = (o = d & u) ^ d & c ^ s, m = h + (r = m + (n = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & A ^ ~g & f) + p[e + 2] + _[e + 2]) | 0, t = ((h = r + (t + i) | 0) >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10), i = (l = h & d) ^ h & u ^ o, f = c + (r = f + (n = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7)) + (m & g ^ ~m & A) + p[e + 3] + _[e + 3]) | 0, c = r + (t + i) | 0, this.chromeBugWorkAround = !0;
                        this.h0 = this.h0 + c | 0, this.h1 = this.h1 + h | 0, this.h2 = this.h2 + d | 0, this.h3 = this.h3 + u | 0, this.h4 = this.h4 + f | 0, this.h5 = this.h5 + m | 0, this.h6 = this.h6 + g | 0, this.h7 = this.h7 + A | 0;
                    }, x.prototype.hex = function () {
                        this.finalize();
                        var e = this.h0, t = this.h1, n = this.h2, i = this.h3, r = this.h4, a = this.h5, s = this.h6, o = this.h7, l = d[e >>> 28 & 15] + d[e >>> 24 & 15] + d[e >>> 20 & 15] + d[e >>> 16 & 15] + d[e >>> 12 & 15] + d[e >>> 8 & 15] + d[e >>> 4 & 15] + d[15 & e] + d[t >>> 28 & 15] + d[t >>> 24 & 15] + d[t >>> 20 & 15] + d[t >>> 16 & 15] + d[t >>> 12 & 15] + d[t >>> 8 & 15] + d[t >>> 4 & 15] + d[15 & t] + d[n >>> 28 & 15] + d[n >>> 24 & 15] + d[n >>> 20 & 15] + d[n >>> 16 & 15] + d[n >>> 12 & 15] + d[n >>> 8 & 15] + d[n >>> 4 & 15] + d[15 & n] + d[i >>> 28 & 15] + d[i >>> 24 & 15] + d[i >>> 20 & 15] + d[i >>> 16 & 15] + d[i >>> 12 & 15] + d[i >>> 8 & 15] + d[i >>> 4 & 15] + d[15 & i] + d[r >>> 28 & 15] + d[r >>> 24 & 15] + d[r >>> 20 & 15] + d[r >>> 16 & 15] + d[r >>> 12 & 15] + d[r >>> 8 & 15] + d[r >>> 4 & 15] + d[15 & r] + d[a >>> 28 & 15] + d[a >>> 24 & 15] + d[a >>> 20 & 15] + d[a >>> 16 & 15] + d[a >>> 12 & 15] + d[a >>> 8 & 15] + d[a >>> 4 & 15] + d[15 & a] + d[s >>> 28 & 15] + d[s >>> 24 & 15] + d[s >>> 20 & 15] + d[s >>> 16 & 15] + d[s >>> 12 & 15] + d[s >>> 8 & 15] + d[s >>> 4 & 15] + d[15 & s];
                        return this.is224 || (l += d[o >>> 28 & 15] + d[o >>> 24 & 15] + d[o >>> 20 & 15] + d[o >>> 16 & 15] + d[o >>> 12 & 15] + d[o >>> 8 & 15] + d[o >>> 4 & 15] + d[15 & o]), l;
                    }, x.prototype.toString = x.prototype.hex, x.prototype.digest = function () {
                        this.finalize();
                        var e = this.h0, t = this.h1, n = this.h2, i = this.h3, r = this.h4, a = this.h5, s = this.h6, o = this.h7, l = [
                                e >>> 24 & 255,
                                e >>> 16 & 255,
                                e >>> 8 & 255,
                                255 & e,
                                t >>> 24 & 255,
                                t >>> 16 & 255,
                                t >>> 8 & 255,
                                255 & t,
                                n >>> 24 & 255,
                                n >>> 16 & 255,
                                n >>> 8 & 255,
                                255 & n,
                                i >>> 24 & 255,
                                i >>> 16 & 255,
                                i >>> 8 & 255,
                                255 & i,
                                r >>> 24 & 255,
                                r >>> 16 & 255,
                                r >>> 8 & 255,
                                255 & r,
                                a >>> 24 & 255,
                                a >>> 16 & 255,
                                a >>> 8 & 255,
                                255 & a,
                                s >>> 24 & 255,
                                s >>> 16 & 255,
                                s >>> 8 & 255,
                                255 & s
                            ];
                        return this.is224 || l.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o), l;
                    }, x.prototype.array = x.prototype.digest, x.prototype.arrayBuffer = function () {
                        this.finalize();
                        var e = new ArrayBuffer(this.is224 ? 28 : 32), t = new DataView(e);
                        return t.setUint32(0, this.h0), t.setUint32(4, this.h1), t.setUint32(8, this.h2), t.setUint32(12, this.h3), t.setUint32(16, this.h4), t.setUint32(20, this.h5), t.setUint32(24, this.h6), this.is224 || t.setUint32(28, this.h7), e;
                    }, b.prototype = new x(), b.prototype.finalize = function () {
                        if (x.prototype.finalize.call(this), this.inner) {
                            this.inner = !1;
                            var e = this.array();
                            x.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(e), x.prototype.finalize.call(this);
                        }
                    };
                    var S = _();
                    S.sha256 = S, S.sha224 = _(!0), S.sha256.hmac = y(), S.sha224.hmac = y(!0), l ? e.exports = S : (a.sha256 = S.sha256, a.sha224 = S.sha224, c && (void 0 === (i = function () {
                        return S;
                    }.call(S, n, S, e)) || (e.exports = i)));
                }();
            },
            1903: () => {
            },
            4394: () => {
            }
        }, t = {};
    function n(i) {
        var r = t[i];
        if (void 0 !== r)
            return r.exports;
        var a = t[i] = { exports: {} };
        return e[i](a, a.exports, n), a.exports;
    }
    n.amdO = {}, n.g = function () {
        if ('object' == typeof globalThis)
            return globalThis;
        try {
            return this || new Function('return this')();
        } catch (e) {
            if ('object' == typeof window)
                return window;
        }
    }(), (() => {
        'use strict';
        const REVISION = '174', t = 0, i = 1, r = 2, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, ConstantColorFactor = 211, OneMinusConstantColorFactor = 212, ConstantAlphaFactor = 213, OneMinusConstantAlphaFactor = 214, b = 0, aspect = 1, CullFaceFront = 2, LessEqualDepth = 3, MultiplyBlending = 4, CustomBlending = 5, GreaterDepth = 6, NotEqualDepth = 7, AttachedBindMode = 'attached', CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, RepeatWrapping = 1000, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipMapNearestFilter = 1004, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipMapNearestFilter = 1007, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedInt248Type = 1020, UnsignedInt5999Type = 35902, RGBAFormat = 1023, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGIntegerFormat = 1031, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, RGB_BPTC_SIGNED_Format = 36494, RGB_BPTC_UNSIGNED_Format = 36495, SIGNED_RED_RGTC1_Format = 36284, RED_GREEN_RGTC2_Format = 36285, SIGNED_RED_GREEN_RGTC2_Format = 36286, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, qe = '', Ye = 'srgb', LinearSRGBColorSpace = 'srgb-linear', LinearTransfer = 'linear', SRGBTransfer = 'srgb', KeepStencilOp = 7680, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysCompare = 519, StaticDrawUsage = 35044, GLSL3 = '300 es', WebGLCoordinateSystem = 2000, WebGPUCoordinateSystem = 2001;
        class EventDispatcher {
            addEventListener(REVISION, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[REVISION] && (n[REVISION] = []), -1 === n[REVISION].indexOf(t) && n[REVISION].push(t);
            }
            hasEventListener(REVISION, t) {
                const n = this._listeners;
                return void 0 !== n && (void 0 !== n[REVISION] && -1 !== n[REVISION].indexOf(t));
            }
            removeEventListener(REVISION, t) {
                const n = this._listeners;
                if (void 0 === n)
                    return;
                const i = n[REVISION];
                if (void 0 !== i) {
                    const REVISION = i.indexOf(t);
                    -1 !== REVISION && i.splice(REVISION, 1);
                }
            }
            dispatchEvent(REVISION) {
                const t = this._listeners;
                if (void 0 === t)
                    return;
                const n = t[REVISION.type];
                if (void 0 !== n) {
                    REVISION.target = this;
                    const t = n.slice(0);
                    for (let n = 0, i = t.length; n < i; n++)
                        t[n].call(this, REVISION);
                    REVISION.target = null;
                }
            }
        }
        const _lut = [
            '00',
            '01',
            '02',
            '03',
            '04',
            '05',
            '06',
            '07',
            '08',
            '09',
            '0a',
            '0b',
            '0c',
            '0d',
            '0e',
            '0f',
            '10',
            '11',
            '12',
            '13',
            '14',
            '15',
            '16',
            '17',
            '18',
            '19',
            '1a',
            '1b',
            '1c',
            '1d',
            '1e',
            '1f',
            '20',
            '21',
            '22',
            '23',
            '24',
            '25',
            '26',
            '27',
            '28',
            '29',
            '2a',
            '2b',
            '2c',
            '2d',
            '2e',
            '2f',
            '30',
            '31',
            '32',
            '33',
            '34',
            '35',
            '36',
            '37',
            '38',
            '39',
            '3a',
            '3b',
            '3c',
            '3d',
            '3e',
            '3f',
            '40',
            '41',
            '42',
            '43',
            '44',
            '45',
            '46',
            '47',
            '48',
            '49',
            '4a',
            '4b',
            '4c',
            '4d',
            '4e',
            '4f',
            '50',
            '51',
            '52',
            '53',
            '54',
            '55',
            '56',
            '57',
            '58',
            '59',
            '5a',
            '5b',
            '5c',
            '5d',
            '5e',
            '5f',
            '60',
            '61',
            '62',
            '63',
            '64',
            '65',
            '66',
            '67',
            '68',
            '69',
            '6a',
            '6b',
            '6c',
            '6d',
            '6e',
            '6f',
            '70',
            '71',
            '72',
            '73',
            '74',
            '75',
            '76',
            '77',
            '78',
            '79',
            '7a',
            '7b',
            '7c',
            '7d',
            '7e',
            '7f',
            '80',
            '81',
            '82',
            '83',
            '84',
            '85',
            '86',
            '87',
            '88',
            '89',
            '8a',
            '8b',
            '8c',
            '8d',
            '8e',
            '8f',
            '90',
            '91',
            '92',
            '93',
            '94',
            '95',
            '96',
            '97',
            '98',
            '99',
            '9a',
            '9b',
            '9c',
            '9d',
            '9e',
            '9f',
            'a0',
            'a1',
            'a2',
            'a3',
            'a4',
            'a5',
            'a6',
            'a7',
            'a8',
            'a9',
            'aa',
            'ab',
            'ac',
            'ad',
            'ae',
            'af',
            'b0',
            'b1',
            'b2',
            'b3',
            'b4',
            'b5',
            'b6',
            'b7',
            'b8',
            'b9',
            'ba',
            'bb',
            'bc',
            'bd',
            'be',
            'bf',
            'c0',
            'c1',
            'c2',
            'c3',
            'c4',
            'c5',
            'c6',
            'c7',
            'c8',
            'c9',
            'ca',
            'cb',
            'cc',
            'cd',
            'ce',
            'cf',
            'd0',
            'd1',
            'd2',
            'd3',
            'd4',
            'd5',
            'd6',
            'd7',
            'd8',
            'd9',
            'da',
            'db',
            'dc',
            'dd',
            'de',
            'df',
            'e0',
            'e1',
            'e2',
            'e3',
            'e4',
            'e5',
            'e6',
            'e7',
            'e8',
            'e9',
            'ea',
            'eb',
            'ec',
            'ed',
            'ee',
            'ef',
            'f0',
            'f1',
            'f2',
            'f3',
            'f4',
            'f5',
            'f6',
            'f7',
            'f8',
            'f9',
            'fa',
            'fb',
            'fc',
            'fd',
            'fe',
            'ff'
        ];
        let _seed = 1234567;
        const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI;
        function At() {
            const REVISION = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0;
            return (_lut[255 & REVISION] + _lut[REVISION >> 8 & 255] + _lut[REVISION >> 16 & 255] + _lut[REVISION >> 24 & 255] + '-' + _lut[255 & t] + _lut[t >> 8 & 255] + '-' + _lut[t >> 16 & 15 | 64] + _lut[t >> 24 & 255] + '-' + _lut[63 & n | 128] + _lut[n >> 8 & 255] + '-' + _lut[n >> 16 & 255] + _lut[n >> 24 & 255] + _lut[255 & i] + _lut[i >> 8 & 255] + _lut[i >> 16 & 255] + _lut[i >> 24 & 255]).toLowerCase();
        }
        function clamp(REVISION, t, n) {
            return Math.max(t, Math.min(n, REVISION));
        }
        function euclideanModulo(REVISION, t) {
            return (REVISION % t + t) % t;
        }
        function lerp(REVISION, t, n) {
            return (1 - n) * REVISION + n * t;
        }
        function denormalize(REVISION, t) {
            switch (t.constructor) {
            case Float32Array:
                return REVISION;
            case Uint32Array:
                return REVISION / 4294967295;
            case Uint16Array:
                return REVISION / 65535;
            case Uint8Array:
                return REVISION / 255;
            case Int32Array:
                return Math.max(REVISION / 2147483647, -1);
            case Int16Array:
                return Math.max(REVISION / 32767, -1);
            case Int8Array:
                return Math.max(REVISION / 127, -1);
            default:
                throw new Error('Invalid component type.');
            }
        }
        function xt(REVISION, t) {
            switch (t.constructor) {
            case Float32Array:
                return REVISION;
            case Uint32Array:
                return Math.round(4294967295 * REVISION);
            case Uint16Array:
                return Math.round(65535 * REVISION);
            case Uint8Array:
                return Math.round(255 * REVISION);
            case Int32Array:
                return Math.round(2147483647 * REVISION);
            case Int16Array:
                return Math.round(32767 * REVISION);
            case Int8Array:
                return Math.round(127 * REVISION);
            default:
                throw new Error('Invalid component type.');
            }
        }
        const bt = {
            DEG2RAD: DEG2RAD,
            RAD2DEG: RAD2DEG,
            generateUUID: At,
            clamp: clamp,
            euclideanModulo: euclideanModulo,
            mapLinear: function (REVISION, t, n, i, r) {
                return i + (REVISION - t) * (r - i) / (n - t);
            },
            inverseLerp: function (REVISION, t, n) {
                return REVISION !== t ? (n - REVISION) / (t - REVISION) : 0;
            },
            lerp: lerp,
            damp: function (REVISION, t, n, i) {
                return lerp(REVISION, t, 1 - Math.exp(-n * i));
            },
            pingpong: function (REVISION, t = 1) {
                return t - Math.abs(euclideanModulo(REVISION, 2 * t) - t);
            },
            smoothstep: function (REVISION, t, n) {
                return REVISION <= t ? 0 : REVISION >= n ? 1 : (REVISION = (REVISION - t) / (n - t)) * REVISION * (3 - 2 * REVISION);
            },
            smootherstep: function (REVISION, t, n) {
                return REVISION <= t ? 0 : REVISION >= n ? 1 : (REVISION = (REVISION - t) / (n - t)) * REVISION * REVISION * (REVISION * (6 * REVISION - 15) + 10);
            },
            randInt: function (REVISION, t) {
                return REVISION + Math.floor(Math.random() * (t - REVISION + 1));
            },
            randFloat: function (REVISION, t) {
                return REVISION + Math.random() * (t - REVISION);
            },
            randFloatSpread: function (REVISION) {
                return REVISION * (0.5 - Math.random());
            },
            seededRandom: function (REVISION) {
                void 0 !== REVISION && (_seed = REVISION);
                let t = _seed += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296;
            },
            degToRad: function (REVISION) {
                return REVISION * DEG2RAD;
            },
            radToDeg: function (REVISION) {
                return REVISION * RAD2DEG;
            },
            isPowerOfTwo: function (REVISION) {
                return !(REVISION & REVISION - 1) && 0 !== REVISION;
            },
            ceilPowerOfTwo: function (REVISION) {
                return Math.pow(2, Math.ceil(Math.log(REVISION) / Math.LN2));
            },
            floorPowerOfTwo: function (REVISION) {
                return Math.pow(2, Math.floor(Math.log(REVISION) / Math.LN2));
            },
            setQuaternionFromProperEuler: function (REVISION, t, n, i, r) {
                const AddEquation = Math.cos, SubtractEquation = Math.sin, ReverseSubtractEquation = AddEquation(n / 2), ZeroFactor = SubtractEquation(n / 2), OneFactor = AddEquation((t + i) / 2), SrcColorFactor = SubtractEquation((t + i) / 2), OneMinusSrcColorFactor = AddEquation((t - i) / 2), SrcAlphaFactor = SubtractEquation((t - i) / 2), OneMinusSrcAlphaFactor = AddEquation((i - t) / 2), DstAlphaFactor = SubtractEquation((i - t) / 2);
                switch (r) {
                case 'XYX':
                    REVISION.set(ReverseSubtractEquation * SrcColorFactor, ZeroFactor * OneMinusSrcColorFactor, ZeroFactor * SrcAlphaFactor, ReverseSubtractEquation * OneFactor);
                    break;
                case 'YZY':
                    REVISION.set(ZeroFactor * SrcAlphaFactor, ReverseSubtractEquation * SrcColorFactor, ZeroFactor * OneMinusSrcColorFactor, ReverseSubtractEquation * OneFactor);
                    break;
                case 'ZXZ':
                    REVISION.set(ZeroFactor * OneMinusSrcColorFactor, ZeroFactor * SrcAlphaFactor, ReverseSubtractEquation * SrcColorFactor, ReverseSubtractEquation * OneFactor);
                    break;
                case 'XZX':
                    REVISION.set(ReverseSubtractEquation * SrcColorFactor, ZeroFactor * DstAlphaFactor, ZeroFactor * OneMinusSrcAlphaFactor, ReverseSubtractEquation * OneFactor);
                    break;
                case 'YXY':
                    REVISION.set(ZeroFactor * OneMinusSrcAlphaFactor, ReverseSubtractEquation * SrcColorFactor, ZeroFactor * DstAlphaFactor, ReverseSubtractEquation * OneFactor);
                    break;
                case 'ZYZ':
                    REVISION.set(ZeroFactor * DstAlphaFactor, ZeroFactor * OneMinusSrcAlphaFactor, ReverseSubtractEquation * SrcColorFactor, ReverseSubtractEquation * OneFactor);
                    break;
                default:
                    console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + r);
                }
            },
            normalize: xt,
            denormalize: denormalize
        };
        class Vector2 {
            constructor(REVISION = 0, t = 0) {
                Vector2.prototype.isVector2 = !0, this.x = REVISION, this.y = t;
            }
            get width() {
                return this.x;
            }
            set width(REVISION) {
                this.x = REVISION;
            }
            get height() {
                return this.y;
            }
            set height(REVISION) {
                this.y = REVISION;
            }
            set(REVISION, t) {
                return this.x = REVISION, this.y = t, this;
            }
            setScalar(REVISION) {
                return this.x = REVISION, this.y = REVISION, this;
            }
            setX(REVISION) {
                return this.x = REVISION, this;
            }
            setY(REVISION) {
                return this.y = REVISION, this;
            }
            setComponent(REVISION, t) {
                switch (REVISION) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error('index is out of range: ' + REVISION);
                }
                return this;
            }
            getComponent(REVISION) {
                switch (REVISION) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + REVISION);
                }
            }
            clone() {
                return new this.constructor(this.x, this.y);
            }
            copy(REVISION) {
                return this.x = REVISION.x, this.y = REVISION.y, this;
            }
            add(REVISION) {
                return this.x += REVISION.x, this.y += REVISION.y, this;
            }
            addScalar(REVISION) {
                return this.x += REVISION, this.y += REVISION, this;
            }
            addVectors(REVISION, t) {
                return this.x = REVISION.x + t.x, this.y = REVISION.y + t.y, this;
            }
            addScaledVector(REVISION, t) {
                return this.x += REVISION.x * t, this.y += REVISION.y * t, this;
            }
            sub(REVISION) {
                return this.x -= REVISION.x, this.y -= REVISION.y, this;
            }
            subScalar(REVISION) {
                return this.x -= REVISION, this.y -= REVISION, this;
            }
            subVectors(REVISION, t) {
                return this.x = REVISION.x - t.x, this.y = REVISION.y - t.y, this;
            }
            multiply(REVISION) {
                return this.x *= REVISION.x, this.y *= REVISION.y, this;
            }
            multiplyScalar(REVISION) {
                return this.x *= REVISION, this.y *= REVISION, this;
            }
            divide(REVISION) {
                return this.x /= REVISION.x, this.y /= REVISION.y, this;
            }
            divideScalar(REVISION) {
                return this.multiplyScalar(1 / REVISION);
            }
            applyMatrix3(REVISION) {
                const t = this.x, n = this.y, i = REVISION.elements;
                return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
            }
            min(REVISION) {
                return this.x = Math.min(this.x, REVISION.x), this.y = Math.min(this.y, REVISION.y), this;
            }
            max(REVISION) {
                return this.x = Math.max(this.x, REVISION.x), this.y = Math.max(this.y, REVISION.y), this;
            }
            clamp(REVISION, t) {
                return this.x = clamp(this.x, REVISION.x, t.x), this.y = clamp(this.y, REVISION.y, t.y), this;
            }
            clampScalar(REVISION, t) {
                return this.x = clamp(this.x, REVISION, t), this.y = clamp(this.y, REVISION, t), this;
            }
            clampLength(REVISION, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(clamp(n, REVISION, t));
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this;
            }
            dot(REVISION) {
                return this.x * REVISION.x + this.y * REVISION.y;
            }
            cross(REVISION) {
                return this.x * REVISION.y - this.y * REVISION.x;
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y;
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y);
            }
            normalize() {
                return this.divideScalar(this.length() || 1);
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI;
            }
            angleTo(REVISION) {
                const t = Math.sqrt(this.lengthSq() * REVISION.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(REVISION) / t;
                return Math.acos(clamp(n, -1, 1));
            }
            distanceTo(REVISION) {
                return Math.sqrt(this.distanceToSquared(REVISION));
            }
            distanceToSquared(REVISION) {
                const t = this.x - REVISION.x, n = this.y - REVISION.y;
                return t * t + n * n;
            }
            manhattanDistanceTo(REVISION) {
                return Math.abs(this.x - REVISION.x) + Math.abs(this.y - REVISION.y);
            }
            setLength(REVISION) {
                return this.normalize().multiplyScalar(REVISION);
            }
            lerp(REVISION, t) {
                return this.x += (REVISION.x - this.x) * t, this.y += (REVISION.y - this.y) * t, this;
            }
            lerpVectors(REVISION, t, n) {
                return this.x = REVISION.x + (t.x - REVISION.x) * n, this.y = REVISION.y + (t.y - REVISION.y) * n, this;
            }
            equals(REVISION) {
                return REVISION.x === this.x && REVISION.y === this.y;
            }
            fromArray(REVISION, t = 0) {
                return this.x = REVISION[t], this.y = REVISION[t + 1], this;
            }
            toArray(REVISION = [], t = 0) {
                return REVISION[t] = this.x, REVISION[t + 1] = this.y, REVISION;
            }
            fromBufferAttribute(REVISION, t) {
                return this.x = REVISION.getX(t), this.y = REVISION.getY(t), this;
            }
            rotateAround(REVISION, t) {
                const n = Math.cos(t), i = Math.sin(t), r = this.x - REVISION.x, AddEquation = this.y - REVISION.y;
                return this.x = r * n - AddEquation * i + REVISION.x, this.y = r * i + AddEquation * n + REVISION.y, this;
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this;
            }
            *[Symbol.iterator]() {
                yield this.x, yield this.y;
            }
        }
        class Matrix3 {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor) {
                Matrix3.prototype.isMatrix3 = !0, this.elements = [
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ], void 0 !== REVISION && this.set(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor);
            }
            set(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor) {
                const OneFactor = this.elements;
                return OneFactor[0] = REVISION, OneFactor[1] = i, OneFactor[2] = SubtractEquation, OneFactor[3] = t, OneFactor[4] = r, OneFactor[5] = ReverseSubtractEquation, OneFactor[6] = n, OneFactor[7] = AddEquation, OneFactor[8] = ZeroFactor, this;
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
            }
            copy(REVISION) {
                const t = this.elements, n = REVISION.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
            }
            extractBasis(REVISION, t, n) {
                return REVISION.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
            }
            setFromMatrix4(REVISION) {
                const t = REVISION.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
            }
            multiply(REVISION) {
                return this.multiplyMatrices(this, REVISION);
            }
            premultiply(REVISION) {
                return this.multiplyMatrices(REVISION, this);
            }
            multiplyMatrices(REVISION, t) {
                const n = REVISION.elements, i = t.elements, r = this.elements, AddEquation = n[0], SubtractEquation = n[3], ReverseSubtractEquation = n[6], ZeroFactor = n[1], OneFactor = n[4], SrcColorFactor = n[7], OneMinusSrcColorFactor = n[2], SrcAlphaFactor = n[5], OneMinusSrcAlphaFactor = n[8], DstAlphaFactor = i[0], OneMinusDstAlphaFactor = i[3], DstColorFactor = i[6], OneMinusDstColorFactor = i[1], SrcAlphaSaturateFactor = i[4], ConstantColorFactor = i[7], OneMinusConstantColorFactor = i[2], ConstantAlphaFactor = i[5], OneMinusConstantAlphaFactor = i[8];
                return r[0] = AddEquation * DstAlphaFactor + SubtractEquation * OneMinusDstColorFactor + ReverseSubtractEquation * OneMinusConstantColorFactor, r[3] = AddEquation * OneMinusDstAlphaFactor + SubtractEquation * SrcAlphaSaturateFactor + ReverseSubtractEquation * ConstantAlphaFactor, r[6] = AddEquation * DstColorFactor + SubtractEquation * ConstantColorFactor + ReverseSubtractEquation * OneMinusConstantAlphaFactor, r[1] = ZeroFactor * DstAlphaFactor + OneFactor * OneMinusDstColorFactor + SrcColorFactor * OneMinusConstantColorFactor, r[4] = ZeroFactor * OneMinusDstAlphaFactor + OneFactor * SrcAlphaSaturateFactor + SrcColorFactor * ConstantAlphaFactor, r[7] = ZeroFactor * DstColorFactor + OneFactor * ConstantColorFactor + SrcColorFactor * OneMinusConstantAlphaFactor, r[2] = OneMinusSrcColorFactor * DstAlphaFactor + SrcAlphaFactor * OneMinusDstColorFactor + OneMinusSrcAlphaFactor * OneMinusConstantColorFactor, r[5] = OneMinusSrcColorFactor * OneMinusDstAlphaFactor + SrcAlphaFactor * SrcAlphaSaturateFactor + OneMinusSrcAlphaFactor * ConstantAlphaFactor, r[8] = OneMinusSrcColorFactor * DstColorFactor + SrcAlphaFactor * ConstantColorFactor + OneMinusSrcAlphaFactor * OneMinusConstantAlphaFactor, this;
            }
            multiplyScalar(REVISION) {
                const t = this.elements;
                return t[0] *= REVISION, t[3] *= REVISION, t[6] *= REVISION, t[1] *= REVISION, t[4] *= REVISION, t[7] *= REVISION, t[2] *= REVISION, t[5] *= REVISION, t[8] *= REVISION, this;
            }
            determinant() {
                const REVISION = this.elements, t = REVISION[0], n = REVISION[1], i = REVISION[2], r = REVISION[3], AddEquation = REVISION[4], SubtractEquation = REVISION[5], ReverseSubtractEquation = REVISION[6], ZeroFactor = REVISION[7], OneFactor = REVISION[8];
                return t * AddEquation * OneFactor - t * SubtractEquation * ZeroFactor - n * r * OneFactor + n * SubtractEquation * ReverseSubtractEquation + i * r * ZeroFactor - i * AddEquation * ReverseSubtractEquation;
            }
            invert() {
                const REVISION = this.elements, t = REVISION[0], n = REVISION[1], i = REVISION[2], r = REVISION[3], AddEquation = REVISION[4], SubtractEquation = REVISION[5], ReverseSubtractEquation = REVISION[6], ZeroFactor = REVISION[7], OneFactor = REVISION[8], SrcColorFactor = OneFactor * AddEquation - SubtractEquation * ZeroFactor, OneMinusSrcColorFactor = SubtractEquation * ReverseSubtractEquation - OneFactor * r, SrcAlphaFactor = ZeroFactor * r - AddEquation * ReverseSubtractEquation, OneMinusSrcAlphaFactor = t * SrcColorFactor + n * OneMinusSrcColorFactor + i * SrcAlphaFactor;
                if (0 === OneMinusSrcAlphaFactor)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const DstAlphaFactor = 1 / OneMinusSrcAlphaFactor;
                return REVISION[0] = SrcColorFactor * DstAlphaFactor, REVISION[1] = (i * ZeroFactor - OneFactor * n) * DstAlphaFactor, REVISION[2] = (SubtractEquation * n - i * AddEquation) * DstAlphaFactor, REVISION[3] = OneMinusSrcColorFactor * DstAlphaFactor, REVISION[4] = (OneFactor * t - i * ReverseSubtractEquation) * DstAlphaFactor, REVISION[5] = (i * r - SubtractEquation * t) * DstAlphaFactor, REVISION[6] = SrcAlphaFactor * DstAlphaFactor, REVISION[7] = (n * ReverseSubtractEquation - ZeroFactor * t) * DstAlphaFactor, REVISION[8] = (AddEquation * t - n * r) * DstAlphaFactor, this;
            }
            transpose() {
                let REVISION;
                const t = this.elements;
                return REVISION = t[1], t[1] = t[3], t[3] = REVISION, REVISION = t[2], t[2] = t[6], t[6] = REVISION, REVISION = t[5], t[5] = t[7], t[7] = REVISION, this;
            }
            getNormalMatrix(REVISION) {
                return this.setFromMatrix4(REVISION).invert().transpose();
            }
            transposeIntoArray(REVISION) {
                const t = this.elements;
                return REVISION[0] = t[0], REVISION[1] = t[3], REVISION[2] = t[6], REVISION[3] = t[1], REVISION[4] = t[4], REVISION[5] = t[7], REVISION[6] = t[2], REVISION[7] = t[5], REVISION[8] = t[8], this;
            }
            setUvTransform(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
                const ReverseSubtractEquation = Math.cos(r), ZeroFactor = Math.sin(r);
                return this.set(n * ReverseSubtractEquation, n * ZeroFactor, -n * (ReverseSubtractEquation * AddEquation + ZeroFactor * SubtractEquation) + AddEquation + REVISION, -i * ZeroFactor, i * ReverseSubtractEquation, -i * (-ZeroFactor * AddEquation + ReverseSubtractEquation * SubtractEquation) + SubtractEquation + t, 0, 0, 1), this;
            }
            scale(REVISION, t) {
                return this.premultiply(_m3.makeScale(REVISION, t)), this;
            }
            rotate(REVISION) {
                return this.premultiply(_m3.makeRotation(-REVISION)), this;
            }
            translate(REVISION, t) {
                return this.premultiply(_m3.makeTranslation(REVISION, t)), this;
            }
            makeTranslation(REVISION, t) {
                return REVISION.isVector2 ? this.set(1, 0, REVISION.x, 0, 1, REVISION.y, 0, 0, 1) : this.set(1, 0, REVISION, 0, 1, t, 0, 0, 1), this;
            }
            makeRotation(REVISION) {
                const t = Math.cos(REVISION), n = Math.sin(REVISION);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
            }
            makeScale(REVISION, t) {
                return this.set(REVISION, 0, 0, 0, t, 0, 0, 0, 1), this;
            }
            equals(REVISION) {
                const t = this.elements, n = REVISION.elements;
                for (let REVISION = 0; REVISION < 9; REVISION++)
                    if (t[REVISION] !== n[REVISION])
                        return !1;
                return !0;
            }
            fromArray(REVISION, t = 0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = REVISION[n + t];
                return this;
            }
            toArray(REVISION = [], t = 0) {
                const n = this.elements;
                return REVISION[t] = n[0], REVISION[t + 1] = n[1], REVISION[t + 2] = n[2], REVISION[t + 3] = n[3], REVISION[t + 4] = n[4], REVISION[t + 5] = n[5], REVISION[t + 6] = n[6], REVISION[t + 7] = n[7], REVISION[t + 8] = n[8], REVISION;
            }
            clone() {
                return new this.constructor().fromArray(this.elements);
            }
        }
        const _m3 = new Matrix3();
        function Tt(REVISION) {
            for (let t = REVISION.length - 1; t >= 0; --t)
                if (REVISION[t] >= 65535)
                    return !0;
            return !1;
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        function createElementNS(REVISION) {
            return document.createElementNS('http://www.w3.org/1999/xhtml', REVISION);
        }
        function It() {
            const REVISION = createElementNS('canvas');
            return REVISION.style.display = 'block', REVISION;
        }
        const _cache = {};
        function Pt(REVISION) {
            REVISION in _cache || (_cache[REVISION] = !0, console.warn(REVISION));
        }
        const LINEAR_REC709_TO_XYZ = new Matrix3().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), XYZ_TO_LINEAR_REC709 = new Matrix3().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
        function Lt() {
            const REVISION = {
                    enabled: !0,
                    workingColorSpace: LinearSRGBColorSpace,
                    spaces: {},
                    convert: function (REVISION, t, n) {
                        return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === SRGBTransfer && (REVISION.r = Nt(REVISION.r), REVISION.g = Nt(REVISION.g), REVISION.b = Nt(REVISION.b)), this.spaces[t].primaries !== this.spaces[n].primaries && (REVISION.applyMatrix3(this.spaces[t].toXYZ), REVISION.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === SRGBTransfer && (REVISION.r = kt(REVISION.r), REVISION.g = kt(REVISION.g), REVISION.b = kt(REVISION.b)), REVISION) : REVISION;
                    },
                    fromWorkingColorSpace: function (REVISION, t) {
                        return this.convert(REVISION, this.workingColorSpace, t);
                    },
                    toWorkingColorSpace: function (REVISION, t) {
                        return this.convert(REVISION, t, this.workingColorSpace);
                    },
                    getPrimaries: function (REVISION) {
                        return this.spaces[REVISION].primaries;
                    },
                    getTransfer: function (REVISION) {
                        return REVISION === qe ? LinearTransfer : this.spaces[REVISION].transfer;
                    },
                    getLuminanceCoefficients: function (REVISION, t = this.workingColorSpace) {
                        return REVISION.fromArray(this.spaces[t].luminanceCoefficients);
                    },
                    define: function (REVISION) {
                        Object.assign(this.spaces, REVISION);
                    },
                    _getMatrix: function (REVISION, t, n) {
                        return REVISION.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ);
                    },
                    _getDrawingBufferColorSpace: function (REVISION) {
                        return this.spaces[REVISION].outputColorSpaceConfig.drawingBufferColorSpace;
                    },
                    _getUnpackColorSpace: function (REVISION = this.workingColorSpace) {
                        return this.spaces[REVISION].workingColorSpaceConfig.unpackColorSpace;
                    }
                }, t = [
                    0.64,
                    0.33,
                    0.3,
                    0.6,
                    0.15,
                    0.06
                ], n = [
                    0.2126,
                    0.7152,
                    0.0722
                ], i = [
                    0.3127,
                    0.329
                ];
            return REVISION.define({
                [LinearSRGBColorSpace]: {
                    primaries: t,
                    whitePoint: i,
                    transfer: LinearTransfer,
                    toXYZ: LINEAR_REC709_TO_XYZ,
                    fromXYZ: XYZ_TO_LINEAR_REC709,
                    luminanceCoefficients: n,
                    workingColorSpaceConfig: { unpackColorSpace: Ye },
                    outputColorSpaceConfig: { drawingBufferColorSpace: Ye }
                },
                [Ye]: {
                    primaries: t,
                    whitePoint: i,
                    transfer: SRGBTransfer,
                    toXYZ: LINEAR_REC709_TO_XYZ,
                    fromXYZ: XYZ_TO_LINEAR_REC709,
                    luminanceCoefficients: n,
                    outputColorSpaceConfig: { drawingBufferColorSpace: Ye }
                }
            }), REVISION;
        }
        const _tables = Lt();
        function Nt(REVISION) {
            return REVISION < 0.04045 ? 0.0773993808 * REVISION : Math.pow(0.9478672986 * REVISION + 0.0521327014, 2.4);
        }
        function kt(REVISION) {
            return REVISION < 0.0031308 ? 12.92 * REVISION : 1.055 * Math.pow(REVISION, 0.41666) - 0.055;
        }
        let _canvas;
        class ImageUtils {
            static getDataURL(REVISION) {
                if (/^data:/i.test(REVISION.src))
                    return REVISION.src;
                if ('undefined' == typeof HTMLCanvasElement)
                    return REVISION.src;
                let t;
                if (REVISION instanceof HTMLCanvasElement)
                    t = REVISION;
                else {
                    void 0 === _canvas && (_canvas = createElementNS('canvas')), _canvas.width = REVISION.width, _canvas.height = REVISION.height;
                    const n = _canvas.getContext('2d');
                    REVISION instanceof ImageData ? n.putImageData(REVISION, 0, 0) : n.drawImage(REVISION, 0, 0, REVISION.width, REVISION.height), t = _canvas;
                }
                return t.toDataURL('image/png');
            }
            static sRGBToLinear(REVISION) {
                if ('undefined' != typeof HTMLImageElement && REVISION instanceof HTMLImageElement || 'undefined' != typeof HTMLCanvasElement && REVISION instanceof HTMLCanvasElement || 'undefined' != typeof ImageBitmap && REVISION instanceof ImageBitmap) {
                    const t = createElementNS('canvas');
                    t.width = REVISION.width, t.height = REVISION.height;
                    const n = t.getContext('2d');
                    n.drawImage(REVISION, 0, 0, REVISION.width, REVISION.height);
                    const i = n.getImageData(0, 0, REVISION.width, REVISION.height), r = i.data;
                    for (let REVISION = 0; REVISION < r.length; REVISION++)
                        r[REVISION] = 255 * Nt(r[REVISION] / 255);
                    return n.putImageData(i, 0, 0), t;
                }
                if (REVISION.data) {
                    const t = REVISION.data.slice(0);
                    for (let REVISION = 0; REVISION < t.length; REVISION++)
                        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[REVISION] = Math.floor(255 * Nt(t[REVISION] / 255)) : t[REVISION] = Nt(t[REVISION]);
                    return {
                        data: t,
                        width: REVISION.width,
                        height: REVISION.height
                    };
                }
                return console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'), REVISION;
            }
        }
        let _sourceId = 0;
        class Source {
            constructor(REVISION = null) {
                this.isSource = !0, Object.defineProperty(this, 'id', { value: _sourceId++ }), this.uuid = At(), this.data = REVISION, this.dataReady = !0, this.version = 0;
            }
            set needsUpdate(REVISION) {
                !0 === REVISION && this.version++;
            }
            toJSON(REVISION) {
                const t = void 0 === REVISION || 'string' == typeof REVISION;
                if (!t && void 0 !== REVISION.images[this.uuid])
                    return REVISION.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ''
                    }, i = this.data;
                if (null !== i) {
                    let REVISION;
                    if (Array.isArray(i)) {
                        REVISION = [];
                        for (let t = 0, n = i.length; t < n; t++)
                            i[t].isDataTexture ? REVISION.push(Wt(i[t].image)) : REVISION.push(Wt(i[t]));
                    } else
                        REVISION = Wt(i);
                    n.url = REVISION;
                }
                return t || (REVISION.images[this.uuid] = n), n;
            }
        }
        function Wt(REVISION) {
            return 'undefined' != typeof HTMLImageElement && REVISION instanceof HTMLImageElement || 'undefined' != typeof HTMLCanvasElement && REVISION instanceof HTMLCanvasElement || 'undefined' != typeof ImageBitmap && REVISION instanceof ImageBitmap ? ImageUtils.getDataURL(REVISION) : REVISION.data ? {
                data: Array.from(REVISION.data),
                width: REVISION.width,
                height: REVISION.height,
                type: REVISION.data.constructor.name
            } : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
        }
        let _textureId = 0;
        class Texture extends EventDispatcher {
            constructor(REVISION = Texture.DEFAULT_IMAGE, t = Texture.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, AddEquation = 1008, SubtractEquation = 1023, ReverseSubtractEquation = 1009, ZeroFactor = Texture.DEFAULT_ANISOTROPY, OneFactor = '') {
                super(), this.isTexture = !0, Object.defineProperty(this, 'id', { value: _textureId++ }), this.uuid = At(), this.name = '', this.source = new Source(REVISION), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = AddEquation, this.anisotropy = ZeroFactor, this.format = SubtractEquation, this.internalFormat = null, this.type = ReverseSubtractEquation, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = OneFactor, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
            }
            get image() {
                return this.source.data;
            }
            set image(REVISION = null) {
                this.source.data = REVISION;
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
            }
            clone() {
                return new this.constructor().copy(this);
            }
            copy(REVISION) {
                return this.name = REVISION.name, this.source = REVISION.source, this.mipmaps = REVISION.mipmaps.slice(0), this.mapping = REVISION.mapping, this.channel = REVISION.channel, this.wrapS = REVISION.wrapS, this.wrapT = REVISION.wrapT, this.magFilter = REVISION.magFilter, this.minFilter = REVISION.minFilter, this.anisotropy = REVISION.anisotropy, this.format = REVISION.format, this.internalFormat = REVISION.internalFormat, this.type = REVISION.type, this.offset.copy(REVISION.offset), this.repeat.copy(REVISION.repeat), this.center.copy(REVISION.center), this.rotation = REVISION.rotation, this.matrixAutoUpdate = REVISION.matrixAutoUpdate, this.matrix.copy(REVISION.matrix), this.generateMipmaps = REVISION.generateMipmaps, this.premultiplyAlpha = REVISION.premultiplyAlpha, this.flipY = REVISION.flipY, this.unpackAlignment = REVISION.unpackAlignment, this.colorSpace = REVISION.colorSpace, this.renderTarget = REVISION.renderTarget, this.isRenderTargetTexture = REVISION.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(REVISION.userData)), this.needsUpdate = !0, this;
            }
            toJSON(REVISION) {
                const t = void 0 === REVISION || 'string' == typeof REVISION;
                if (!t && void 0 !== REVISION.textures[this.uuid])
                    return REVISION.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: 'Texture',
                        generator: 'Texture.toJSON'
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(REVISION).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [
                        this.repeat.x,
                        this.repeat.y
                    ],
                    offset: [
                        this.offset.x,
                        this.offset.y
                    ],
                    center: [
                        this.center.x,
                        this.center.y
                    ],
                    rotation: this.rotation,
                    wrap: [
                        this.wrapS,
                        this.wrapT
                    ],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (REVISION.textures[this.uuid] = n), n;
            }
            dispose() {
                this.dispatchEvent({ type: 'dispose' });
            }
            transformUv(REVISION) {
                if (300 !== this.mapping)
                    return REVISION;
                if (REVISION.applyMatrix3(this.matrix), REVISION.x < 0 || REVISION.x > 1)
                    switch (this.wrapS) {
                    case RepeatWrapping:
                        REVISION.x = REVISION.x - Math.floor(REVISION.x);
                        break;
                    case ClampToEdgeWrapping:
                        REVISION.x = REVISION.x < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        1 === Math.abs(Math.floor(REVISION.x) % 2) ? REVISION.x = Math.ceil(REVISION.x) - REVISION.x : REVISION.x = REVISION.x - Math.floor(REVISION.x);
                    }
                if (REVISION.y < 0 || REVISION.y > 1)
                    switch (this.wrapT) {
                    case RepeatWrapping:
                        REVISION.y = REVISION.y - Math.floor(REVISION.y);
                        break;
                    case ClampToEdgeWrapping:
                        REVISION.y = REVISION.y < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        1 === Math.abs(Math.floor(REVISION.y) % 2) ? REVISION.y = Math.ceil(REVISION.y) - REVISION.y : REVISION.y = REVISION.y - Math.floor(REVISION.y);
                    }
                return this.flipY && (REVISION.y = 1 - REVISION.y), REVISION;
            }
            set needsUpdate(REVISION) {
                !0 === REVISION && (this.version++, this.source.needsUpdate = !0);
            }
            set needsPMREMUpdate(REVISION) {
                !0 === REVISION && this.pmremVersion++;
            }
        }
        Texture.DEFAULT_IMAGE = null, Texture.DEFAULT_MAPPING = 300, Texture.DEFAULT_ANISOTROPY = 1;
        class Vector4 {
            constructor(REVISION = 0, t = 0, n = 0, i = 1) {
                Vector4.prototype.isVector4 = !0, this.x = REVISION, this.y = t, this.z = n, this.w = i;
            }
            get width() {
                return this.z;
            }
            set width(REVISION) {
                this.z = REVISION;
            }
            get height() {
                return this.w;
            }
            set height(REVISION) {
                this.w = REVISION;
            }
            set(REVISION, t, n, i) {
                return this.x = REVISION, this.y = t, this.z = n, this.w = i, this;
            }
            setScalar(REVISION) {
                return this.x = REVISION, this.y = REVISION, this.z = REVISION, this.w = REVISION, this;
            }
            setX(REVISION) {
                return this.x = REVISION, this;
            }
            setY(REVISION) {
                return this.y = REVISION, this;
            }
            setZ(REVISION) {
                return this.z = REVISION, this;
            }
            setW(REVISION) {
                return this.w = REVISION, this;
            }
            setComponent(REVISION, t) {
                switch (REVISION) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error('index is out of range: ' + REVISION);
                }
                return this;
            }
            getComponent(REVISION) {
                switch (REVISION) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error('index is out of range: ' + REVISION);
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w);
            }
            copy(REVISION) {
                return this.x = REVISION.x, this.y = REVISION.y, this.z = REVISION.z, this.w = void 0 !== REVISION.w ? REVISION.w : 1, this;
            }
            add(REVISION) {
                return this.x += REVISION.x, this.y += REVISION.y, this.z += REVISION.z, this.w += REVISION.w, this;
            }
            addScalar(REVISION) {
                return this.x += REVISION, this.y += REVISION, this.z += REVISION, this.w += REVISION, this;
            }
            addVectors(REVISION, t) {
                return this.x = REVISION.x + t.x, this.y = REVISION.y + t.y, this.z = REVISION.z + t.z, this.w = REVISION.w + t.w, this;
            }
            addScaledVector(REVISION, t) {
                return this.x += REVISION.x * t, this.y += REVISION.y * t, this.z += REVISION.z * t, this.w += REVISION.w * t, this;
            }
            sub(REVISION) {
                return this.x -= REVISION.x, this.y -= REVISION.y, this.z -= REVISION.z, this.w -= REVISION.w, this;
            }
            subScalar(REVISION) {
                return this.x -= REVISION, this.y -= REVISION, this.z -= REVISION, this.w -= REVISION, this;
            }
            subVectors(REVISION, t) {
                return this.x = REVISION.x - t.x, this.y = REVISION.y - t.y, this.z = REVISION.z - t.z, this.w = REVISION.w - t.w, this;
            }
            multiply(REVISION) {
                return this.x *= REVISION.x, this.y *= REVISION.y, this.z *= REVISION.z, this.w *= REVISION.w, this;
            }
            multiplyScalar(REVISION) {
                return this.x *= REVISION, this.y *= REVISION, this.z *= REVISION, this.w *= REVISION, this;
            }
            applyMatrix4(REVISION) {
                const t = this.x, n = this.y, i = this.z, r = this.w, AddEquation = REVISION.elements;
                return this.x = AddEquation[0] * t + AddEquation[4] * n + AddEquation[8] * i + AddEquation[12] * r, this.y = AddEquation[1] * t + AddEquation[5] * n + AddEquation[9] * i + AddEquation[13] * r, this.z = AddEquation[2] * t + AddEquation[6] * n + AddEquation[10] * i + AddEquation[14] * r, this.w = AddEquation[3] * t + AddEquation[7] * n + AddEquation[11] * i + AddEquation[15] * r, this;
            }
            divide(REVISION) {
                return this.x /= REVISION.x, this.y /= REVISION.y, this.z /= REVISION.z, this.w /= REVISION.w, this;
            }
            divideScalar(REVISION) {
                return this.multiplyScalar(1 / REVISION);
            }
            setAxisAngleFromQuaternion(REVISION) {
                this.w = 2 * Math.acos(REVISION.w);
                const t = Math.sqrt(1 - REVISION.w * REVISION.w);
                return t < 0.0001 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = REVISION.x / t, this.y = REVISION.y / t, this.z = REVISION.z / t), this;
            }
            setAxisAngleFromRotationMatrix(REVISION) {
                let t, n, i, r;
                const AddEquation = 0.01, SubtractEquation = 0.1, ReverseSubtractEquation = REVISION.elements, ZeroFactor = ReverseSubtractEquation[0], OneFactor = ReverseSubtractEquation[4], SrcColorFactor = ReverseSubtractEquation[8], OneMinusSrcColorFactor = ReverseSubtractEquation[1], SrcAlphaFactor = ReverseSubtractEquation[5], OneMinusSrcAlphaFactor = ReverseSubtractEquation[9], DstAlphaFactor = ReverseSubtractEquation[2], OneMinusDstAlphaFactor = ReverseSubtractEquation[6], DstColorFactor = ReverseSubtractEquation[10];
                if (Math.abs(OneFactor - OneMinusSrcColorFactor) < AddEquation && Math.abs(SrcColorFactor - DstAlphaFactor) < AddEquation && Math.abs(OneMinusSrcAlphaFactor - OneMinusDstAlphaFactor) < AddEquation) {
                    if (Math.abs(OneFactor + OneMinusSrcColorFactor) < SubtractEquation && Math.abs(SrcColorFactor + DstAlphaFactor) < SubtractEquation && Math.abs(OneMinusSrcAlphaFactor + OneMinusDstAlphaFactor) < SubtractEquation && Math.abs(ZeroFactor + SrcAlphaFactor + DstColorFactor - 3) < SubtractEquation)
                        return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    const REVISION = (ZeroFactor + 1) / 2, ReverseSubtractEquation = (SrcAlphaFactor + 1) / 2, OneMinusDstColorFactor = (DstColorFactor + 1) / 2, SrcAlphaSaturateFactor = (OneFactor + OneMinusSrcColorFactor) / 4, ConstantColorFactor = (SrcColorFactor + DstAlphaFactor) / 4, OneMinusConstantColorFactor = (OneMinusSrcAlphaFactor + OneMinusDstAlphaFactor) / 4;
                    return REVISION > ReverseSubtractEquation && REVISION > OneMinusDstColorFactor ? REVISION < AddEquation ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(REVISION), i = SrcAlphaSaturateFactor / n, r = ConstantColorFactor / n) : ReverseSubtractEquation > OneMinusDstColorFactor ? ReverseSubtractEquation < AddEquation ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(ReverseSubtractEquation), n = SrcAlphaSaturateFactor / i, r = OneMinusConstantColorFactor / i) : OneMinusDstColorFactor < AddEquation ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(OneMinusDstColorFactor), n = ConstantColorFactor / r, i = OneMinusConstantColorFactor / r), this.set(n, i, r, t), this;
                }
                let OneMinusDstColorFactor = Math.sqrt((OneMinusDstAlphaFactor - OneMinusSrcAlphaFactor) * (OneMinusDstAlphaFactor - OneMinusSrcAlphaFactor) + (SrcColorFactor - DstAlphaFactor) * (SrcColorFactor - DstAlphaFactor) + (OneMinusSrcColorFactor - OneFactor) * (OneMinusSrcColorFactor - OneFactor));
                return Math.abs(OneMinusDstColorFactor) < 0.001 && (OneMinusDstColorFactor = 1), this.x = (OneMinusDstAlphaFactor - OneMinusSrcAlphaFactor) / OneMinusDstColorFactor, this.y = (SrcColorFactor - DstAlphaFactor) / OneMinusDstColorFactor, this.z = (OneMinusSrcColorFactor - OneFactor) / OneMinusDstColorFactor, this.w = Math.acos((ZeroFactor + SrcAlphaFactor + DstColorFactor - 1) / 2), this;
            }
            setFromMatrixPosition(REVISION) {
                const t = REVISION.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
            }
            min(REVISION) {
                return this.x = Math.min(this.x, REVISION.x), this.y = Math.min(this.y, REVISION.y), this.z = Math.min(this.z, REVISION.z), this.w = Math.min(this.w, REVISION.w), this;
            }
            max(REVISION) {
                return this.x = Math.max(this.x, REVISION.x), this.y = Math.max(this.y, REVISION.y), this.z = Math.max(this.z, REVISION.z), this.w = Math.max(this.w, REVISION.w), this;
            }
            clamp(REVISION, t) {
                return this.x = clamp(this.x, REVISION.x, t.x), this.y = clamp(this.y, REVISION.y, t.y), this.z = clamp(this.z, REVISION.z, t.z), this.w = clamp(this.w, REVISION.w, t.w), this;
            }
            clampScalar(REVISION, t) {
                return this.x = clamp(this.x, REVISION, t), this.y = clamp(this.y, REVISION, t), this.z = clamp(this.z, REVISION, t), this.w = clamp(this.w, REVISION, t), this;
            }
            clampLength(REVISION, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(clamp(n, REVISION, t));
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
            }
            dot(REVISION) {
                return this.x * REVISION.x + this.y * REVISION.y + this.z * REVISION.z + this.w * REVISION.w;
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
            }
            normalize() {
                return this.divideScalar(this.length() || 1);
            }
            setLength(REVISION) {
                return this.normalize().multiplyScalar(REVISION);
            }
            lerp(REVISION, t) {
                return this.x += (REVISION.x - this.x) * t, this.y += (REVISION.y - this.y) * t, this.z += (REVISION.z - this.z) * t, this.w += (REVISION.w - this.w) * t, this;
            }
            lerpVectors(REVISION, t, n) {
                return this.x = REVISION.x + (t.x - REVISION.x) * n, this.y = REVISION.y + (t.y - REVISION.y) * n, this.z = REVISION.z + (t.z - REVISION.z) * n, this.w = REVISION.w + (t.w - REVISION.w) * n, this;
            }
            equals(REVISION) {
                return REVISION.x === this.x && REVISION.y === this.y && REVISION.z === this.z && REVISION.w === this.w;
            }
            fromArray(REVISION, t = 0) {
                return this.x = REVISION[t], this.y = REVISION[t + 1], this.z = REVISION[t + 2], this.w = REVISION[t + 3], this;
            }
            toArray(REVISION = [], t = 0) {
                return REVISION[t] = this.x, REVISION[t + 1] = this.y, REVISION[t + 2] = this.z, REVISION[t + 3] = this.w, REVISION;
            }
            fromBufferAttribute(REVISION, t) {
                return this.x = REVISION.getX(t), this.y = REVISION.getY(t), this.z = REVISION.getZ(t), this.w = REVISION.getW(t), this;
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
            }
            *[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w;
            }
        }
        class RenderTarget extends EventDispatcher {
            constructor(REVISION = 1, t = 1, n = {}) {
                super(), this.isRenderTarget = !0, this.width = REVISION, this.height = t, this.depth = 1, this.scissor = new Vector4(0, 0, REVISION, t), this.scissorTest = !1, this.viewport = new Vector4(0, 0, REVISION, t);
                const i = {
                    width: REVISION,
                    height: t,
                    depth: 1
                };
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: LinearFilter,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    resolveDepthBuffer: !0,
                    resolveStencilBuffer: !0,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, n);
                const r = new Texture(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
                const AddEquation = n.count;
                for (let REVISION = 0; REVISION < AddEquation; REVISION++)
                    this.textures[REVISION] = r.clone(), this.textures[REVISION].isRenderTargetTexture = !0, this.textures[REVISION].renderTarget = this;
                this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples;
            }
            get texture() {
                return this.textures[0];
            }
            set texture(REVISION) {
                this.textures[0] = REVISION;
            }
            set depthTexture(REVISION) {
                null !== this._depthTexture && (this._depthTexture.renderTarget = null), null !== REVISION && (REVISION.renderTarget = this), this._depthTexture = REVISION;
            }
            get depthTexture() {
                return this._depthTexture;
            }
            setSize(REVISION, t, n = 1) {
                if (this.width !== REVISION || this.height !== t || this.depth !== n) {
                    this.width = REVISION, this.height = t, this.depth = n;
                    for (let i = 0, r = this.textures.length; i < r; i++)
                        this.textures[i].image.width = REVISION, this.textures[i].image.height = t, this.textures[i].image.depth = n;
                    this.dispose();
                }
                this.viewport.set(0, 0, REVISION, t), this.scissor.set(0, 0, REVISION, t);
            }
            clone() {
                return new this.constructor().copy(this);
            }
            copy(REVISION) {
                this.width = REVISION.width, this.height = REVISION.height, this.depth = REVISION.depth, this.scissor.copy(REVISION.scissor), this.scissorTest = REVISION.scissorTest, this.viewport.copy(REVISION.viewport), this.textures.length = 0;
                for (let t = 0, n = REVISION.textures.length; t < n; t++) {
                    this.textures[t] = REVISION.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                    const n = Object.assign({}, REVISION.textures[t].image);
                    this.textures[t].source = new Source(n);
                }
                return this.depthBuffer = REVISION.depthBuffer, this.stencilBuffer = REVISION.stencilBuffer, this.resolveDepthBuffer = REVISION.resolveDepthBuffer, this.resolveStencilBuffer = REVISION.resolveStencilBuffer, null !== REVISION.depthTexture && (this.depthTexture = REVISION.depthTexture.clone()), this.samples = REVISION.samples, this;
            }
            dispose() {
                this.dispatchEvent({ type: 'dispose' });
            }
        }
        class jt extends RenderTarget {
            constructor(REVISION = 1, t = 1, n = {}) {
                super(REVISION, t, n), this.isWebGLRenderTarget = !0;
            }
        }
        class CompressedArrayTexture extends Texture {
            constructor(REVISION = null, t = 1, n = 1, i = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: REVISION,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set();
            }
            addLayerUpdate(REVISION) {
                this.layerUpdates.add(REVISION);
            }
            clearLayerUpdates() {
                this.layerUpdates.clear();
            }
        }
        class Yt extends Texture {
            constructor(REVISION = null, t = 1, n = 1, i = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: REVISION,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
            }
        }
        class Quaternion {
            constructor(REVISION = 0, t = 0, n = 0, i = 1) {
                this.isQuaternion = !0, this._x = REVISION, this._y = t, this._z = n, this._w = i;
            }
            static slerpFlat(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
                let ReverseSubtractEquation = n[i + 0], ZeroFactor = n[i + 1], OneFactor = n[i + 2], SrcColorFactor = n[i + 3];
                const OneMinusSrcColorFactor = r[AddEquation + 0], SrcAlphaFactor = r[AddEquation + 1], OneMinusSrcAlphaFactor = r[AddEquation + 2], DstAlphaFactor = r[AddEquation + 3];
                if (0 === SubtractEquation)
                    return REVISION[t + 0] = ReverseSubtractEquation, REVISION[t + 1] = ZeroFactor, REVISION[t + 2] = OneFactor, void (REVISION[t + 3] = SrcColorFactor);
                if (1 === SubtractEquation)
                    return REVISION[t + 0] = OneMinusSrcColorFactor, REVISION[t + 1] = SrcAlphaFactor, REVISION[t + 2] = OneMinusSrcAlphaFactor, void (REVISION[t + 3] = DstAlphaFactor);
                if (SrcColorFactor !== DstAlphaFactor || ReverseSubtractEquation !== OneMinusSrcColorFactor || ZeroFactor !== SrcAlphaFactor || OneFactor !== OneMinusSrcAlphaFactor) {
                    let REVISION = 1 - SubtractEquation;
                    const t = ReverseSubtractEquation * OneMinusSrcColorFactor + ZeroFactor * SrcAlphaFactor + OneFactor * OneMinusSrcAlphaFactor + SrcColorFactor * DstAlphaFactor, n = t >= 0 ? 1 : -1, i = 1 - t * t;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i), AddEquation = Math.atan2(r, t * n);
                        REVISION = Math.sin(REVISION * AddEquation) / r, SubtractEquation = Math.sin(SubtractEquation * AddEquation) / r;
                    }
                    const r = SubtractEquation * n;
                    if (ReverseSubtractEquation = ReverseSubtractEquation * REVISION + OneMinusSrcColorFactor * r, ZeroFactor = ZeroFactor * REVISION + SrcAlphaFactor * r, OneFactor = OneFactor * REVISION + OneMinusSrcAlphaFactor * r, SrcColorFactor = SrcColorFactor * REVISION + DstAlphaFactor * r, REVISION === 1 - SubtractEquation) {
                        const REVISION = 1 / Math.sqrt(ReverseSubtractEquation * ReverseSubtractEquation + ZeroFactor * ZeroFactor + OneFactor * OneFactor + SrcColorFactor * SrcColorFactor);
                        ReverseSubtractEquation *= REVISION, ZeroFactor *= REVISION, OneFactor *= REVISION, SrcColorFactor *= REVISION;
                    }
                }
                REVISION[t] = ReverseSubtractEquation, REVISION[t + 1] = ZeroFactor, REVISION[t + 2] = OneFactor, REVISION[t + 3] = SrcColorFactor;
            }
            static multiplyQuaternionsFlat(REVISION, t, n, i, r, AddEquation) {
                const SubtractEquation = n[i], ReverseSubtractEquation = n[i + 1], ZeroFactor = n[i + 2], OneFactor = n[i + 3], SrcColorFactor = r[AddEquation], OneMinusSrcColorFactor = r[AddEquation + 1], SrcAlphaFactor = r[AddEquation + 2], OneMinusSrcAlphaFactor = r[AddEquation + 3];
                return REVISION[t] = SubtractEquation * OneMinusSrcAlphaFactor + OneFactor * SrcColorFactor + ReverseSubtractEquation * SrcAlphaFactor - ZeroFactor * OneMinusSrcColorFactor, REVISION[t + 1] = ReverseSubtractEquation * OneMinusSrcAlphaFactor + OneFactor * OneMinusSrcColorFactor + ZeroFactor * SrcColorFactor - SubtractEquation * SrcAlphaFactor, REVISION[t + 2] = ZeroFactor * OneMinusSrcAlphaFactor + OneFactor * SrcAlphaFactor + SubtractEquation * OneMinusSrcColorFactor - ReverseSubtractEquation * SrcColorFactor, REVISION[t + 3] = OneFactor * OneMinusSrcAlphaFactor - SubtractEquation * SrcColorFactor - ReverseSubtractEquation * OneMinusSrcColorFactor - ZeroFactor * SrcAlphaFactor, REVISION;
            }
            get x() {
                return this._x;
            }
            set x(REVISION) {
                this._x = REVISION, this._onChangeCallback();
            }
            get y() {
                return this._y;
            }
            set y(REVISION) {
                this._y = REVISION, this._onChangeCallback();
            }
            get z() {
                return this._z;
            }
            set z(REVISION) {
                this._z = REVISION, this._onChangeCallback();
            }
            get w() {
                return this._w;
            }
            set w(REVISION) {
                this._w = REVISION, this._onChangeCallback();
            }
            set(REVISION, t, n, i) {
                return this._x = REVISION, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w);
            }
            copy(REVISION) {
                return this._x = REVISION.x, this._y = REVISION.y, this._z = REVISION.z, this._w = REVISION.w, this._onChangeCallback(), this;
            }
            setFromEuler(REVISION, t = !0) {
                const n = REVISION._x, i = REVISION._y, r = REVISION._z, AddEquation = REVISION._order, SubtractEquation = Math.cos, ReverseSubtractEquation = Math.sin, ZeroFactor = SubtractEquation(n / 2), OneFactor = SubtractEquation(i / 2), SrcColorFactor = SubtractEquation(r / 2), OneMinusSrcColorFactor = ReverseSubtractEquation(n / 2), SrcAlphaFactor = ReverseSubtractEquation(i / 2), OneMinusSrcAlphaFactor = ReverseSubtractEquation(r / 2);
                switch (AddEquation) {
                case 'XYZ':
                    this._x = OneMinusSrcColorFactor * OneFactor * SrcColorFactor + ZeroFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor, this._y = ZeroFactor * SrcAlphaFactor * SrcColorFactor - OneMinusSrcColorFactor * OneFactor * OneMinusSrcAlphaFactor, this._z = ZeroFactor * OneFactor * OneMinusSrcAlphaFactor + OneMinusSrcColorFactor * SrcAlphaFactor * SrcColorFactor, this._w = ZeroFactor * OneFactor * SrcColorFactor - OneMinusSrcColorFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor;
                    break;
                case 'YXZ':
                    this._x = OneMinusSrcColorFactor * OneFactor * SrcColorFactor + ZeroFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor, this._y = ZeroFactor * SrcAlphaFactor * SrcColorFactor - OneMinusSrcColorFactor * OneFactor * OneMinusSrcAlphaFactor, this._z = ZeroFactor * OneFactor * OneMinusSrcAlphaFactor - OneMinusSrcColorFactor * SrcAlphaFactor * SrcColorFactor, this._w = ZeroFactor * OneFactor * SrcColorFactor + OneMinusSrcColorFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor;
                    break;
                case 'ZXY':
                    this._x = OneMinusSrcColorFactor * OneFactor * SrcColorFactor - ZeroFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor, this._y = ZeroFactor * SrcAlphaFactor * SrcColorFactor + OneMinusSrcColorFactor * OneFactor * OneMinusSrcAlphaFactor, this._z = ZeroFactor * OneFactor * OneMinusSrcAlphaFactor + OneMinusSrcColorFactor * SrcAlphaFactor * SrcColorFactor, this._w = ZeroFactor * OneFactor * SrcColorFactor - OneMinusSrcColorFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor;
                    break;
                case 'ZYX':
                    this._x = OneMinusSrcColorFactor * OneFactor * SrcColorFactor - ZeroFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor, this._y = ZeroFactor * SrcAlphaFactor * SrcColorFactor + OneMinusSrcColorFactor * OneFactor * OneMinusSrcAlphaFactor, this._z = ZeroFactor * OneFactor * OneMinusSrcAlphaFactor - OneMinusSrcColorFactor * SrcAlphaFactor * SrcColorFactor, this._w = ZeroFactor * OneFactor * SrcColorFactor + OneMinusSrcColorFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor;
                    break;
                case 'YZX':
                    this._x = OneMinusSrcColorFactor * OneFactor * SrcColorFactor + ZeroFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor, this._y = ZeroFactor * SrcAlphaFactor * SrcColorFactor + OneMinusSrcColorFactor * OneFactor * OneMinusSrcAlphaFactor, this._z = ZeroFactor * OneFactor * OneMinusSrcAlphaFactor - OneMinusSrcColorFactor * SrcAlphaFactor * SrcColorFactor, this._w = ZeroFactor * OneFactor * SrcColorFactor - OneMinusSrcColorFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor;
                    break;
                case 'XZY':
                    this._x = OneMinusSrcColorFactor * OneFactor * SrcColorFactor - ZeroFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor, this._y = ZeroFactor * SrcAlphaFactor * SrcColorFactor - OneMinusSrcColorFactor * OneFactor * OneMinusSrcAlphaFactor, this._z = ZeroFactor * OneFactor * OneMinusSrcAlphaFactor + OneMinusSrcColorFactor * SrcAlphaFactor * SrcColorFactor, this._w = ZeroFactor * OneFactor * SrcColorFactor + OneMinusSrcColorFactor * SrcAlphaFactor * OneMinusSrcAlphaFactor;
                    break;
                default:
                    console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + AddEquation);
                }
                return !0 === t && this._onChangeCallback(), this;
            }
            setFromAxisAngle(REVISION, t) {
                const n = t / 2, i = Math.sin(n);
                return this._x = REVISION.x * i, this._y = REVISION.y * i, this._z = REVISION.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
            }
            setFromRotationMatrix(REVISION) {
                const t = REVISION.elements, n = t[0], i = t[4], r = t[8], AddEquation = t[1], SubtractEquation = t[5], ReverseSubtractEquation = t[9], ZeroFactor = t[2], OneFactor = t[6], SrcColorFactor = t[10], OneMinusSrcColorFactor = n + SubtractEquation + SrcColorFactor;
                if (OneMinusSrcColorFactor > 0) {
                    const REVISION = 0.5 / Math.sqrt(OneMinusSrcColorFactor + 1);
                    this._w = 0.25 / REVISION, this._x = (OneFactor - ReverseSubtractEquation) * REVISION, this._y = (r - ZeroFactor) * REVISION, this._z = (AddEquation - i) * REVISION;
                } else if (n > SubtractEquation && n > SrcColorFactor) {
                    const REVISION = 2 * Math.sqrt(1 + n - SubtractEquation - SrcColorFactor);
                    this._w = (OneFactor - ReverseSubtractEquation) / REVISION, this._x = 0.25 * REVISION, this._y = (i + AddEquation) / REVISION, this._z = (r + ZeroFactor) / REVISION;
                } else if (SubtractEquation > SrcColorFactor) {
                    const REVISION = 2 * Math.sqrt(1 + SubtractEquation - n - SrcColorFactor);
                    this._w = (r - ZeroFactor) / REVISION, this._x = (i + AddEquation) / REVISION, this._y = 0.25 * REVISION, this._z = (ReverseSubtractEquation + OneFactor) / REVISION;
                } else {
                    const REVISION = 2 * Math.sqrt(1 + SrcColorFactor - n - SubtractEquation);
                    this._w = (AddEquation - i) / REVISION, this._x = (r + ZeroFactor) / REVISION, this._y = (ReverseSubtractEquation + OneFactor) / REVISION, this._z = 0.25 * REVISION;
                }
                return this._onChangeCallback(), this;
            }
            setFromUnitVectors(REVISION, t) {
                let n = REVISION.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(REVISION.x) > Math.abs(REVISION.z) ? (this._x = -REVISION.y, this._y = REVISION.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -REVISION.z, this._z = REVISION.y, this._w = n)) : (this._x = REVISION.y * t.z - REVISION.z * t.y, this._y = REVISION.z * t.x - REVISION.x * t.z, this._z = REVISION.x * t.y - REVISION.y * t.x, this._w = n), this.normalize();
            }
            angleTo(REVISION) {
                return 2 * Math.acos(Math.abs(clamp(this.dot(REVISION), -1, 1)));
            }
            rotateTowards(REVISION, t) {
                const n = this.angleTo(REVISION);
                if (0 === n)
                    return this;
                const i = Math.min(1, t / n);
                return this.slerp(REVISION, i), this;
            }
            identity() {
                return this.set(0, 0, 0, 1);
            }
            invert() {
                return this.conjugate();
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
            }
            dot(REVISION) {
                return this._x * REVISION._x + this._y * REVISION._y + this._z * REVISION._z + this._w * REVISION._w;
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
            }
            normalize() {
                let REVISION = this.length();
                return 0 === REVISION ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (REVISION = 1 / REVISION, this._x = this._x * REVISION, this._y = this._y * REVISION, this._z = this._z * REVISION, this._w = this._w * REVISION), this._onChangeCallback(), this;
            }
            multiply(REVISION) {
                return this.multiplyQuaternions(this, REVISION);
            }
            premultiply(REVISION) {
                return this.multiplyQuaternions(REVISION, this);
            }
            multiplyQuaternions(REVISION, t) {
                const n = REVISION._x, i = REVISION._y, r = REVISION._z, AddEquation = REVISION._w, SubtractEquation = t._x, ReverseSubtractEquation = t._y, ZeroFactor = t._z, OneFactor = t._w;
                return this._x = n * OneFactor + AddEquation * SubtractEquation + i * ZeroFactor - r * ReverseSubtractEquation, this._y = i * OneFactor + AddEquation * ReverseSubtractEquation + r * SubtractEquation - n * ZeroFactor, this._z = r * OneFactor + AddEquation * ZeroFactor + n * ReverseSubtractEquation - i * SubtractEquation, this._w = AddEquation * OneFactor - n * SubtractEquation - i * ReverseSubtractEquation - r * ZeroFactor, this._onChangeCallback(), this;
            }
            slerp(REVISION, t) {
                if (0 === t)
                    return this;
                if (1 === t)
                    return this.copy(REVISION);
                const n = this._x, i = this._y, r = this._z, AddEquation = this._w;
                let SubtractEquation = AddEquation * REVISION._w + n * REVISION._x + i * REVISION._y + r * REVISION._z;
                if (SubtractEquation < 0 ? (this._w = -REVISION._w, this._x = -REVISION._x, this._y = -REVISION._y, this._z = -REVISION._z, SubtractEquation = -SubtractEquation) : this.copy(REVISION), SubtractEquation >= 1)
                    return this._w = AddEquation, this._x = n, this._y = i, this._z = r, this;
                const ReverseSubtractEquation = 1 - SubtractEquation * SubtractEquation;
                if (ReverseSubtractEquation <= Number.EPSILON) {
                    const REVISION = 1 - t;
                    return this._w = REVISION * AddEquation + t * this._w, this._x = REVISION * n + t * this._x, this._y = REVISION * i + t * this._y, this._z = REVISION * r + t * this._z, this.normalize(), this;
                }
                const ZeroFactor = Math.sqrt(ReverseSubtractEquation), OneFactor = Math.atan2(ZeroFactor, SubtractEquation), SrcColorFactor = Math.sin((1 - t) * OneFactor) / ZeroFactor, OneMinusSrcColorFactor = Math.sin(t * OneFactor) / ZeroFactor;
                return this._w = AddEquation * SrcColorFactor + this._w * OneMinusSrcColorFactor, this._x = n * SrcColorFactor + this._x * OneMinusSrcColorFactor, this._y = i * SrcColorFactor + this._y * OneMinusSrcColorFactor, this._z = r * SrcColorFactor + this._z * OneMinusSrcColorFactor, this._onChangeCallback(), this;
            }
            slerpQuaternions(REVISION, t, n) {
                return this.copy(REVISION).slerp(t, n);
            }
            random() {
                const REVISION = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), r = Math.sqrt(n);
                return this.set(i * Math.sin(REVISION), i * Math.cos(REVISION), r * Math.sin(t), r * Math.cos(t));
            }
            equals(REVISION) {
                return REVISION._x === this._x && REVISION._y === this._y && REVISION._z === this._z && REVISION._w === this._w;
            }
            fromArray(REVISION, t = 0) {
                return this._x = REVISION[t], this._y = REVISION[t + 1], this._z = REVISION[t + 2], this._w = REVISION[t + 3], this._onChangeCallback(), this;
            }
            toArray(REVISION = [], t = 0) {
                return REVISION[t] = this._x, REVISION[t + 1] = this._y, REVISION[t + 2] = this._z, REVISION[t + 3] = this._w, REVISION;
            }
            fromBufferAttribute(REVISION, t) {
                return this._x = REVISION.getX(t), this._y = REVISION.getY(t), this._z = REVISION.getZ(t), this._w = REVISION.getW(t), this._onChangeCallback(), this;
            }
            toJSON() {
                return this.toArray();
            }
            _onChange(REVISION) {
                return this._onChangeCallback = REVISION, this;
            }
            _onChangeCallback() {
            }
            *[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w;
            }
        }
        class Vector3 {
            constructor(REVISION = 0, t = 0, n = 0) {
                Vector3.prototype.isVector3 = !0, this.x = REVISION, this.y = t, this.z = n;
            }
            set(REVISION, t, n) {
                return void 0 === n && (n = this.z), this.x = REVISION, this.y = t, this.z = n, this;
            }
            setScalar(REVISION) {
                return this.x = REVISION, this.y = REVISION, this.z = REVISION, this;
            }
            setX(REVISION) {
                return this.x = REVISION, this;
            }
            setY(REVISION) {
                return this.y = REVISION, this;
            }
            setZ(REVISION) {
                return this.z = REVISION, this;
            }
            setComponent(REVISION, t) {
                switch (REVISION) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error('index is out of range: ' + REVISION);
                }
                return this;
            }
            getComponent(REVISION) {
                switch (REVISION) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error('index is out of range: ' + REVISION);
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z);
            }
            copy(REVISION) {
                return this.x = REVISION.x, this.y = REVISION.y, this.z = REVISION.z, this;
            }
            add(REVISION) {
                return this.x += REVISION.x, this.y += REVISION.y, this.z += REVISION.z, this;
            }
            addScalar(REVISION) {
                return this.x += REVISION, this.y += REVISION, this.z += REVISION, this;
            }
            addVectors(REVISION, t) {
                return this.x = REVISION.x + t.x, this.y = REVISION.y + t.y, this.z = REVISION.z + t.z, this;
            }
            addScaledVector(REVISION, t) {
                return this.x += REVISION.x * t, this.y += REVISION.y * t, this.z += REVISION.z * t, this;
            }
            sub(REVISION) {
                return this.x -= REVISION.x, this.y -= REVISION.y, this.z -= REVISION.z, this;
            }
            subScalar(REVISION) {
                return this.x -= REVISION, this.y -= REVISION, this.z -= REVISION, this;
            }
            subVectors(REVISION, t) {
                return this.x = REVISION.x - t.x, this.y = REVISION.y - t.y, this.z = REVISION.z - t.z, this;
            }
            multiply(REVISION) {
                return this.x *= REVISION.x, this.y *= REVISION.y, this.z *= REVISION.z, this;
            }
            multiplyScalar(REVISION) {
                return this.x *= REVISION, this.y *= REVISION, this.z *= REVISION, this;
            }
            multiplyVectors(REVISION, t) {
                return this.x = REVISION.x * t.x, this.y = REVISION.y * t.y, this.z = REVISION.z * t.z, this;
            }
            applyEuler(REVISION) {
                return this.applyQuaternion(_quaternion$4.setFromEuler(REVISION));
            }
            applyAxisAngle(REVISION, t) {
                return this.applyQuaternion(_quaternion$4.setFromAxisAngle(REVISION, t));
            }
            applyMatrix3(REVISION) {
                const t = this.x, n = this.y, i = this.z, r = REVISION.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
            }
            applyNormalMatrix(REVISION) {
                return this.applyMatrix3(REVISION).normalize();
            }
            applyMatrix4(REVISION) {
                const t = this.x, n = this.y, i = this.z, r = REVISION.elements, AddEquation = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * AddEquation, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * AddEquation, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * AddEquation, this;
            }
            applyQuaternion(REVISION) {
                const t = this.x, n = this.y, i = this.z, r = REVISION.x, AddEquation = REVISION.y, SubtractEquation = REVISION.z, ReverseSubtractEquation = REVISION.w, ZeroFactor = 2 * (AddEquation * i - SubtractEquation * n), OneFactor = 2 * (SubtractEquation * t - r * i), SrcColorFactor = 2 * (r * n - AddEquation * t);
                return this.x = t + ReverseSubtractEquation * ZeroFactor + AddEquation * SrcColorFactor - SubtractEquation * OneFactor, this.y = n + ReverseSubtractEquation * OneFactor + SubtractEquation * ZeroFactor - r * SrcColorFactor, this.z = i + ReverseSubtractEquation * SrcColorFactor + r * OneFactor - AddEquation * ZeroFactor, this;
            }
            project(REVISION) {
                return this.applyMatrix4(REVISION.matrixWorldInverse).applyMatrix4(REVISION.projectionMatrix);
            }
            unproject(REVISION) {
                return this.applyMatrix4(REVISION.projectionMatrixInverse).applyMatrix4(REVISION.matrixWorld);
            }
            transformDirection(REVISION) {
                const t = this.x, n = this.y, i = this.z, r = REVISION.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
            }
            divide(REVISION) {
                return this.x /= REVISION.x, this.y /= REVISION.y, this.z /= REVISION.z, this;
            }
            divideScalar(REVISION) {
                return this.multiplyScalar(1 / REVISION);
            }
            min(REVISION) {
                return this.x = Math.min(this.x, REVISION.x), this.y = Math.min(this.y, REVISION.y), this.z = Math.min(this.z, REVISION.z), this;
            }
            max(REVISION) {
                return this.x = Math.max(this.x, REVISION.x), this.y = Math.max(this.y, REVISION.y), this.z = Math.max(this.z, REVISION.z), this;
            }
            clamp(REVISION, t) {
                return this.x = clamp(this.x, REVISION.x, t.x), this.y = clamp(this.y, REVISION.y, t.y), this.z = clamp(this.z, REVISION.z, t.z), this;
            }
            clampScalar(REVISION, t) {
                return this.x = clamp(this.x, REVISION, t), this.y = clamp(this.y, REVISION, t), this.z = clamp(this.z, REVISION, t), this;
            }
            clampLength(REVISION, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(clamp(n, REVISION, t));
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
            }
            dot(REVISION) {
                return this.x * REVISION.x + this.y * REVISION.y + this.z * REVISION.z;
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
            }
            normalize() {
                return this.divideScalar(this.length() || 1);
            }
            setLength(REVISION) {
                return this.normalize().multiplyScalar(REVISION);
            }
            lerp(REVISION, t) {
                return this.x += (REVISION.x - this.x) * t, this.y += (REVISION.y - this.y) * t, this.z += (REVISION.z - this.z) * t, this;
            }
            lerpVectors(REVISION, t, n) {
                return this.x = REVISION.x + (t.x - REVISION.x) * n, this.y = REVISION.y + (t.y - REVISION.y) * n, this.z = REVISION.z + (t.z - REVISION.z) * n, this;
            }
            cross(REVISION) {
                return this.crossVectors(this, REVISION);
            }
            crossVectors(REVISION, t) {
                const n = REVISION.x, i = REVISION.y, r = REVISION.z, AddEquation = t.x, SubtractEquation = t.y, ReverseSubtractEquation = t.z;
                return this.x = i * ReverseSubtractEquation - r * SubtractEquation, this.y = r * AddEquation - n * ReverseSubtractEquation, this.z = n * SubtractEquation - i * AddEquation, this;
            }
            projectOnVector(REVISION) {
                const t = REVISION.lengthSq();
                if (0 === t)
                    return this.set(0, 0, 0);
                const n = REVISION.dot(this) / t;
                return this.copy(REVISION).multiplyScalar(n);
            }
            projectOnPlane(REVISION) {
                return _vector$c.copy(this).projectOnVector(REVISION), this.sub(_vector$c);
            }
            reflect(REVISION) {
                return this.sub(_vector$c.copy(REVISION).multiplyScalar(2 * this.dot(REVISION)));
            }
            angleTo(REVISION) {
                const t = Math.sqrt(this.lengthSq() * REVISION.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(REVISION) / t;
                return Math.acos(clamp(n, -1, 1));
            }
            distanceTo(REVISION) {
                return Math.sqrt(this.distanceToSquared(REVISION));
            }
            distanceToSquared(REVISION) {
                const t = this.x - REVISION.x, n = this.y - REVISION.y, i = this.z - REVISION.z;
                return t * t + n * n + i * i;
            }
            manhattanDistanceTo(REVISION) {
                return Math.abs(this.x - REVISION.x) + Math.abs(this.y - REVISION.y) + Math.abs(this.z - REVISION.z);
            }
            setFromSpherical(REVISION) {
                return this.setFromSphericalCoords(REVISION.radius, REVISION.phi, REVISION.theta);
            }
            setFromSphericalCoords(REVISION, t, n) {
                const i = Math.sin(t) * REVISION;
                return this.x = i * Math.sin(n), this.y = Math.cos(t) * REVISION, this.z = i * Math.cos(n), this;
            }
            setFromCylindrical(REVISION) {
                return this.setFromCylindricalCoords(REVISION.radius, REVISION.theta, REVISION.y);
            }
            setFromCylindricalCoords(REVISION, t, n) {
                return this.x = REVISION * Math.sin(t), this.y = n, this.z = REVISION * Math.cos(t), this;
            }
            setFromMatrixPosition(REVISION) {
                const t = REVISION.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this;
            }
            setFromMatrixScale(REVISION) {
                const t = this.setFromMatrixColumn(REVISION, 0).length(), n = this.setFromMatrixColumn(REVISION, 1).length(), i = this.setFromMatrixColumn(REVISION, 2).length();
                return this.x = t, this.y = n, this.z = i, this;
            }
            setFromMatrixColumn(REVISION, t) {
                return this.fromArray(REVISION.elements, 4 * t);
            }
            setFromMatrix3Column(REVISION, t) {
                return this.fromArray(REVISION.elements, 3 * t);
            }
            setFromEuler(REVISION) {
                return this.x = REVISION._x, this.y = REVISION._y, this.z = REVISION._z, this;
            }
            setFromColor(REVISION) {
                return this.x = REVISION.r, this.y = REVISION.g, this.z = REVISION.b, this;
            }
            equals(REVISION) {
                return REVISION.x === this.x && REVISION.y === this.y && REVISION.z === this.z;
            }
            fromArray(REVISION, t = 0) {
                return this.x = REVISION[t], this.y = REVISION[t + 1], this.z = REVISION[t + 2], this;
            }
            toArray(REVISION = [], t = 0) {
                return REVISION[t] = this.x, REVISION[t + 1] = this.y, REVISION[t + 2] = this.z, REVISION;
            }
            fromBufferAttribute(REVISION, t) {
                return this.x = REVISION.getX(t), this.y = REVISION.getY(t), this.z = REVISION.getZ(t), this;
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
            }
            randomDirection() {
                const REVISION = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, n = Math.sqrt(1 - t * t);
                return this.x = n * Math.cos(REVISION), this.y = t, this.z = n * Math.sin(REVISION), this;
            }
            *[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z;
            }
        }
        const _vector$c = new Vector3(), _quaternion$4 = new Quaternion();
        class Box3 {
            constructor(REVISION = new Vector3(1 / 0, 1 / 0, 1 / 0), t = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = REVISION, this.max = t;
            }
            set(REVISION, t) {
                return this.min.copy(REVISION), this.max.copy(t), this;
            }
            setFromArray(REVISION) {
                this.makeEmpty();
                for (let t = 0, n = REVISION.length; t < n; t += 3)
                    this.expandByPoint(_vector$b.fromArray(REVISION, t));
                return this;
            }
            setFromBufferAttribute(REVISION) {
                this.makeEmpty();
                for (let t = 0, n = REVISION.count; t < n; t++)
                    this.expandByPoint(_vector$b.fromBufferAttribute(REVISION, t));
                return this;
            }
            setFromPoints(REVISION) {
                this.makeEmpty();
                for (let t = 0, n = REVISION.length; t < n; t++)
                    this.expandByPoint(REVISION[t]);
                return this;
            }
            setFromCenterAndSize(REVISION, t) {
                const n = _vector$b.copy(t).multiplyScalar(0.5);
                return this.min.copy(REVISION).sub(n), this.max.copy(REVISION).add(n), this;
            }
            setFromObject(REVISION, t = !1) {
                return this.makeEmpty(), this.expandByObject(REVISION, t);
            }
            clone() {
                return new this.constructor().copy(this);
            }
            copy(REVISION) {
                return this.min.copy(REVISION.min), this.max.copy(REVISION.max), this;
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            }
            getCenter(REVISION) {
                return this.isEmpty() ? REVISION.set(0, 0, 0) : REVISION.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
            getSize(REVISION) {
                return this.isEmpty() ? REVISION.set(0, 0, 0) : REVISION.subVectors(this.max, this.min);
            }
            expandByPoint(REVISION) {
                return this.min.min(REVISION), this.max.max(REVISION), this;
            }
            expandByVector(REVISION) {
                return this.min.sub(REVISION), this.max.add(REVISION), this;
            }
            expandByScalar(REVISION) {
                return this.min.addScalar(-REVISION), this.max.addScalar(REVISION), this;
            }
            expandByObject(REVISION, t = !1) {
                REVISION.updateWorldMatrix(!1, !1);
                const n = REVISION.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute('position');
                    if (!0 === t && void 0 !== i && !0 !== REVISION.isInstancedMesh)
                        for (let t = 0, n = i.count; t < n; t++)
                            !0 === REVISION.isMesh ? REVISION.getVertexPosition(t, _vector$b) : _vector$b.fromBufferAttribute(i, t), _vector$b.applyMatrix4(REVISION.matrixWorld), this.expandByPoint(_vector$b);
                    else
                        void 0 !== REVISION.boundingBox ? (null === REVISION.boundingBox && REVISION.computeBoundingBox(), _box$4.copy(REVISION.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), _box$4.copy(n.boundingBox)), _box$4.applyMatrix4(REVISION.matrixWorld), this.union(_box$4);
                }
                const i = REVISION.children;
                for (let REVISION = 0, n = i.length; REVISION < n; REVISION++)
                    this.expandByObject(i[REVISION], t);
                return this;
            }
            containsPoint(REVISION) {
                return REVISION.x >= this.min.x && REVISION.x <= this.max.x && REVISION.y >= this.min.y && REVISION.y <= this.max.y && REVISION.z >= this.min.z && REVISION.z <= this.max.z;
            }
            containsBox(REVISION) {
                return this.min.x <= REVISION.min.x && REVISION.max.x <= this.max.x && this.min.y <= REVISION.min.y && REVISION.max.y <= this.max.y && this.min.z <= REVISION.min.z && REVISION.max.z <= this.max.z;
            }
            getParameter(REVISION, t) {
                return t.set((REVISION.x - this.min.x) / (this.max.x - this.min.x), (REVISION.y - this.min.y) / (this.max.y - this.min.y), (REVISION.z - this.min.z) / (this.max.z - this.min.z));
            }
            intersectsBox(REVISION) {
                return REVISION.max.x >= this.min.x && REVISION.min.x <= this.max.x && REVISION.max.y >= this.min.y && REVISION.min.y <= this.max.y && REVISION.max.z >= this.min.z && REVISION.min.z <= this.max.z;
            }
            intersectsSphere(REVISION) {
                return this.clampPoint(REVISION.center, _vector$b), _vector$b.distanceToSquared(REVISION.center) <= REVISION.radius * REVISION.radius;
            }
            intersectsPlane(REVISION) {
                let t, n;
                return REVISION.normal.x > 0 ? (t = REVISION.normal.x * this.min.x, n = REVISION.normal.x * this.max.x) : (t = REVISION.normal.x * this.max.x, n = REVISION.normal.x * this.min.x), REVISION.normal.y > 0 ? (t += REVISION.normal.y * this.min.y, n += REVISION.normal.y * this.max.y) : (t += REVISION.normal.y * this.max.y, n += REVISION.normal.y * this.min.y), REVISION.normal.z > 0 ? (t += REVISION.normal.z * this.min.z, n += REVISION.normal.z * this.max.z) : (t += REVISION.normal.z * this.max.z, n += REVISION.normal.z * this.min.z), t <= -REVISION.constant && n >= -REVISION.constant;
            }
            intersectsTriangle(REVISION) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(REVISION.a, _center), _v1$7.subVectors(REVISION.b, _center), _v2$4.subVectors(REVISION.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$4, _v1$7), _f2.subVectors(_v0$2, _v2$4);
                let t = [
                    0,
                    -_f0.z,
                    _f0.y,
                    0,
                    -_f1.z,
                    _f1.y,
                    0,
                    -_f2.z,
                    _f2.y,
                    _f0.z,
                    0,
                    -_f0.x,
                    _f1.z,
                    0,
                    -_f1.x,
                    _f2.z,
                    0,
                    -_f2.x,
                    -_f0.y,
                    _f0.x,
                    0,
                    -_f1.y,
                    _f1.x,
                    0,
                    -_f2.y,
                    _f2.x,
                    0
                ];
                return !!mn(t, _v0$2, _v1$7, _v2$4, _extents) && (t = [
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ], !!mn(t, _v0$2, _v1$7, _v2$4, _extents) && (_triangleNormal.crossVectors(_f0, _f1), t = [
                    _triangleNormal.x,
                    _triangleNormal.y,
                    _triangleNormal.z
                ], mn(t, _v0$2, _v1$7, _v2$4, _extents)));
            }
            clampPoint(REVISION, t) {
                return t.copy(REVISION).clamp(this.min, this.max);
            }
            distanceToPoint(REVISION) {
                return this.clampPoint(REVISION, _vector$b).distanceTo(REVISION);
            }
            getBoundingSphere(REVISION) {
                return this.isEmpty() ? REVISION.makeEmpty() : (this.getCenter(REVISION.center), REVISION.radius = 0.5 * this.getSize(_vector$b).length()), REVISION;
            }
            intersect(REVISION) {
                return this.min.max(REVISION.min), this.max.min(REVISION.max), this.isEmpty() && this.makeEmpty(), this;
            }
            union(REVISION) {
                return this.min.min(REVISION.min), this.max.max(REVISION.max), this;
            }
            applyMatrix4(REVISION) {
                return this.isEmpty() || (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(REVISION), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(REVISION), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(REVISION), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(REVISION), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(REVISION), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(REVISION), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(REVISION), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(REVISION), this.setFromPoints(_points)), this;
            }
            translate(REVISION) {
                return this.min.add(REVISION), this.max.add(REVISION), this;
            }
            equals(REVISION) {
                return REVISION.min.equals(this.min) && REVISION.max.equals(this.max);
            }
        }
        const _points = [
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3()
            ], _vector$b = new Vector3(), _box$4 = new Box3(), _v0$2 = new Vector3(), _v1$7 = new Vector3(), _v2$4 = new Vector3(), _f0 = new Vector3(), _f1 = new Vector3(), _f2 = new Vector3(), _center = new Vector3(), _extents = new Vector3(), _triangleNormal = new Vector3(), _testAxis = new Vector3();
        function mn(REVISION, t, n, i, r) {
            for (let AddEquation = 0, SubtractEquation = REVISION.length - 3; AddEquation <= SubtractEquation; AddEquation += 3) {
                _testAxis.fromArray(REVISION, AddEquation);
                const SubtractEquation = r.x * Math.abs(_testAxis.x) + r.y * Math.abs(_testAxis.y) + r.z * Math.abs(_testAxis.z), ReverseSubtractEquation = t.dot(_testAxis), ZeroFactor = n.dot(_testAxis), OneFactor = i.dot(_testAxis);
                if (Math.max(-Math.max(ReverseSubtractEquation, ZeroFactor, OneFactor), Math.min(ReverseSubtractEquation, ZeroFactor, OneFactor)) > SubtractEquation)
                    return !1;
            }
            return !0;
        }
        const _box$3 = new Box3(), _v1$6 = new Vector3(), _v2$3 = new Vector3();
        class Sphere {
            constructor(REVISION = new Vector3(), t = -1) {
                this.isSphere = !0, this.center = REVISION, this.radius = t;
            }
            set(REVISION, t) {
                return this.center.copy(REVISION), this.radius = t, this;
            }
            setFromPoints(REVISION, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : _box$3.setFromPoints(REVISION).getCenter(n);
                let i = 0;
                for (let t = 0, r = REVISION.length; t < r; t++)
                    i = Math.max(i, n.distanceToSquared(REVISION[t]));
                return this.radius = Math.sqrt(i), this;
            }
            copy(REVISION) {
                return this.center.copy(REVISION.center), this.radius = REVISION.radius, this;
            }
            isEmpty() {
                return this.radius < 0;
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this;
            }
            containsPoint(REVISION) {
                return REVISION.distanceToSquared(this.center) <= this.radius * this.radius;
            }
            distanceToPoint(REVISION) {
                return REVISION.distanceTo(this.center) - this.radius;
            }
            intersectsSphere(REVISION) {
                const t = this.radius + REVISION.radius;
                return REVISION.center.distanceToSquared(this.center) <= t * t;
            }
            intersectsBox(REVISION) {
                return REVISION.intersectsSphere(this);
            }
            intersectsPlane(REVISION) {
                return Math.abs(REVISION.distanceToPoint(this.center)) <= this.radius;
            }
            clampPoint(REVISION, t) {
                const n = this.center.distanceToSquared(REVISION);
                return t.copy(REVISION), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
            }
            getBoundingBox(REVISION) {
                return this.isEmpty() ? (REVISION.makeEmpty(), REVISION) : (REVISION.set(this.center, this.center), REVISION.expandByScalar(this.radius), REVISION);
            }
            applyMatrix4(REVISION) {
                return this.center.applyMatrix4(REVISION), this.radius = this.radius * REVISION.getMaxScaleOnAxis(), this;
            }
            translate(REVISION) {
                return this.center.add(REVISION), this;
            }
            expandByPoint(REVISION) {
                if (this.isEmpty())
                    return this.center.copy(REVISION), this.radius = 0, this;
                _v1$6.subVectors(REVISION, this.center);
                const t = _v1$6.lengthSq();
                if (t > this.radius * this.radius) {
                    const REVISION = Math.sqrt(t), n = 0.5 * (REVISION - this.radius);
                    this.center.addScaledVector(_v1$6, n / REVISION), this.radius += n;
                }
                return this;
            }
            union(REVISION) {
                return REVISION.isEmpty() ? this : this.isEmpty() ? (this.copy(REVISION), this) : (!0 === this.center.equals(REVISION.center) ? this.radius = Math.max(this.radius, REVISION.radius) : (_v2$3.subVectors(REVISION.center, this.center).setLength(REVISION.radius), this.expandByPoint(_v1$6.copy(REVISION.center).add(_v2$3)), this.expandByPoint(_v1$6.copy(REVISION.center).sub(_v2$3))), this);
            }
            equals(REVISION) {
                return REVISION.center.equals(this.center) && REVISION.radius === this.radius;
            }
            clone() {
                return new this.constructor().copy(this);
            }
        }
        const _vector$a = new Vector3(), _segCenter = new Vector3(), _segDir = new Vector3(), _diff = new Vector3(), _edge1 = new Vector3(), _edge2 = new Vector3(), _normal$1 = new Vector3();
        class Ray {
            constructor(REVISION = new Vector3(), t = new Vector3(0, 0, -1)) {
                this.origin = REVISION, this.direction = t;
            }
            set(REVISION, t) {
                return this.origin.copy(REVISION), this.direction.copy(t), this;
            }
            copy(REVISION) {
                return this.origin.copy(REVISION.origin), this.direction.copy(REVISION.direction), this;
            }
            at(REVISION, t) {
                return t.copy(this.origin).addScaledVector(this.direction, REVISION);
            }
            lookAt(REVISION) {
                return this.direction.copy(REVISION).sub(this.origin).normalize(), this;
            }
            recast(REVISION) {
                return this.origin.copy(this.at(REVISION, _vector$a)), this;
            }
            closestPointToPoint(REVISION, t) {
                t.subVectors(REVISION, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
            }
            distanceToPoint(REVISION) {
                return Math.sqrt(this.distanceSqToPoint(REVISION));
            }
            distanceSqToPoint(REVISION) {
                const t = _vector$a.subVectors(REVISION, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(REVISION) : (_vector$a.copy(this.origin).addScaledVector(this.direction, t), _vector$a.distanceToSquared(REVISION));
            }
            distanceSqToSegment(REVISION, t, n, i) {
                _segCenter.copy(REVISION).add(t).multiplyScalar(0.5), _segDir.copy(t).sub(REVISION).normalize(), _diff.copy(this.origin).sub(_segCenter);
                const r = 0.5 * REVISION.distanceTo(t), AddEquation = -this.direction.dot(_segDir), SubtractEquation = _diff.dot(this.direction), ReverseSubtractEquation = -_diff.dot(_segDir), ZeroFactor = _diff.lengthSq(), OneFactor = Math.abs(1 - AddEquation * AddEquation);
                let SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor;
                if (OneFactor > 0)
                    if (SrcColorFactor = AddEquation * ReverseSubtractEquation - SubtractEquation, OneMinusSrcColorFactor = AddEquation * SubtractEquation - ReverseSubtractEquation, OneMinusSrcAlphaFactor = r * OneFactor, SrcColorFactor >= 0)
                        if (OneMinusSrcColorFactor >= -OneMinusSrcAlphaFactor)
                            if (OneMinusSrcColorFactor <= OneMinusSrcAlphaFactor) {
                                const REVISION = 1 / OneFactor;
                                SrcColorFactor *= REVISION, OneMinusSrcColorFactor *= REVISION, SrcAlphaFactor = SrcColorFactor * (SrcColorFactor + AddEquation * OneMinusSrcColorFactor + 2 * SubtractEquation) + OneMinusSrcColorFactor * (AddEquation * SrcColorFactor + OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor;
                            } else
                                OneMinusSrcColorFactor = r, SrcColorFactor = Math.max(0, -(AddEquation * OneMinusSrcColorFactor + SubtractEquation)), SrcAlphaFactor = -SrcColorFactor * SrcColorFactor + OneMinusSrcColorFactor * (OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor;
                        else
                            OneMinusSrcColorFactor = -r, SrcColorFactor = Math.max(0, -(AddEquation * OneMinusSrcColorFactor + SubtractEquation)), SrcAlphaFactor = -SrcColorFactor * SrcColorFactor + OneMinusSrcColorFactor * (OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor;
                    else
                        OneMinusSrcColorFactor <= -OneMinusSrcAlphaFactor ? (SrcColorFactor = Math.max(0, -(-AddEquation * r + SubtractEquation)), OneMinusSrcColorFactor = SrcColorFactor > 0 ? -r : Math.min(Math.max(-r, -ReverseSubtractEquation), r), SrcAlphaFactor = -SrcColorFactor * SrcColorFactor + OneMinusSrcColorFactor * (OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor) : OneMinusSrcColorFactor <= OneMinusSrcAlphaFactor ? (SrcColorFactor = 0, OneMinusSrcColorFactor = Math.min(Math.max(-r, -ReverseSubtractEquation), r), SrcAlphaFactor = OneMinusSrcColorFactor * (OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor) : (SrcColorFactor = Math.max(0, -(AddEquation * r + SubtractEquation)), OneMinusSrcColorFactor = SrcColorFactor > 0 ? r : Math.min(Math.max(-r, -ReverseSubtractEquation), r), SrcAlphaFactor = -SrcColorFactor * SrcColorFactor + OneMinusSrcColorFactor * (OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor);
                else
                    OneMinusSrcColorFactor = AddEquation > 0 ? -r : r, SrcColorFactor = Math.max(0, -(AddEquation * OneMinusSrcColorFactor + SubtractEquation)), SrcAlphaFactor = -SrcColorFactor * SrcColorFactor + OneMinusSrcColorFactor * (OneMinusSrcColorFactor + 2 * ReverseSubtractEquation) + ZeroFactor;
                return n && n.copy(this.origin).addScaledVector(this.direction, SrcColorFactor), i && i.copy(_segCenter).addScaledVector(_segDir, OneMinusSrcColorFactor), SrcAlphaFactor;
            }
            intersectSphere(REVISION, t) {
                _vector$a.subVectors(REVISION.center, this.origin);
                const n = _vector$a.dot(this.direction), i = _vector$a.dot(_vector$a) - n * n, r = REVISION.radius * REVISION.radius;
                if (i > r)
                    return null;
                const AddEquation = Math.sqrt(r - i), SubtractEquation = n - AddEquation, ReverseSubtractEquation = n + AddEquation;
                return ReverseSubtractEquation < 0 ? null : SubtractEquation < 0 ? this.at(ReverseSubtractEquation, t) : this.at(SubtractEquation, t);
            }
            intersectsSphere(REVISION) {
                return this.distanceSqToPoint(REVISION.center) <= REVISION.radius * REVISION.radius;
            }
            distanceToPlane(REVISION) {
                const t = REVISION.normal.dot(this.direction);
                if (0 === t)
                    return 0 === REVISION.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(REVISION.normal) + REVISION.constant) / t;
                return n >= 0 ? n : null;
            }
            intersectPlane(REVISION, t) {
                const n = this.distanceToPlane(REVISION);
                return null === n ? null : this.at(n, t);
            }
            intersectsPlane(REVISION) {
                const t = REVISION.distanceToPoint(this.origin);
                if (0 === t)
                    return !0;
                return REVISION.normal.dot(this.direction) * t < 0;
            }
            intersectBox(REVISION, t) {
                let n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation;
                const ZeroFactor = 1 / this.direction.x, OneFactor = 1 / this.direction.y, SrcColorFactor = 1 / this.direction.z, OneMinusSrcColorFactor = this.origin;
                return ZeroFactor >= 0 ? (n = (REVISION.min.x - OneMinusSrcColorFactor.x) * ZeroFactor, i = (REVISION.max.x - OneMinusSrcColorFactor.x) * ZeroFactor) : (n = (REVISION.max.x - OneMinusSrcColorFactor.x) * ZeroFactor, i = (REVISION.min.x - OneMinusSrcColorFactor.x) * ZeroFactor), OneFactor >= 0 ? (r = (REVISION.min.y - OneMinusSrcColorFactor.y) * OneFactor, AddEquation = (REVISION.max.y - OneMinusSrcColorFactor.y) * OneFactor) : (r = (REVISION.max.y - OneMinusSrcColorFactor.y) * OneFactor, AddEquation = (REVISION.min.y - OneMinusSrcColorFactor.y) * OneFactor), n > AddEquation || r > i ? null : ((r > n || isNaN(n)) && (n = r), (AddEquation < i || isNaN(i)) && (i = AddEquation), SrcColorFactor >= 0 ? (SubtractEquation = (REVISION.min.z - OneMinusSrcColorFactor.z) * SrcColorFactor, ReverseSubtractEquation = (REVISION.max.z - OneMinusSrcColorFactor.z) * SrcColorFactor) : (SubtractEquation = (REVISION.max.z - OneMinusSrcColorFactor.z) * SrcColorFactor, ReverseSubtractEquation = (REVISION.min.z - OneMinusSrcColorFactor.z) * SrcColorFactor), n > ReverseSubtractEquation || SubtractEquation > i ? null : ((SubtractEquation > n || n != n) && (n = SubtractEquation), (ReverseSubtractEquation < i || i != i) && (i = ReverseSubtractEquation), i < 0 ? null : this.at(n >= 0 ? n : i, t)));
            }
            intersectsBox(REVISION) {
                return null !== this.intersectBox(REVISION, _vector$a);
            }
            intersectTriangle(REVISION, t, n, i, r) {
                _edge1.subVectors(t, REVISION), _edge2.subVectors(n, REVISION), _normal$1.crossVectors(_edge1, _edge2);
                let AddEquation, SubtractEquation = this.direction.dot(_normal$1);
                if (SubtractEquation > 0) {
                    if (i)
                        return null;
                    AddEquation = 1;
                } else {
                    if (!(SubtractEquation < 0))
                        return null;
                    AddEquation = -1, SubtractEquation = -SubtractEquation;
                }
                _diff.subVectors(this.origin, REVISION);
                const ReverseSubtractEquation = AddEquation * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
                if (ReverseSubtractEquation < 0)
                    return null;
                const ZeroFactor = AddEquation * this.direction.dot(_edge1.cross(_diff));
                if (ZeroFactor < 0)
                    return null;
                if (ReverseSubtractEquation + ZeroFactor > SubtractEquation)
                    return null;
                const OneFactor = -AddEquation * _diff.dot(_normal$1);
                return OneFactor < 0 ? null : this.at(OneFactor / SubtractEquation, r);
            }
            applyMatrix4(REVISION) {
                return this.origin.applyMatrix4(REVISION), this.direction.transformDirection(REVISION), this;
            }
            equals(REVISION) {
                return REVISION.origin.equals(this.origin) && REVISION.direction.equals(this.direction);
            }
            clone() {
                return new this.constructor().copy(this);
            }
        }
        class Matrix4 {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor) {
                Matrix4.prototype.isMatrix4 = !0, this.elements = [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ], void 0 !== REVISION && this.set(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor);
            }
            set(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor) {
                const DstColorFactor = this.elements;
                return DstColorFactor[0] = REVISION, DstColorFactor[4] = t, DstColorFactor[8] = n, DstColorFactor[12] = i, DstColorFactor[1] = r, DstColorFactor[5] = AddEquation, DstColorFactor[9] = SubtractEquation, DstColorFactor[13] = ReverseSubtractEquation, DstColorFactor[2] = ZeroFactor, DstColorFactor[6] = OneFactor, DstColorFactor[10] = SrcColorFactor, DstColorFactor[14] = OneMinusSrcColorFactor, DstColorFactor[3] = SrcAlphaFactor, DstColorFactor[7] = OneMinusSrcAlphaFactor, DstColorFactor[11] = DstAlphaFactor, DstColorFactor[15] = OneMinusDstAlphaFactor, this;
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
            }
            clone() {
                return new Matrix4().fromArray(this.elements);
            }
            copy(REVISION) {
                const t = this.elements, n = REVISION.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
            }
            copyPosition(REVISION) {
                const t = this.elements, n = REVISION.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
            }
            setFromMatrix3(REVISION) {
                const t = REVISION.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
            }
            extractBasis(REVISION, t, n) {
                return REVISION.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
            }
            makeBasis(REVISION, t, n) {
                return this.set(REVISION.x, t.x, n.x, 0, REVISION.y, t.y, n.y, 0, REVISION.z, t.z, n.z, 0, 0, 0, 0, 1), this;
            }
            extractRotation(REVISION) {
                const t = this.elements, n = REVISION.elements, i = 1 / _v1$5.setFromMatrixColumn(REVISION, 0).length(), r = 1 / _v1$5.setFromMatrixColumn(REVISION, 1).length(), AddEquation = 1 / _v1$5.setFromMatrixColumn(REVISION, 2).length();
                return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * AddEquation, t[9] = n[9] * AddEquation, t[10] = n[10] * AddEquation, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
            }
            makeRotationFromEuler(REVISION) {
                const t = this.elements, n = REVISION.x, i = REVISION.y, r = REVISION.z, AddEquation = Math.cos(n), SubtractEquation = Math.sin(n), ReverseSubtractEquation = Math.cos(i), ZeroFactor = Math.sin(i), OneFactor = Math.cos(r), SrcColorFactor = Math.sin(r);
                if ('XYZ' === REVISION.order) {
                    const REVISION = AddEquation * OneFactor, n = AddEquation * SrcColorFactor, i = SubtractEquation * OneFactor, r = SubtractEquation * SrcColorFactor;
                    t[0] = ReverseSubtractEquation * OneFactor, t[4] = -ReverseSubtractEquation * SrcColorFactor, t[8] = ZeroFactor, t[1] = n + i * ZeroFactor, t[5] = REVISION - r * ZeroFactor, t[9] = -SubtractEquation * ReverseSubtractEquation, t[2] = r - REVISION * ZeroFactor, t[6] = i + n * ZeroFactor, t[10] = AddEquation * ReverseSubtractEquation;
                } else if ('YXZ' === REVISION.order) {
                    const REVISION = ReverseSubtractEquation * OneFactor, n = ReverseSubtractEquation * SrcColorFactor, i = ZeroFactor * OneFactor, r = ZeroFactor * SrcColorFactor;
                    t[0] = REVISION + r * SubtractEquation, t[4] = i * SubtractEquation - n, t[8] = AddEquation * ZeroFactor, t[1] = AddEquation * SrcColorFactor, t[5] = AddEquation * OneFactor, t[9] = -SubtractEquation, t[2] = n * SubtractEquation - i, t[6] = r + REVISION * SubtractEquation, t[10] = AddEquation * ReverseSubtractEquation;
                } else if ('ZXY' === REVISION.order) {
                    const REVISION = ReverseSubtractEquation * OneFactor, n = ReverseSubtractEquation * SrcColorFactor, i = ZeroFactor * OneFactor, r = ZeroFactor * SrcColorFactor;
                    t[0] = REVISION - r * SubtractEquation, t[4] = -AddEquation * SrcColorFactor, t[8] = i + n * SubtractEquation, t[1] = n + i * SubtractEquation, t[5] = AddEquation * OneFactor, t[9] = r - REVISION * SubtractEquation, t[2] = -AddEquation * ZeroFactor, t[6] = SubtractEquation, t[10] = AddEquation * ReverseSubtractEquation;
                } else if ('ZYX' === REVISION.order) {
                    const REVISION = AddEquation * OneFactor, n = AddEquation * SrcColorFactor, i = SubtractEquation * OneFactor, r = SubtractEquation * SrcColorFactor;
                    t[0] = ReverseSubtractEquation * OneFactor, t[4] = i * ZeroFactor - n, t[8] = REVISION * ZeroFactor + r, t[1] = ReverseSubtractEquation * SrcColorFactor, t[5] = r * ZeroFactor + REVISION, t[9] = n * ZeroFactor - i, t[2] = -ZeroFactor, t[6] = SubtractEquation * ReverseSubtractEquation, t[10] = AddEquation * ReverseSubtractEquation;
                } else if ('YZX' === REVISION.order) {
                    const REVISION = AddEquation * ReverseSubtractEquation, n = AddEquation * ZeroFactor, i = SubtractEquation * ReverseSubtractEquation, r = SubtractEquation * ZeroFactor;
                    t[0] = ReverseSubtractEquation * OneFactor, t[4] = r - REVISION * SrcColorFactor, t[8] = i * SrcColorFactor + n, t[1] = SrcColorFactor, t[5] = AddEquation * OneFactor, t[9] = -SubtractEquation * OneFactor, t[2] = -ZeroFactor * OneFactor, t[6] = n * SrcColorFactor + i, t[10] = REVISION - r * SrcColorFactor;
                } else if ('XZY' === REVISION.order) {
                    const REVISION = AddEquation * ReverseSubtractEquation, n = AddEquation * ZeroFactor, i = SubtractEquation * ReverseSubtractEquation, r = SubtractEquation * ZeroFactor;
                    t[0] = ReverseSubtractEquation * OneFactor, t[4] = -SrcColorFactor, t[8] = ZeroFactor * OneFactor, t[1] = REVISION * SrcColorFactor + r, t[5] = AddEquation * OneFactor, t[9] = n * SrcColorFactor - i, t[2] = i * SrcColorFactor - n, t[6] = SubtractEquation * OneFactor, t[10] = r * SrcColorFactor + REVISION;
                }
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
            }
            makeRotationFromQuaternion(REVISION) {
                return this.compose(_zero, REVISION, _whiteColor);
            }
            lookAt(REVISION, t, n) {
                const i = this.elements;
                return _z.subVectors(REVISION, t), 0 === _z.lengthSq() && (_z.z = 1), _z.normalize(), _x.crossVectors(n, _z), 0 === _x.lengthSq() && (1 === Math.abs(n.z) ? _z.x += 0.0001 : _z.z += 0.0001, _z.normalize(), _x.crossVectors(n, _z)), _x.normalize(), _y.crossVectors(_z, _x), i[0] = _x.x, i[4] = _y.x, i[8] = _z.x, i[1] = _x.y, i[5] = _y.y, i[9] = _z.y, i[2] = _x.z, i[6] = _y.z, i[10] = _z.z, this;
            }
            multiply(REVISION) {
                return this.multiplyMatrices(this, REVISION);
            }
            premultiply(REVISION) {
                return this.multiplyMatrices(REVISION, this);
            }
            multiplyMatrices(REVISION, t) {
                const n = REVISION.elements, i = t.elements, r = this.elements, AddEquation = n[0], SubtractEquation = n[4], ReverseSubtractEquation = n[8], ZeroFactor = n[12], OneFactor = n[1], SrcColorFactor = n[5], OneMinusSrcColorFactor = n[9], SrcAlphaFactor = n[13], OneMinusSrcAlphaFactor = n[2], DstAlphaFactor = n[6], OneMinusDstAlphaFactor = n[10], DstColorFactor = n[14], OneMinusDstColorFactor = n[3], SrcAlphaSaturateFactor = n[7], ConstantColorFactor = n[11], OneMinusConstantColorFactor = n[15], ConstantAlphaFactor = i[0], OneMinusConstantAlphaFactor = i[4], b = i[8], aspect = i[12], CullFaceFront = i[1], LessEqualDepth = i[5], MultiplyBlending = i[9], CustomBlending = i[13], GreaterDepth = i[2], NotEqualDepth = i[6], AttachedBindMode = i[10], CubeReflectionMapping = i[14], CubeRefractionMapping = i[3], EquirectangularReflectionMapping = i[7], EquirectangularRefractionMapping = i[11], CubeUVReflectionMapping = i[15];
                return r[0] = AddEquation * ConstantAlphaFactor + SubtractEquation * CullFaceFront + ReverseSubtractEquation * GreaterDepth + ZeroFactor * CubeRefractionMapping, r[4] = AddEquation * OneMinusConstantAlphaFactor + SubtractEquation * LessEqualDepth + ReverseSubtractEquation * NotEqualDepth + ZeroFactor * EquirectangularReflectionMapping, r[8] = AddEquation * b + SubtractEquation * MultiplyBlending + ReverseSubtractEquation * AttachedBindMode + ZeroFactor * EquirectangularRefractionMapping, r[12] = AddEquation * aspect + SubtractEquation * CustomBlending + ReverseSubtractEquation * CubeReflectionMapping + ZeroFactor * CubeUVReflectionMapping, r[1] = OneFactor * ConstantAlphaFactor + SrcColorFactor * CullFaceFront + OneMinusSrcColorFactor * GreaterDepth + SrcAlphaFactor * CubeRefractionMapping, r[5] = OneFactor * OneMinusConstantAlphaFactor + SrcColorFactor * LessEqualDepth + OneMinusSrcColorFactor * NotEqualDepth + SrcAlphaFactor * EquirectangularReflectionMapping, r[9] = OneFactor * b + SrcColorFactor * MultiplyBlending + OneMinusSrcColorFactor * AttachedBindMode + SrcAlphaFactor * EquirectangularRefractionMapping, r[13] = OneFactor * aspect + SrcColorFactor * CustomBlending + OneMinusSrcColorFactor * CubeReflectionMapping + SrcAlphaFactor * CubeUVReflectionMapping, r[2] = OneMinusSrcAlphaFactor * ConstantAlphaFactor + DstAlphaFactor * CullFaceFront + OneMinusDstAlphaFactor * GreaterDepth + DstColorFactor * CubeRefractionMapping, r[6] = OneMinusSrcAlphaFactor * OneMinusConstantAlphaFactor + DstAlphaFactor * LessEqualDepth + OneMinusDstAlphaFactor * NotEqualDepth + DstColorFactor * EquirectangularReflectionMapping, r[10] = OneMinusSrcAlphaFactor * b + DstAlphaFactor * MultiplyBlending + OneMinusDstAlphaFactor * AttachedBindMode + DstColorFactor * EquirectangularRefractionMapping, r[14] = OneMinusSrcAlphaFactor * aspect + DstAlphaFactor * CustomBlending + OneMinusDstAlphaFactor * CubeReflectionMapping + DstColorFactor * CubeUVReflectionMapping, r[3] = OneMinusDstColorFactor * ConstantAlphaFactor + SrcAlphaSaturateFactor * CullFaceFront + ConstantColorFactor * GreaterDepth + OneMinusConstantColorFactor * CubeRefractionMapping, r[7] = OneMinusDstColorFactor * OneMinusConstantAlphaFactor + SrcAlphaSaturateFactor * LessEqualDepth + ConstantColorFactor * NotEqualDepth + OneMinusConstantColorFactor * EquirectangularReflectionMapping, r[11] = OneMinusDstColorFactor * b + SrcAlphaSaturateFactor * MultiplyBlending + ConstantColorFactor * AttachedBindMode + OneMinusConstantColorFactor * EquirectangularRefractionMapping, r[15] = OneMinusDstColorFactor * aspect + SrcAlphaSaturateFactor * CustomBlending + ConstantColorFactor * CubeReflectionMapping + OneMinusConstantColorFactor * CubeUVReflectionMapping, this;
            }
            multiplyScalar(REVISION) {
                const t = this.elements;
                return t[0] *= REVISION, t[4] *= REVISION, t[8] *= REVISION, t[12] *= REVISION, t[1] *= REVISION, t[5] *= REVISION, t[9] *= REVISION, t[13] *= REVISION, t[2] *= REVISION, t[6] *= REVISION, t[10] *= REVISION, t[14] *= REVISION, t[3] *= REVISION, t[7] *= REVISION, t[11] *= REVISION, t[15] *= REVISION, this;
            }
            determinant() {
                const REVISION = this.elements, t = REVISION[0], n = REVISION[4], i = REVISION[8], r = REVISION[12], AddEquation = REVISION[1], SubtractEquation = REVISION[5], ReverseSubtractEquation = REVISION[9], ZeroFactor = REVISION[13], OneFactor = REVISION[2], SrcColorFactor = REVISION[6], OneMinusSrcColorFactor = REVISION[10], SrcAlphaFactor = REVISION[14];
                return REVISION[3] * (+r * ReverseSubtractEquation * SrcColorFactor - i * ZeroFactor * SrcColorFactor - r * SubtractEquation * OneMinusSrcColorFactor + n * ZeroFactor * OneMinusSrcColorFactor + i * SubtractEquation * SrcAlphaFactor - n * ReverseSubtractEquation * SrcAlphaFactor) + REVISION[7] * (+t * ReverseSubtractEquation * SrcAlphaFactor - t * ZeroFactor * OneMinusSrcColorFactor + r * AddEquation * OneMinusSrcColorFactor - i * AddEquation * SrcAlphaFactor + i * ZeroFactor * OneFactor - r * ReverseSubtractEquation * OneFactor) + REVISION[11] * (+t * ZeroFactor * SrcColorFactor - t * SubtractEquation * SrcAlphaFactor - r * AddEquation * SrcColorFactor + n * AddEquation * SrcAlphaFactor + r * SubtractEquation * OneFactor - n * ZeroFactor * OneFactor) + REVISION[15] * (-i * SubtractEquation * OneFactor - t * ReverseSubtractEquation * SrcColorFactor + t * SubtractEquation * OneMinusSrcColorFactor + i * AddEquation * SrcColorFactor - n * AddEquation * OneMinusSrcColorFactor + n * ReverseSubtractEquation * OneFactor);
            }
            transpose() {
                const REVISION = this.elements;
                let t;
                return t = REVISION[1], REVISION[1] = REVISION[4], REVISION[4] = t, t = REVISION[2], REVISION[2] = REVISION[8], REVISION[8] = t, t = REVISION[6], REVISION[6] = REVISION[9], REVISION[9] = t, t = REVISION[3], REVISION[3] = REVISION[12], REVISION[12] = t, t = REVISION[7], REVISION[7] = REVISION[13], REVISION[13] = t, t = REVISION[11], REVISION[11] = REVISION[14], REVISION[14] = t, this;
            }
            setPosition(REVISION, t, n) {
                const i = this.elements;
                return REVISION.isVector3 ? (i[12] = REVISION.x, i[13] = REVISION.y, i[14] = REVISION.z) : (i[12] = REVISION, i[13] = t, i[14] = n), this;
            }
            invert() {
                const REVISION = this.elements, t = REVISION[0], n = REVISION[1], i = REVISION[2], r = REVISION[3], AddEquation = REVISION[4], SubtractEquation = REVISION[5], ReverseSubtractEquation = REVISION[6], ZeroFactor = REVISION[7], OneFactor = REVISION[8], SrcColorFactor = REVISION[9], OneMinusSrcColorFactor = REVISION[10], SrcAlphaFactor = REVISION[11], OneMinusSrcAlphaFactor = REVISION[12], DstAlphaFactor = REVISION[13], OneMinusDstAlphaFactor = REVISION[14], DstColorFactor = REVISION[15], OneMinusDstColorFactor = SrcColorFactor * OneMinusDstAlphaFactor * ZeroFactor - DstAlphaFactor * OneMinusSrcColorFactor * ZeroFactor + DstAlphaFactor * ReverseSubtractEquation * SrcAlphaFactor - SubtractEquation * OneMinusDstAlphaFactor * SrcAlphaFactor - SrcColorFactor * ReverseSubtractEquation * DstColorFactor + SubtractEquation * OneMinusSrcColorFactor * DstColorFactor, SrcAlphaSaturateFactor = OneMinusSrcAlphaFactor * OneMinusSrcColorFactor * ZeroFactor - OneFactor * OneMinusDstAlphaFactor * ZeroFactor - OneMinusSrcAlphaFactor * ReverseSubtractEquation * SrcAlphaFactor + AddEquation * OneMinusDstAlphaFactor * SrcAlphaFactor + OneFactor * ReverseSubtractEquation * DstColorFactor - AddEquation * OneMinusSrcColorFactor * DstColorFactor, ConstantColorFactor = OneFactor * DstAlphaFactor * ZeroFactor - OneMinusSrcAlphaFactor * SrcColorFactor * ZeroFactor + OneMinusSrcAlphaFactor * SubtractEquation * SrcAlphaFactor - AddEquation * DstAlphaFactor * SrcAlphaFactor - OneFactor * SubtractEquation * DstColorFactor + AddEquation * SrcColorFactor * DstColorFactor, OneMinusConstantColorFactor = OneMinusSrcAlphaFactor * SrcColorFactor * ReverseSubtractEquation - OneFactor * DstAlphaFactor * ReverseSubtractEquation - OneMinusSrcAlphaFactor * SubtractEquation * OneMinusSrcColorFactor + AddEquation * DstAlphaFactor * OneMinusSrcColorFactor + OneFactor * SubtractEquation * OneMinusDstAlphaFactor - AddEquation * SrcColorFactor * OneMinusDstAlphaFactor, ConstantAlphaFactor = t * OneMinusDstColorFactor + n * SrcAlphaSaturateFactor + i * ConstantColorFactor + r * OneMinusConstantColorFactor;
                if (0 === ConstantAlphaFactor)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const OneMinusConstantAlphaFactor = 1 / ConstantAlphaFactor;
                return REVISION[0] = OneMinusDstColorFactor * OneMinusConstantAlphaFactor, REVISION[1] = (DstAlphaFactor * OneMinusSrcColorFactor * r - SrcColorFactor * OneMinusDstAlphaFactor * r - DstAlphaFactor * i * SrcAlphaFactor + n * OneMinusDstAlphaFactor * SrcAlphaFactor + SrcColorFactor * i * DstColorFactor - n * OneMinusSrcColorFactor * DstColorFactor) * OneMinusConstantAlphaFactor, REVISION[2] = (SubtractEquation * OneMinusDstAlphaFactor * r - DstAlphaFactor * ReverseSubtractEquation * r + DstAlphaFactor * i * ZeroFactor - n * OneMinusDstAlphaFactor * ZeroFactor - SubtractEquation * i * DstColorFactor + n * ReverseSubtractEquation * DstColorFactor) * OneMinusConstantAlphaFactor, REVISION[3] = (SrcColorFactor * ReverseSubtractEquation * r - SubtractEquation * OneMinusSrcColorFactor * r - SrcColorFactor * i * ZeroFactor + n * OneMinusSrcColorFactor * ZeroFactor + SubtractEquation * i * SrcAlphaFactor - n * ReverseSubtractEquation * SrcAlphaFactor) * OneMinusConstantAlphaFactor, REVISION[4] = SrcAlphaSaturateFactor * OneMinusConstantAlphaFactor, REVISION[5] = (OneFactor * OneMinusDstAlphaFactor * r - OneMinusSrcAlphaFactor * OneMinusSrcColorFactor * r + OneMinusSrcAlphaFactor * i * SrcAlphaFactor - t * OneMinusDstAlphaFactor * SrcAlphaFactor - OneFactor * i * DstColorFactor + t * OneMinusSrcColorFactor * DstColorFactor) * OneMinusConstantAlphaFactor, REVISION[6] = (OneMinusSrcAlphaFactor * ReverseSubtractEquation * r - AddEquation * OneMinusDstAlphaFactor * r - OneMinusSrcAlphaFactor * i * ZeroFactor + t * OneMinusDstAlphaFactor * ZeroFactor + AddEquation * i * DstColorFactor - t * ReverseSubtractEquation * DstColorFactor) * OneMinusConstantAlphaFactor, REVISION[7] = (AddEquation * OneMinusSrcColorFactor * r - OneFactor * ReverseSubtractEquation * r + OneFactor * i * ZeroFactor - t * OneMinusSrcColorFactor * ZeroFactor - AddEquation * i * SrcAlphaFactor + t * ReverseSubtractEquation * SrcAlphaFactor) * OneMinusConstantAlphaFactor, REVISION[8] = ConstantColorFactor * OneMinusConstantAlphaFactor, REVISION[9] = (OneMinusSrcAlphaFactor * SrcColorFactor * r - OneFactor * DstAlphaFactor * r - OneMinusSrcAlphaFactor * n * SrcAlphaFactor + t * DstAlphaFactor * SrcAlphaFactor + OneFactor * n * DstColorFactor - t * SrcColorFactor * DstColorFactor) * OneMinusConstantAlphaFactor, REVISION[10] = (AddEquation * DstAlphaFactor * r - OneMinusSrcAlphaFactor * SubtractEquation * r + OneMinusSrcAlphaFactor * n * ZeroFactor - t * DstAlphaFactor * ZeroFactor - AddEquation * n * DstColorFactor + t * SubtractEquation * DstColorFactor) * OneMinusConstantAlphaFactor, REVISION[11] = (OneFactor * SubtractEquation * r - AddEquation * SrcColorFactor * r - OneFactor * n * ZeroFactor + t * SrcColorFactor * ZeroFactor + AddEquation * n * SrcAlphaFactor - t * SubtractEquation * SrcAlphaFactor) * OneMinusConstantAlphaFactor, REVISION[12] = OneMinusConstantColorFactor * OneMinusConstantAlphaFactor, REVISION[13] = (OneFactor * DstAlphaFactor * i - OneMinusSrcAlphaFactor * SrcColorFactor * i + OneMinusSrcAlphaFactor * n * OneMinusSrcColorFactor - t * DstAlphaFactor * OneMinusSrcColorFactor - OneFactor * n * OneMinusDstAlphaFactor + t * SrcColorFactor * OneMinusDstAlphaFactor) * OneMinusConstantAlphaFactor, REVISION[14] = (OneMinusSrcAlphaFactor * SubtractEquation * i - AddEquation * DstAlphaFactor * i - OneMinusSrcAlphaFactor * n * ReverseSubtractEquation + t * DstAlphaFactor * ReverseSubtractEquation + AddEquation * n * OneMinusDstAlphaFactor - t * SubtractEquation * OneMinusDstAlphaFactor) * OneMinusConstantAlphaFactor, REVISION[15] = (AddEquation * SrcColorFactor * i - OneFactor * SubtractEquation * i + OneFactor * n * ReverseSubtractEquation - t * SrcColorFactor * ReverseSubtractEquation - AddEquation * n * OneMinusSrcColorFactor + t * SubtractEquation * OneMinusSrcColorFactor) * OneMinusConstantAlphaFactor, this;
            }
            scale(REVISION) {
                const t = this.elements, n = REVISION.x, i = REVISION.y, r = REVISION.z;
                return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
            }
            getMaxScaleOnAxis() {
                const REVISION = this.elements, t = REVISION[0] * REVISION[0] + REVISION[1] * REVISION[1] + REVISION[2] * REVISION[2], n = REVISION[4] * REVISION[4] + REVISION[5] * REVISION[5] + REVISION[6] * REVISION[6], i = REVISION[8] * REVISION[8] + REVISION[9] * REVISION[9] + REVISION[10] * REVISION[10];
                return Math.sqrt(Math.max(t, n, i));
            }
            makeTranslation(REVISION, t, n) {
                return REVISION.isVector3 ? this.set(1, 0, 0, REVISION.x, 0, 1, 0, REVISION.y, 0, 0, 1, REVISION.z, 0, 0, 0, 1) : this.set(1, 0, 0, REVISION, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
            }
            makeRotationX(REVISION) {
                const t = Math.cos(REVISION), n = Math.sin(REVISION);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
            }
            makeRotationY(REVISION) {
                const t = Math.cos(REVISION), n = Math.sin(REVISION);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
            }
            makeRotationZ(REVISION) {
                const t = Math.cos(REVISION), n = Math.sin(REVISION);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
            }
            makeRotationAxis(REVISION, t) {
                const n = Math.cos(t), i = Math.sin(t), r = 1 - n, AddEquation = REVISION.x, SubtractEquation = REVISION.y, ReverseSubtractEquation = REVISION.z, ZeroFactor = r * AddEquation, OneFactor = r * SubtractEquation;
                return this.set(ZeroFactor * AddEquation + n, ZeroFactor * SubtractEquation - i * ReverseSubtractEquation, ZeroFactor * ReverseSubtractEquation + i * SubtractEquation, 0, ZeroFactor * SubtractEquation + i * ReverseSubtractEquation, OneFactor * SubtractEquation + n, OneFactor * ReverseSubtractEquation - i * AddEquation, 0, ZeroFactor * ReverseSubtractEquation - i * SubtractEquation, OneFactor * ReverseSubtractEquation + i * AddEquation, r * ReverseSubtractEquation * ReverseSubtractEquation + n, 0, 0, 0, 0, 1), this;
            }
            makeScale(REVISION, t, n) {
                return this.set(REVISION, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
            }
            makeShear(REVISION, t, n, i, r, AddEquation) {
                return this.set(1, n, r, 0, REVISION, 1, AddEquation, 0, t, i, 1, 0, 0, 0, 0, 1), this;
            }
            compose(REVISION, t, n) {
                const i = this.elements, r = t._x, AddEquation = t._y, SubtractEquation = t._z, ReverseSubtractEquation = t._w, ZeroFactor = r + r, OneFactor = AddEquation + AddEquation, SrcColorFactor = SubtractEquation + SubtractEquation, OneMinusSrcColorFactor = r * ZeroFactor, SrcAlphaFactor = r * OneFactor, OneMinusSrcAlphaFactor = r * SrcColorFactor, DstAlphaFactor = AddEquation * OneFactor, OneMinusDstAlphaFactor = AddEquation * SrcColorFactor, DstColorFactor = SubtractEquation * SrcColorFactor, OneMinusDstColorFactor = ReverseSubtractEquation * ZeroFactor, SrcAlphaSaturateFactor = ReverseSubtractEquation * OneFactor, ConstantColorFactor = ReverseSubtractEquation * SrcColorFactor, OneMinusConstantColorFactor = n.x, ConstantAlphaFactor = n.y, OneMinusConstantAlphaFactor = n.z;
                return i[0] = (1 - (DstAlphaFactor + DstColorFactor)) * OneMinusConstantColorFactor, i[1] = (SrcAlphaFactor + ConstantColorFactor) * OneMinusConstantColorFactor, i[2] = (OneMinusSrcAlphaFactor - SrcAlphaSaturateFactor) * OneMinusConstantColorFactor, i[3] = 0, i[4] = (SrcAlphaFactor - ConstantColorFactor) * ConstantAlphaFactor, i[5] = (1 - (OneMinusSrcColorFactor + DstColorFactor)) * ConstantAlphaFactor, i[6] = (OneMinusDstAlphaFactor + OneMinusDstColorFactor) * ConstantAlphaFactor, i[7] = 0, i[8] = (OneMinusSrcAlphaFactor + SrcAlphaSaturateFactor) * OneMinusConstantAlphaFactor, i[9] = (OneMinusDstAlphaFactor - OneMinusDstColorFactor) * OneMinusConstantAlphaFactor, i[10] = (1 - (OneMinusSrcColorFactor + DstAlphaFactor)) * OneMinusConstantAlphaFactor, i[11] = 0, i[12] = REVISION.x, i[13] = REVISION.y, i[14] = REVISION.z, i[15] = 1, this;
            }
            decompose(REVISION, t, n) {
                const i = this.elements;
                let r = _v1$5.set(i[0], i[1], i[2]).length();
                const AddEquation = _v1$5.set(i[4], i[5], i[6]).length(), SubtractEquation = _v1$5.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), REVISION.x = i[12], REVISION.y = i[13], REVISION.z = i[14], _m1$2.copy(this);
                const ReverseSubtractEquation = 1 / r, ZeroFactor = 1 / AddEquation, OneFactor = 1 / SubtractEquation;
                return _m1$2.elements[0] *= ReverseSubtractEquation, _m1$2.elements[1] *= ReverseSubtractEquation, _m1$2.elements[2] *= ReverseSubtractEquation, _m1$2.elements[4] *= ZeroFactor, _m1$2.elements[5] *= ZeroFactor, _m1$2.elements[6] *= ZeroFactor, _m1$2.elements[8] *= OneFactor, _m1$2.elements[9] *= OneFactor, _m1$2.elements[10] *= OneFactor, t.setFromRotationMatrix(_m1$2), n.x = r, n.y = AddEquation, n.z = SubtractEquation, this;
            }
            makePerspective(REVISION, t, n, i, r, AddEquation, SubtractEquation = 2000) {
                const ReverseSubtractEquation = this.elements, ZeroFactor = 2 * r / (t - REVISION), OneFactor = 2 * r / (n - i), SrcColorFactor = (t + REVISION) / (t - REVISION), OneMinusSrcColorFactor = (n + i) / (n - i);
                let SrcAlphaFactor, OneMinusSrcAlphaFactor;
                if (SubtractEquation === WebGLCoordinateSystem)
                    SrcAlphaFactor = -(AddEquation + r) / (AddEquation - r), OneMinusSrcAlphaFactor = -2 * AddEquation * r / (AddEquation - r);
                else {
                    if (SubtractEquation !== WebGPUCoordinateSystem)
                        throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + SubtractEquation);
                    SrcAlphaFactor = -AddEquation / (AddEquation - r), OneMinusSrcAlphaFactor = -AddEquation * r / (AddEquation - r);
                }
                return ReverseSubtractEquation[0] = ZeroFactor, ReverseSubtractEquation[4] = 0, ReverseSubtractEquation[8] = SrcColorFactor, ReverseSubtractEquation[12] = 0, ReverseSubtractEquation[1] = 0, ReverseSubtractEquation[5] = OneFactor, ReverseSubtractEquation[9] = OneMinusSrcColorFactor, ReverseSubtractEquation[13] = 0, ReverseSubtractEquation[2] = 0, ReverseSubtractEquation[6] = 0, ReverseSubtractEquation[10] = SrcAlphaFactor, ReverseSubtractEquation[14] = OneMinusSrcAlphaFactor, ReverseSubtractEquation[3] = 0, ReverseSubtractEquation[7] = 0, ReverseSubtractEquation[11] = -1, ReverseSubtractEquation[15] = 0, this;
            }
            makeOrthographic(REVISION, t, n, i, r, AddEquation, SubtractEquation = 2000) {
                const ReverseSubtractEquation = this.elements, ZeroFactor = 1 / (t - REVISION), OneFactor = 1 / (n - i), SrcColorFactor = 1 / (AddEquation - r), OneMinusSrcColorFactor = (t + REVISION) * ZeroFactor, SrcAlphaFactor = (n + i) * OneFactor;
                let OneMinusSrcAlphaFactor, DstAlphaFactor;
                if (SubtractEquation === WebGLCoordinateSystem)
                    OneMinusSrcAlphaFactor = (AddEquation + r) * SrcColorFactor, DstAlphaFactor = -2 * SrcColorFactor;
                else {
                    if (SubtractEquation !== WebGPUCoordinateSystem)
                        throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + SubtractEquation);
                    OneMinusSrcAlphaFactor = r * SrcColorFactor, DstAlphaFactor = -1 * SrcColorFactor;
                }
                return ReverseSubtractEquation[0] = 2 * ZeroFactor, ReverseSubtractEquation[4] = 0, ReverseSubtractEquation[8] = 0, ReverseSubtractEquation[12] = -OneMinusSrcColorFactor, ReverseSubtractEquation[1] = 0, ReverseSubtractEquation[5] = 2 * OneFactor, ReverseSubtractEquation[9] = 0, ReverseSubtractEquation[13] = -SrcAlphaFactor, ReverseSubtractEquation[2] = 0, ReverseSubtractEquation[6] = 0, ReverseSubtractEquation[10] = DstAlphaFactor, ReverseSubtractEquation[14] = -OneMinusSrcAlphaFactor, ReverseSubtractEquation[3] = 0, ReverseSubtractEquation[7] = 0, ReverseSubtractEquation[11] = 0, ReverseSubtractEquation[15] = 1, this;
            }
            equals(REVISION) {
                const t = this.elements, n = REVISION.elements;
                for (let REVISION = 0; REVISION < 16; REVISION++)
                    if (t[REVISION] !== n[REVISION])
                        return !1;
                return !0;
            }
            fromArray(REVISION, t = 0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = REVISION[n + t];
                return this;
            }
            toArray(REVISION = [], t = 0) {
                const n = this.elements;
                return REVISION[t] = n[0], REVISION[t + 1] = n[1], REVISION[t + 2] = n[2], REVISION[t + 3] = n[3], REVISION[t + 4] = n[4], REVISION[t + 5] = n[5], REVISION[t + 6] = n[6], REVISION[t + 7] = n[7], REVISION[t + 8] = n[8], REVISION[t + 9] = n[9], REVISION[t + 10] = n[10], REVISION[t + 11] = n[11], REVISION[t + 12] = n[12], REVISION[t + 13] = n[13], REVISION[t + 14] = n[14], REVISION[t + 15] = n[15], REVISION;
            }
        }
        const _v1$5 = new Vector3(), _m1$2 = new Matrix4(), _zero = new Vector3(0, 0, 0), _whiteColor = new Vector3(1, 1, 1), _x = new Vector3(), _y = new Vector3(), _z = new Vector3(), _matrix$2 = new Matrix4(), _quaternion$3 = new Quaternion();
        class Euler {
            constructor(REVISION = 0, t = 0, n = 0, i = Euler.DEFAULT_ORDER) {
                this.isEuler = !0, this._x = REVISION, this._y = t, this._z = n, this._order = i;
            }
            get x() {
                return this._x;
            }
            set x(REVISION) {
                this._x = REVISION, this._onChangeCallback();
            }
            get y() {
                return this._y;
            }
            set y(REVISION) {
                this._y = REVISION, this._onChangeCallback();
            }
            get z() {
                return this._z;
            }
            set z(REVISION) {
                this._z = REVISION, this._onChangeCallback();
            }
            get order() {
                return this._order;
            }
            set order(REVISION) {
                this._order = REVISION, this._onChangeCallback();
            }
            set(REVISION, t, n, i = this._order) {
                return this._x = REVISION, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order);
            }
            copy(REVISION) {
                return this._x = REVISION._x, this._y = REVISION._y, this._z = REVISION._z, this._order = REVISION._order, this._onChangeCallback(), this;
            }
            setFromRotationMatrix(REVISION, t = this._order, n = !0) {
                const i = REVISION.elements, r = i[0], AddEquation = i[4], SubtractEquation = i[8], ReverseSubtractEquation = i[1], ZeroFactor = i[5], OneFactor = i[9], SrcColorFactor = i[2], OneMinusSrcColorFactor = i[6], SrcAlphaFactor = i[10];
                switch (t) {
                case 'XYZ':
                    this._y = Math.asin(clamp(SubtractEquation, -1, 1)), Math.abs(SubtractEquation) < 0.9999999 ? (this._x = Math.atan2(-OneFactor, SrcAlphaFactor), this._z = Math.atan2(-AddEquation, r)) : (this._x = Math.atan2(OneMinusSrcColorFactor, ZeroFactor), this._z = 0);
                    break;
                case 'YXZ':
                    this._x = Math.asin(-clamp(OneFactor, -1, 1)), Math.abs(OneFactor) < 0.9999999 ? (this._y = Math.atan2(SubtractEquation, SrcAlphaFactor), this._z = Math.atan2(ReverseSubtractEquation, ZeroFactor)) : (this._y = Math.atan2(-SrcColorFactor, r), this._z = 0);
                    break;
                case 'ZXY':
                    this._x = Math.asin(clamp(OneMinusSrcColorFactor, -1, 1)), Math.abs(OneMinusSrcColorFactor) < 0.9999999 ? (this._y = Math.atan2(-SrcColorFactor, SrcAlphaFactor), this._z = Math.atan2(-AddEquation, ZeroFactor)) : (this._y = 0, this._z = Math.atan2(ReverseSubtractEquation, r));
                    break;
                case 'ZYX':
                    this._y = Math.asin(-clamp(SrcColorFactor, -1, 1)), Math.abs(SrcColorFactor) < 0.9999999 ? (this._x = Math.atan2(OneMinusSrcColorFactor, SrcAlphaFactor), this._z = Math.atan2(ReverseSubtractEquation, r)) : (this._x = 0, this._z = Math.atan2(-AddEquation, ZeroFactor));
                    break;
                case 'YZX':
                    this._z = Math.asin(clamp(ReverseSubtractEquation, -1, 1)), Math.abs(ReverseSubtractEquation) < 0.9999999 ? (this._x = Math.atan2(-OneFactor, ZeroFactor), this._y = Math.atan2(-SrcColorFactor, r)) : (this._x = 0, this._y = Math.atan2(SubtractEquation, SrcAlphaFactor));
                    break;
                case 'XZY':
                    this._z = Math.asin(-clamp(AddEquation, -1, 1)), Math.abs(AddEquation) < 0.9999999 ? (this._x = Math.atan2(OneMinusSrcColorFactor, ZeroFactor), this._y = Math.atan2(SubtractEquation, r)) : (this._x = Math.atan2(-OneFactor, SrcAlphaFactor), this._y = 0);
                    break;
                default:
                    console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + t);
                }
                return this._order = t, !0 === n && this._onChangeCallback(), this;
            }
            setFromQuaternion(REVISION, t, n) {
                return _matrix$2.makeRotationFromQuaternion(REVISION), this.setFromRotationMatrix(_matrix$2, t, n);
            }
            setFromVector3(REVISION, t = this._order) {
                return this.set(REVISION.x, REVISION.y, REVISION.z, t);
            }
            reorder(REVISION) {
                return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, REVISION);
            }
            equals(REVISION) {
                return REVISION._x === this._x && REVISION._y === this._y && REVISION._z === this._z && REVISION._order === this._order;
            }
            fromArray(REVISION) {
                return this._x = REVISION[0], this._y = REVISION[1], this._z = REVISION[2], void 0 !== REVISION[3] && (this._order = REVISION[3]), this._onChangeCallback(), this;
            }
            toArray(REVISION = [], t = 0) {
                return REVISION[t] = this._x, REVISION[t + 1] = this._y, REVISION[t + 2] = this._z, REVISION[t + 3] = this._order, REVISION;
            }
            _onChange(REVISION) {
                return this._onChangeCallback = REVISION, this;
            }
            _onChangeCallback() {
            }
            *[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order;
            }
        }
        Euler.DEFAULT_ORDER = 'XYZ';
        class Layers {
            constructor() {
                this.mask = 1;
            }
            set(REVISION) {
                this.mask = 1 << REVISION >>> 0;
            }
            enable(REVISION) {
                this.mask |= 1 << REVISION;
            }
            enableAll() {
                this.mask = -1;
            }
            toggle(REVISION) {
                this.mask ^= 1 << REVISION;
            }
            disable(REVISION) {
                this.mask &= ~(1 << REVISION);
            }
            disableAll() {
                this.mask = 0;
            }
            test(REVISION) {
                return !!(this.mask & REVISION.mask);
            }
            isEnabled(REVISION) {
                return !!(this.mask & 1 << REVISION);
            }
        }
        let _object3DId = 0;
        const _v1$4 = new Vector3(), _q1 = new Quaternion(), _m1$1 = new Matrix4(), _target = new Vector3(), _position$3 = new Vector3(), _scale$2 = new Vector3(), _quaternion$2 = new Quaternion(), _xAxis = new Vector3(1, 0, 0), _yAxis = new Vector3(0, 1, 0), _zAxis = new Vector3(0, 0, 1), _addedEvent = { type: 'added' }, _removedEvent = { type: 'removed' }, _childaddedEvent = {
                type: 'childadded',
                child: null
            }, _childremovedEvent = {
                type: 'childremoved',
                child: null
            };
        class Object3D extends EventDispatcher {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, 'id', { value: _object3DId++ }), this.uuid = At(), this.name = '', this.type = 'Object3D', this.parent = null, this.children = [], this.up = Object3D.DEFAULT_UP.clone();
                const REVISION = new Vector3(), t = new Euler(), n = new Quaternion(), i = new Vector3(1, 1, 1);
                t._onChange(function () {
                    n.setFromEuler(t, !1);
                }), n._onChange(function () {
                    t.setFromQuaternion(n, void 0, !1);
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: REVISION
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: { value: new Matrix4() },
                    normalMatrix: { value: new Matrix3() }
                }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
            }
            onBeforeShadow() {
            }
            onAfterShadow() {
            }
            onBeforeRender() {
            }
            onAfterRender() {
            }
            applyMatrix4(REVISION) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(REVISION), this.matrix.decompose(this.position, this.quaternion, this.scale);
            }
            applyQuaternion(REVISION) {
                return this.quaternion.premultiply(REVISION), this;
            }
            setRotationFromAxisAngle(REVISION, t) {
                this.quaternion.setFromAxisAngle(REVISION, t);
            }
            setRotationFromEuler(REVISION) {
                this.quaternion.setFromEuler(REVISION, !0);
            }
            setRotationFromMatrix(REVISION) {
                this.quaternion.setFromRotationMatrix(REVISION);
            }
            setRotationFromQuaternion(REVISION) {
                this.quaternion.copy(REVISION);
            }
            rotateOnAxis(REVISION, t) {
                return _q1.setFromAxisAngle(REVISION, t), this.quaternion.multiply(_q1), this;
            }
            rotateOnWorldAxis(REVISION, t) {
                return _q1.setFromAxisAngle(REVISION, t), this.quaternion.premultiply(_q1), this;
            }
            rotateX(REVISION) {
                return this.rotateOnAxis(_xAxis, REVISION);
            }
            rotateY(REVISION) {
                return this.rotateOnAxis(_yAxis, REVISION);
            }
            rotateZ(REVISION) {
                return this.rotateOnAxis(_zAxis, REVISION);
            }
            translateOnAxis(REVISION, t) {
                return _v1$4.copy(REVISION).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(t)), this;
            }
            translateX(REVISION) {
                return this.translateOnAxis(_xAxis, REVISION);
            }
            translateY(REVISION) {
                return this.translateOnAxis(_yAxis, REVISION);
            }
            translateZ(REVISION) {
                return this.translateOnAxis(_zAxis, REVISION);
            }
            localToWorld(REVISION) {
                return this.updateWorldMatrix(!0, !1), REVISION.applyMatrix4(this.matrixWorld);
            }
            worldToLocal(REVISION) {
                return this.updateWorldMatrix(!0, !1), REVISION.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
            }
            lookAt(REVISION, t, n) {
                REVISION.isVector3 ? _target.copy(REVISION) : _target.set(REVISION, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1), i && (_m1$1.extractRotation(i.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert()));
            }
            add(REVISION) {
                if (arguments.length > 1) {
                    for (let REVISION = 0; REVISION < arguments.length; REVISION++)
                        this.add(arguments[REVISION]);
                    return this;
                }
                return REVISION === this ? (console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', REVISION), this) : (REVISION && REVISION.isObject3D ? (REVISION.removeFromParent(), REVISION.parent = this, this.children.push(REVISION), REVISION.dispatchEvent(_addedEvent), _childaddedEvent.child = REVISION, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null) : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', REVISION), this);
            }
            remove(REVISION) {
                if (arguments.length > 1) {
                    for (let REVISION = 0; REVISION < arguments.length; REVISION++)
                        this.remove(arguments[REVISION]);
                    return this;
                }
                const t = this.children.indexOf(REVISION);
                return -1 !== t && (REVISION.parent = null, this.children.splice(t, 1), REVISION.dispatchEvent(_removedEvent), _childremovedEvent.child = REVISION, this.dispatchEvent(_childremovedEvent), _childremovedEvent.child = null), this;
            }
            removeFromParent() {
                const REVISION = this.parent;
                return null !== REVISION && REVISION.remove(this), this;
            }
            clear() {
                return this.remove(...this.children);
            }
            attach(REVISION) {
                return this.updateWorldMatrix(!0, !1), _m1$1.copy(this.matrixWorld).invert(), null !== REVISION.parent && (REVISION.parent.updateWorldMatrix(!0, !1), _m1$1.multiply(REVISION.parent.matrixWorld)), REVISION.applyMatrix4(_m1$1), REVISION.removeFromParent(), REVISION.parent = this, this.children.push(REVISION), REVISION.updateWorldMatrix(!1, !0), REVISION.dispatchEvent(_addedEvent), _childaddedEvent.child = REVISION, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null, this;
            }
            getObjectById(REVISION) {
                return this.getObjectByProperty('id', REVISION);
            }
            getObjectByName(REVISION) {
                return this.getObjectByProperty('name', REVISION);
            }
            getObjectByProperty(REVISION, t) {
                if (this[REVISION] === t)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(REVISION, t);
                    if (void 0 !== i)
                        return i;
                }
            }
            getObjectsByProperty(REVISION, t, n = []) {
                this[REVISION] === t && n.push(this);
                const i = this.children;
                for (let r = 0, AddEquation = i.length; r < AddEquation; r++)
                    i[r].getObjectsByProperty(REVISION, t, n);
                return n;
            }
            getWorldPosition(REVISION) {
                return this.updateWorldMatrix(!0, !1), REVISION.setFromMatrixPosition(this.matrixWorld);
            }
            getWorldQuaternion(REVISION) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, REVISION, _scale$2), REVISION;
            }
            getWorldScale(REVISION) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, REVISION), REVISION;
            }
            getWorldDirection(REVISION) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return REVISION.set(t[8], t[9], t[10]).normalize();
            }
            raycast() {
            }
            traverse(REVISION) {
                REVISION(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverse(REVISION);
            }
            traverseVisible(REVISION) {
                if (!1 === this.visible)
                    return;
                REVISION(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverseVisible(REVISION);
            }
            traverseAncestors(REVISION) {
                const t = this.parent;
                null !== t && (REVISION(t), t.traverseAncestors(REVISION));
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
            }
            updateMatrixWorld(REVISION) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || REVISION) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, REVISION = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) {
                    t[n].updateMatrixWorld(REVISION);
                }
            }
            updateWorldMatrix(REVISION, t) {
                const n = this.parent;
                if (!0 === REVISION && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) {
                    const REVISION = this.children;
                    for (let t = 0, n = REVISION.length; t < n; t++) {
                        REVISION[t].updateWorldMatrix(!1, !0);
                    }
                }
            }
            toJSON(REVISION) {
                const t = void 0 === REVISION || 'string' == typeof REVISION, n = {};
                t && (REVISION = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.6,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                });
                const i = {};
                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(REVISION)), n.uuid;
                }
                if (i.uuid = this.uuid, i.type = this.type, '' !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = 'InstancedMesh', i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = 'BatchedMesh', i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map(REVISION => ({
                        boxInitialized: REVISION.boxInitialized,
                        boxMin: REVISION.box.min.toArray(),
                        boxMax: REVISION.box.max.toArray(),
                        sphereInitialized: REVISION.sphereInitialized,
                        sphereRadius: REVISION.sphere.radius,
                        sphereCenter: REVISION.sphere.center.toArray()
                    })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(REVISION), null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(REVISION)), null !== this.boundingSphere && (i.boundingSphere = {
                        center: i.boundingSphere.center.toArray(),
                        radius: i.boundingSphere.radius
                    }), null !== this.boundingBox && (i.boundingBox = {
                        min: i.boundingBox.min.toArray(),
                        max: i.boundingBox.max.toArray()
                    })), this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(REVISION).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(REVISION).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(REVISION.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                r(REVISION.shapes, i);
                            }
                        else
                            r(REVISION.shapes, n);
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(REVISION.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            t.push(r(REVISION.materials, this.material[n]));
                        i.material = t;
                    } else
                        i.material = r(REVISION.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let t = 0; t < this.children.length; t++)
                        i.children.push(this.children[t].toJSON(REVISION).object);
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        i.animations.push(r(REVISION.animations, n));
                    }
                }
                if (t) {
                    const t = AddEquation(REVISION.geometries), i = AddEquation(REVISION.materials), r = AddEquation(REVISION.textures), SubtractEquation = AddEquation(REVISION.images), ReverseSubtractEquation = AddEquation(REVISION.shapes), ZeroFactor = AddEquation(REVISION.skeletons), OneFactor = AddEquation(REVISION.animations), SrcColorFactor = AddEquation(REVISION.nodes);
                    t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), SubtractEquation.length > 0 && (n.images = SubtractEquation), ReverseSubtractEquation.length > 0 && (n.shapes = ReverseSubtractEquation), ZeroFactor.length > 0 && (n.skeletons = ZeroFactor), OneFactor.length > 0 && (n.animations = OneFactor), SrcColorFactor.length > 0 && (n.nodes = SrcColorFactor);
                }
                return n.object = i, n;
                function AddEquation(REVISION) {
                    const t = [];
                    for (const n in REVISION) {
                        const i = REVISION[n];
                        delete i.metadata, t.push(i);
                    }
                    return t;
                }
            }
            clone(REVISION) {
                return new this.constructor().copy(this, REVISION);
            }
            copy(REVISION, t = !0) {
                if (this.name = REVISION.name, this.up.copy(REVISION.up), this.position.copy(REVISION.position), this.rotation.order = REVISION.rotation.order, this.quaternion.copy(REVISION.quaternion), this.scale.copy(REVISION.scale), this.matrix.copy(REVISION.matrix), this.matrixWorld.copy(REVISION.matrixWorld), this.matrixAutoUpdate = REVISION.matrixAutoUpdate, this.matrixWorldAutoUpdate = REVISION.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = REVISION.matrixWorldNeedsUpdate, this.layers.mask = REVISION.layers.mask, this.visible = REVISION.visible, this.castShadow = REVISION.castShadow, this.receiveShadow = REVISION.receiveShadow, this.frustumCulled = REVISION.frustumCulled, this.renderOrder = REVISION.renderOrder, this.animations = REVISION.animations.slice(), this.userData = JSON.parse(JSON.stringify(REVISION.userData)), !0 === t)
                    for (let t = 0; t < REVISION.children.length; t++) {
                        const n = REVISION.children[t];
                        this.add(n.clone());
                    }
                return this;
            }
        }
        Object3D.DEFAULT_UP = new Vector3(0, 1, 0), Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0, Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const _v0$1 = new Vector3(), _v1$3 = new Vector3(), _v2$2 = new Vector3(), _v3$2 = new Vector3(), _vab = new Vector3(), _vac = new Vector3(), _vbc = new Vector3(), _vap = new Vector3(), _vbp = new Vector3(), _vcp = new Vector3(), _v40 = new Vector4(), _v41 = new Vector4(), _v42 = new Vector4();
        class Triangle {
            constructor(REVISION = new Vector3(), t = new Vector3(), n = new Vector3()) {
                this.a = REVISION, this.b = t, this.c = n;
            }
            static getNormal(REVISION, t, n, i) {
                i.subVectors(n, t), _v0$1.subVectors(REVISION, t), i.cross(_v0$1);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
            }
            static getBarycoord(REVISION, t, n, i, r) {
                _v0$1.subVectors(i, t), _v1$3.subVectors(n, t), _v2$2.subVectors(REVISION, t);
                const AddEquation = _v0$1.dot(_v0$1), SubtractEquation = _v0$1.dot(_v1$3), ReverseSubtractEquation = _v0$1.dot(_v2$2), ZeroFactor = _v1$3.dot(_v1$3), OneFactor = _v1$3.dot(_v2$2), SrcColorFactor = AddEquation * ZeroFactor - SubtractEquation * SubtractEquation;
                if (0 === SrcColorFactor)
                    return r.set(0, 0, 0), null;
                const OneMinusSrcColorFactor = 1 / SrcColorFactor, SrcAlphaFactor = (ZeroFactor * ReverseSubtractEquation - SubtractEquation * OneFactor) * OneMinusSrcColorFactor, OneMinusSrcAlphaFactor = (AddEquation * OneFactor - SubtractEquation * ReverseSubtractEquation) * OneMinusSrcColorFactor;
                return r.set(1 - SrcAlphaFactor - OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor, SrcAlphaFactor);
            }
            static containsPoint(REVISION, t, n, i) {
                return null !== this.getBarycoord(REVISION, t, n, i, _v3$2) && (_v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1);
            }
            static getInterpolation(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                return null === this.getBarycoord(REVISION, t, n, i, _v3$2) ? (ReverseSubtractEquation.x = 0, ReverseSubtractEquation.y = 0, 'z' in ReverseSubtractEquation && (ReverseSubtractEquation.z = 0), 'w' in ReverseSubtractEquation && (ReverseSubtractEquation.w = 0), null) : (ReverseSubtractEquation.setScalar(0), ReverseSubtractEquation.addScaledVector(r, _v3$2.x), ReverseSubtractEquation.addScaledVector(AddEquation, _v3$2.y), ReverseSubtractEquation.addScaledVector(SubtractEquation, _v3$2.z), ReverseSubtractEquation);
            }
            static getInterpolatedAttribute(REVISION, t, n, i, r, AddEquation) {
                return _v40.setScalar(0), _v41.setScalar(0), _v42.setScalar(0), _v40.fromBufferAttribute(REVISION, t), _v41.fromBufferAttribute(REVISION, n), _v42.fromBufferAttribute(REVISION, i), AddEquation.setScalar(0), AddEquation.addScaledVector(_v40, r.x), AddEquation.addScaledVector(_v41, r.y), AddEquation.addScaledVector(_v42, r.z), AddEquation;
            }
            static isFrontFacing(REVISION, t, n, i) {
                return _v0$1.subVectors(n, t), _v1$3.subVectors(REVISION, t), _v0$1.cross(_v1$3).dot(i) < 0;
            }
            set(REVISION, t, n) {
                return this.a.copy(REVISION), this.b.copy(t), this.c.copy(n), this;
            }
            setFromPointsAndIndices(REVISION, t, n, i) {
                return this.a.copy(REVISION[t]), this.b.copy(REVISION[n]), this.c.copy(REVISION[i]), this;
            }
            setFromAttributeAndIndices(REVISION, t, n, i) {
                return this.a.fromBufferAttribute(REVISION, t), this.b.fromBufferAttribute(REVISION, n), this.c.fromBufferAttribute(REVISION, i), this;
            }
            clone() {
                return new this.constructor().copy(this);
            }
            copy(REVISION) {
                return this.a.copy(REVISION.a), this.b.copy(REVISION.b), this.c.copy(REVISION.c), this;
            }
            getArea() {
                return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), 0.5 * _v0$1.cross(_v1$3).length();
            }
            getMidpoint(REVISION) {
                return REVISION.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
            }
            getNormal(REVISION) {
                return Triangle.getNormal(this.a, this.b, this.c, REVISION);
            }
            getPlane(REVISION) {
                return REVISION.setFromCoplanarPoints(this.a, this.b, this.c);
            }
            getBarycoord(REVISION, t) {
                return Triangle.getBarycoord(REVISION, this.a, this.b, this.c, t);
            }
            getInterpolation(REVISION, t, n, i, r) {
                return Triangle.getInterpolation(REVISION, this.a, this.b, this.c, t, n, i, r);
            }
            containsPoint(REVISION) {
                return Triangle.containsPoint(REVISION, this.a, this.b, this.c);
            }
            isFrontFacing(REVISION) {
                return Triangle.isFrontFacing(this.a, this.b, this.c, REVISION);
            }
            intersectsBox(REVISION) {
                return REVISION.intersectsTriangle(this);
            }
            closestPointToPoint(REVISION, t) {
                const n = this.a, i = this.b, r = this.c;
                let AddEquation, SubtractEquation;
                _vab.subVectors(i, n), _vac.subVectors(r, n), _vap.subVectors(REVISION, n);
                const ReverseSubtractEquation = _vab.dot(_vap), ZeroFactor = _vac.dot(_vap);
                if (ReverseSubtractEquation <= 0 && ZeroFactor <= 0)
                    return t.copy(n);
                _vbp.subVectors(REVISION, i);
                const OneFactor = _vab.dot(_vbp), SrcColorFactor = _vac.dot(_vbp);
                if (OneFactor >= 0 && SrcColorFactor <= OneFactor)
                    return t.copy(i);
                const OneMinusSrcColorFactor = ReverseSubtractEquation * SrcColorFactor - OneFactor * ZeroFactor;
                if (OneMinusSrcColorFactor <= 0 && ReverseSubtractEquation >= 0 && OneFactor <= 0)
                    return AddEquation = ReverseSubtractEquation / (ReverseSubtractEquation - OneFactor), t.copy(n).addScaledVector(_vab, AddEquation);
                _vcp.subVectors(REVISION, r);
                const SrcAlphaFactor = _vab.dot(_vcp), OneMinusSrcAlphaFactor = _vac.dot(_vcp);
                if (OneMinusSrcAlphaFactor >= 0 && SrcAlphaFactor <= OneMinusSrcAlphaFactor)
                    return t.copy(r);
                const DstAlphaFactor = SrcAlphaFactor * ZeroFactor - ReverseSubtractEquation * OneMinusSrcAlphaFactor;
                if (DstAlphaFactor <= 0 && ZeroFactor >= 0 && OneMinusSrcAlphaFactor <= 0)
                    return SubtractEquation = ZeroFactor / (ZeroFactor - OneMinusSrcAlphaFactor), t.copy(n).addScaledVector(_vac, SubtractEquation);
                const OneMinusDstAlphaFactor = OneFactor * OneMinusSrcAlphaFactor - SrcAlphaFactor * SrcColorFactor;
                if (OneMinusDstAlphaFactor <= 0 && SrcColorFactor - OneFactor >= 0 && SrcAlphaFactor - OneMinusSrcAlphaFactor >= 0)
                    return _vbc.subVectors(r, i), SubtractEquation = (SrcColorFactor - OneFactor) / (SrcColorFactor - OneFactor + (SrcAlphaFactor - OneMinusSrcAlphaFactor)), t.copy(i).addScaledVector(_vbc, SubtractEquation);
                const DstColorFactor = 1 / (OneMinusDstAlphaFactor + DstAlphaFactor + OneMinusSrcColorFactor);
                return AddEquation = DstAlphaFactor * DstColorFactor, SubtractEquation = OneMinusSrcColorFactor * DstColorFactor, t.copy(n).addScaledVector(_vab, AddEquation).addScaledVector(_vac, SubtractEquation);
            }
            equals(REVISION) {
                return REVISION.a.equals(this.a) && REVISION.b.equals(this.b) && REVISION.c.equals(this.c);
            }
        }
        const gi = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            }, _hslA = {
                h: 0,
                s: 0,
                l: 0
            }, _hslB = {
                h: 0,
                s: 0,
                l: 0
            };
        function vi(REVISION, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? REVISION + 6 * (t - REVISION) * n : n < 0.5 ? t : n < 2 / 3 ? REVISION + 6 * (t - REVISION) * (2 / 3 - n) : REVISION;
        }
        class Color {
            constructor(REVISION, t, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(REVISION, t, n);
            }
            set(REVISION, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = REVISION;
                    t && t.isColor ? this.copy(t) : 'number' == typeof t ? this.setHex(t) : 'string' == typeof t && this.setStyle(t);
                } else
                    this.setRGB(REVISION, t, n);
                return this;
            }
            setScalar(REVISION) {
                return this.r = REVISION, this.g = REVISION, this.b = REVISION, this;
            }
            setHex(REVISION, t = Ye) {
                return REVISION = Math.floor(REVISION), this.r = (REVISION >> 16 & 255) / 255, this.g = (REVISION >> 8 & 255) / 255, this.b = (255 & REVISION) / 255, _tables.toWorkingColorSpace(this, t), this;
            }
            setRGB(REVISION, t, n, i = _tables.workingColorSpace) {
                return this.r = REVISION, this.g = t, this.b = n, _tables.toWorkingColorSpace(this, i), this;
            }
            setHSL(REVISION, t, n, i = _tables.workingColorSpace) {
                if (REVISION = euclideanModulo(REVISION, 1), t = clamp(t, 0, 1), n = clamp(n, 0, 1), 0 === t)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i;
                    this.r = vi(r, i, REVISION + 1 / 3), this.g = vi(r, i, REVISION), this.b = vi(r, i, REVISION - 1 / 3);
                }
                return _tables.toWorkingColorSpace(this, i), this;
            }
            setStyle(REVISION, t = Ye) {
                function n(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn('THREE.Color: Alpha component of ' + REVISION + ' will be ignored.');
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(REVISION)) {
                    let r;
                    const AddEquation = i[1], SubtractEquation = i[2];
                    switch (AddEquation) {
                    case 'rgb':
                    case 'rgba':
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(SubtractEquation))
                            return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(SubtractEquation))
                            return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(SubtractEquation))
                            return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                    default:
                        console.warn('THREE.Color: Unknown color model ' + REVISION);
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(REVISION)) {
                    const n = i[1], r = n.length;
                    if (3 === r)
                        return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                    if (6 === r)
                        return this.setHex(parseInt(n, 16), t);
                    console.warn('THREE.Color: Invalid hex color ' + REVISION);
                } else if (REVISION && REVISION.length > 0)
                    return this.setColorName(REVISION, t);
                return this;
            }
            setColorName(REVISION, t = Ye) {
                const n = gi[REVISION.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn('THREE.Color: Unknown color ' + REVISION), this;
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b);
            }
            copy(REVISION) {
                return this.r = REVISION.r, this.g = REVISION.g, this.b = REVISION.b, this;
            }
            copySRGBToLinear(REVISION) {
                return this.r = Nt(REVISION.r), this.g = Nt(REVISION.g), this.b = Nt(REVISION.b), this;
            }
            copyLinearToSRGB(REVISION) {
                return this.r = kt(REVISION.r), this.g = kt(REVISION.g), this.b = kt(REVISION.b), this;
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this;
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this;
            }
            getHex(REVISION = Ye) {
                return _tables.fromWorkingColorSpace(_color.copy(this), REVISION), 65536 * Math.round(clamp(255 * _color.r, 0, 255)) + 256 * Math.round(clamp(255 * _color.g, 0, 255)) + Math.round(clamp(255 * _color.b, 0, 255));
            }
            getHexString(REVISION = Ye) {
                return ('000000' + this.getHex(REVISION).toString(16)).slice(-6);
            }
            getHSL(REVISION, t = _tables.workingColorSpace) {
                _tables.fromWorkingColorSpace(_color.copy(this), t);
                const n = _color.r, i = _color.g, r = _color.b, AddEquation = Math.max(n, i, r), SubtractEquation = Math.min(n, i, r);
                let ReverseSubtractEquation, ZeroFactor;
                const OneFactor = (SubtractEquation + AddEquation) / 2;
                if (SubtractEquation === AddEquation)
                    ReverseSubtractEquation = 0, ZeroFactor = 0;
                else {
                    const REVISION = AddEquation - SubtractEquation;
                    switch (ZeroFactor = OneFactor <= 0.5 ? REVISION / (AddEquation + SubtractEquation) : REVISION / (2 - AddEquation - SubtractEquation), AddEquation) {
                    case n:
                        ReverseSubtractEquation = (i - r) / REVISION + (i < r ? 6 : 0);
                        break;
                    case i:
                        ReverseSubtractEquation = (r - n) / REVISION + 2;
                        break;
                    case r:
                        ReverseSubtractEquation = (n - i) / REVISION + 4;
                    }
                    ReverseSubtractEquation /= 6;
                }
                return REVISION.h = ReverseSubtractEquation, REVISION.s = ZeroFactor, REVISION.l = OneFactor, REVISION;
            }
            getRGB(REVISION, t = _tables.workingColorSpace) {
                return _tables.fromWorkingColorSpace(_color.copy(this), t), REVISION.r = _color.r, REVISION.g = _color.g, REVISION.b = _color.b, REVISION;
            }
            getStyle(REVISION = Ye) {
                _tables.fromWorkingColorSpace(_color.copy(this), REVISION);
                const t = _color.r, n = _color.g, i = _color.b;
                return REVISION !== Ye ? `color(${ REVISION } ${ t.toFixed(3) } ${ n.toFixed(3) } ${ i.toFixed(3) })` : `rgb(${ Math.round(255 * t) },${ Math.round(255 * n) },${ Math.round(255 * i) })`;
            }
            offsetHSL(REVISION, t, n) {
                return this.getHSL(_hslA), this.setHSL(_hslA.h + REVISION, _hslA.s + t, _hslA.l + n);
            }
            add(REVISION) {
                return this.r += REVISION.r, this.g += REVISION.g, this.b += REVISION.b, this;
            }
            addColors(REVISION, t) {
                return this.r = REVISION.r + t.r, this.g = REVISION.g + t.g, this.b = REVISION.b + t.b, this;
            }
            addScalar(REVISION) {
                return this.r += REVISION, this.g += REVISION, this.b += REVISION, this;
            }
            sub(REVISION) {
                return this.r = Math.max(0, this.r - REVISION.r), this.g = Math.max(0, this.g - REVISION.g), this.b = Math.max(0, this.b - REVISION.b), this;
            }
            multiply(REVISION) {
                return this.r *= REVISION.r, this.g *= REVISION.g, this.b *= REVISION.b, this;
            }
            multiplyScalar(REVISION) {
                return this.r *= REVISION, this.g *= REVISION, this.b *= REVISION, this;
            }
            lerp(REVISION, t) {
                return this.r += (REVISION.r - this.r) * t, this.g += (REVISION.g - this.g) * t, this.b += (REVISION.b - this.b) * t, this;
            }
            lerpColors(REVISION, t, n) {
                return this.r = REVISION.r + (t.r - REVISION.r) * n, this.g = REVISION.g + (t.g - REVISION.g) * n, this.b = REVISION.b + (t.b - REVISION.b) * n, this;
            }
            lerpHSL(REVISION, t) {
                this.getHSL(_hslA), REVISION.getHSL(_hslB);
                const n = lerp(_hslA.h, _hslB.h, t), i = lerp(_hslA.s, _hslB.s, t), r = lerp(_hslA.l, _hslB.l, t);
                return this.setHSL(n, i, r), this;
            }
            setFromVector3(REVISION) {
                return this.r = REVISION.x, this.g = REVISION.y, this.b = REVISION.z, this;
            }
            applyMatrix3(REVISION) {
                const t = this.r, n = this.g, i = this.b, r = REVISION.elements;
                return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
            }
            equals(REVISION) {
                return REVISION.r === this.r && REVISION.g === this.g && REVISION.b === this.b;
            }
            fromArray(REVISION, t = 0) {
                return this.r = REVISION[t], this.g = REVISION[t + 1], this.b = REVISION[t + 2], this;
            }
            toArray(REVISION = [], t = 0) {
                return REVISION[t] = this.r, REVISION[t + 1] = this.g, REVISION[t + 2] = this.b, REVISION;
            }
            fromBufferAttribute(REVISION, t) {
                return this.r = REVISION.getX(t), this.g = REVISION.getY(t), this.b = REVISION.getZ(t), this;
            }
            toJSON() {
                return this.getHex();
            }
            *[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b;
            }
        }
        const _color = new Color();
        Color.NAMES = gi;
        let _materialId = 0;
        class Material extends EventDispatcher {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, 'id', { value: _materialId++ }), this.uuid = At(), this.name = '', this.type = 'Material', this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Color(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
            }
            get alphaTest() {
                return this._alphaTest;
            }
            set alphaTest(REVISION) {
                this._alphaTest > 0 != REVISION > 0 && this.version++, this._alphaTest = REVISION;
            }
            onBeforeRender() {
            }
            onBeforeCompile() {
            }
            customProgramCacheKey() {
                return this.onBeforeCompile.toString();
            }
            setValues(REVISION) {
                if (void 0 !== REVISION)
                    for (const t in REVISION) {
                        const n = REVISION[t];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${ t }' has value of undefined.`);
                            continue;
                        }
                        const i = this[t];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${ t }' is not a property of THREE.${ this.type }.`);
                    }
            }
            toJSON(REVISION) {
                const t = void 0 === REVISION || 'string' == typeof REVISION;
                t && (REVISION = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: 'Material',
                        generator: 'Material.toJSON'
                    }
                };
                function i(REVISION) {
                    const t = [];
                    for (const n in REVISION) {
                        const i = REVISION[n];
                        delete i.metadata, t.push(i);
                    }
                    return t;
                }
                if (n.uuid = this.uuid, n.type = this.type, '' !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(REVISION).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(REVISION).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(REVISION).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(REVISION).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(REVISION).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(REVISION).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(REVISION).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(REVISION).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(REVISION).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(REVISION).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(REVISION).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(REVISION).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(REVISION).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(REVISION).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(REVISION).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(REVISION).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(REVISION).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(REVISION).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(REVISION).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(REVISION).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(REVISION).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(REVISION).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(REVISION).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(REVISION).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== AddEquation && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== KeepStencilOp && (n.stencilFail = this.stencilFail), this.stencilZFail !== KeepStencilOp && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== KeepStencilOp && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), 'round' !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), 'round' !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                    const t = i(REVISION.textures), r = i(REVISION.images);
                    t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
                }
                return n;
            }
            clone() {
                return new this.constructor().copy(this);
            }
            copy(REVISION) {
                this.name = REVISION.name, this.blending = REVISION.blending, this.side = REVISION.side, this.vertexColors = REVISION.vertexColors, this.opacity = REVISION.opacity, this.transparent = REVISION.transparent, this.blendSrc = REVISION.blendSrc, this.blendDst = REVISION.blendDst, this.blendEquation = REVISION.blendEquation, this.blendSrcAlpha = REVISION.blendSrcAlpha, this.blendDstAlpha = REVISION.blendDstAlpha, this.blendEquationAlpha = REVISION.blendEquationAlpha, this.blendColor.copy(REVISION.blendColor), this.blendAlpha = REVISION.blendAlpha, this.depthFunc = REVISION.depthFunc, this.depthTest = REVISION.depthTest, this.depthWrite = REVISION.depthWrite, this.stencilWriteMask = REVISION.stencilWriteMask, this.stencilFunc = REVISION.stencilFunc, this.stencilRef = REVISION.stencilRef, this.stencilFuncMask = REVISION.stencilFuncMask, this.stencilFail = REVISION.stencilFail, this.stencilZFail = REVISION.stencilZFail, this.stencilZPass = REVISION.stencilZPass, this.stencilWrite = REVISION.stencilWrite;
                const t = REVISION.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const REVISION = t.length;
                    n = new Array(REVISION);
                    for (let i = 0; i !== REVISION; ++i)
                        n[i] = t[i].clone();
                }
                return this.clippingPlanes = n, this.clipIntersection = REVISION.clipIntersection, this.clipShadows = REVISION.clipShadows, this.shadowSide = REVISION.shadowSide, this.colorWrite = REVISION.colorWrite, this.precision = REVISION.precision, this.polygonOffset = REVISION.polygonOffset, this.polygonOffsetFactor = REVISION.polygonOffsetFactor, this.polygonOffsetUnits = REVISION.polygonOffsetUnits, this.dithering = REVISION.dithering, this.alphaTest = REVISION.alphaTest, this.alphaHash = REVISION.alphaHash, this.alphaToCoverage = REVISION.alphaToCoverage, this.premultipliedAlpha = REVISION.premultipliedAlpha, this.forceSinglePass = REVISION.forceSinglePass, this.visible = REVISION.visible, this.toneMapped = REVISION.toneMapped, this.userData = JSON.parse(JSON.stringify(REVISION.userData)), this;
            }
            dispose() {
                this.dispatchEvent({ type: 'dispose' });
            }
            set needsUpdate(REVISION) {
                !0 === REVISION && this.version++;
            }
            onBuild() {
                console.warn('Material: onBuild() has been removed.');
            }
        }
        class Si extends Material {
            constructor(REVISION) {
                super(), this.isMeshBasicMaterial = !0, this.type = 'MeshBasicMaterial', this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler(), this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.fog = !0, this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.color.copy(REVISION.color), this.map = REVISION.map, this.lightMap = REVISION.lightMap, this.lightMapIntensity = REVISION.lightMapIntensity, this.aoMap = REVISION.aoMap, this.aoMapIntensity = REVISION.aoMapIntensity, this.specularMap = REVISION.specularMap, this.alphaMap = REVISION.alphaMap, this.envMap = REVISION.envMap, this.envMapRotation.copy(REVISION.envMapRotation), this.combine = REVISION.combine, this.reflectivity = REVISION.reflectivity, this.refractionRatio = REVISION.refractionRatio, this.wireframe = REVISION.wireframe, this.wireframeLinewidth = REVISION.wireframeLinewidth, this.wireframeLinecap = REVISION.wireframeLinecap, this.wireframeLinejoin = REVISION.wireframeLinejoin, this.fog = REVISION.fog, this;
            }
        }
        const _vector$9 = new Vector3(), _vector2$1 = new Vector2();
        let _id$2 = 0;
        class BufferAttribute {
            constructor(REVISION, t, n = !1) {
                if (Array.isArray(REVISION))
                    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
                this.isBufferAttribute = !0, Object.defineProperty(this, 'id', { value: _id$2++ }), this.name = '', this.array = REVISION, this.itemSize = t, this.count = void 0 !== REVISION ? REVISION.length / t : 0, this.normalized = n, this.usage = StaticDrawUsage, this.updateRanges = [], this.gpuType = FloatType, this.version = 0;
            }
            onUploadCallback() {
            }
            set needsUpdate(REVISION) {
                !0 === REVISION && this.version++;
            }
            setUsage(REVISION) {
                return this.usage = REVISION, this;
            }
            addUpdateRange(REVISION, t) {
                this.updateRanges.push({
                    start: REVISION,
                    count: t
                });
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0;
            }
            copy(REVISION) {
                return this.name = REVISION.name, this.array = new REVISION.array.constructor(REVISION.array), this.itemSize = REVISION.itemSize, this.count = REVISION.count, this.normalized = REVISION.normalized, this.usage = REVISION.usage, this.gpuType = REVISION.gpuType, this;
            }
            copyAt(REVISION, t, n) {
                REVISION *= this.itemSize, n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[REVISION + i] = t.array[n + i];
                return this;
            }
            copyArray(REVISION) {
                return this.array.set(REVISION), this;
            }
            applyMatrix3(REVISION) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        _vector2$1.fromBufferAttribute(this, t), _vector2$1.applyMatrix3(REVISION), this.setXY(t, _vector2$1.x, _vector2$1.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        _vector$9.fromBufferAttribute(this, t), _vector$9.applyMatrix3(REVISION), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
                return this;
            }
            applyMatrix4(REVISION) {
                for (let t = 0, n = this.count; t < n; t++)
                    _vector$9.fromBufferAttribute(this, t), _vector$9.applyMatrix4(REVISION), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
                return this;
            }
            applyNormalMatrix(REVISION) {
                for (let t = 0, n = this.count; t < n; t++)
                    _vector$9.fromBufferAttribute(this, t), _vector$9.applyNormalMatrix(REVISION), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
                return this;
            }
            transformDirection(REVISION) {
                for (let t = 0, n = this.count; t < n; t++)
                    _vector$9.fromBufferAttribute(this, t), _vector$9.transformDirection(REVISION), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
                return this;
            }
            set(REVISION, t = 0) {
                return this.array.set(REVISION, t), this;
            }
            getComponent(REVISION, t) {
                let n = this.array[REVISION * this.itemSize + t];
                return this.normalized && (n = denormalize(n, this.array)), n;
            }
            setComponent(REVISION, t, n) {
                return this.normalized && (n = xt(n, this.array)), this.array[REVISION * this.itemSize + t] = n, this;
            }
            getX(REVISION) {
                let t = this.array[REVISION * this.itemSize];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            setX(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.array[REVISION * this.itemSize] = t, this;
            }
            getY(REVISION) {
                let t = this.array[REVISION * this.itemSize + 1];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            setY(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.array[REVISION * this.itemSize + 1] = t, this;
            }
            getZ(REVISION) {
                let t = this.array[REVISION * this.itemSize + 2];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            setZ(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.array[REVISION * this.itemSize + 2] = t, this;
            }
            getW(REVISION) {
                let t = this.array[REVISION * this.itemSize + 3];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            setW(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.array[REVISION * this.itemSize + 3] = t, this;
            }
            setXY(REVISION, t, n) {
                return REVISION *= this.itemSize, this.normalized && (t = xt(t, this.array), n = xt(n, this.array)), this.array[REVISION + 0] = t, this.array[REVISION + 1] = n, this;
            }
            setXYZ(REVISION, t, n, i) {
                return REVISION *= this.itemSize, this.normalized && (t = xt(t, this.array), n = xt(n, this.array), i = xt(i, this.array)), this.array[REVISION + 0] = t, this.array[REVISION + 1] = n, this.array[REVISION + 2] = i, this;
            }
            setXYZW(REVISION, t, n, i, r) {
                return REVISION *= this.itemSize, this.normalized && (t = xt(t, this.array), n = xt(n, this.array), i = xt(i, this.array), r = xt(r, this.array)), this.array[REVISION + 0] = t, this.array[REVISION + 1] = n, this.array[REVISION + 2] = i, this.array[REVISION + 3] = r, this;
            }
            onUpload(REVISION) {
                return this.onUploadCallback = REVISION, this;
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this);
            }
            toJSON() {
                const REVISION = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return '' !== this.name && (REVISION.name = this.name), this.usage !== StaticDrawUsage && (REVISION.usage = this.usage), REVISION;
            }
        }
        class Ii extends BufferAttribute {
            constructor(REVISION, t, n) {
                super(new Uint16Array(REVISION), t, n);
            }
        }
        class Ri extends BufferAttribute {
            constructor(REVISION, t, n) {
                super(new Uint32Array(REVISION), t, n);
            }
        }
        class Float32BufferAttribute extends BufferAttribute {
            constructor(REVISION, t, n) {
                super(new Float32Array(REVISION), t, n);
            }
        }
        let _id$1 = 0;
        const _m1 = new Matrix4(), _obj = new Object3D(), _offset = new Vector3(), _box$2 = new Box3(), _boxMorphTargets = new Box3(), _vector$8 = new Vector3();
        class BufferGeometry extends EventDispatcher {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, 'id', { value: _id$1++ }), this.uuid = At(), this.name = '', this.type = 'BufferGeometry', this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {};
            }
            getIndex() {
                return this.index;
            }
            setIndex(REVISION) {
                return Array.isArray(REVISION) ? this.index = new ((Tt(REVISION)) ? Ri : Ii)(REVISION, 1) : this.index = REVISION, this;
            }
            setIndirect(REVISION) {
                return this.indirect = REVISION, this;
            }
            getIndirect() {
                return this.indirect;
            }
            getAttribute(REVISION) {
                return this.attributes[REVISION];
            }
            setAttribute(REVISION, t) {
                return this.attributes[REVISION] = t, this;
            }
            deleteAttribute(REVISION) {
                return delete this.attributes[REVISION], this;
            }
            hasAttribute(REVISION) {
                return void 0 !== this.attributes[REVISION];
            }
            addGroup(REVISION, t, n = 0) {
                this.groups.push({
                    start: REVISION,
                    count: t,
                    materialIndex: n
                });
            }
            clearGroups() {
                this.groups = [];
            }
            setDrawRange(REVISION, t) {
                this.drawRange.start = REVISION, this.drawRange.count = t;
            }
            applyMatrix4(REVISION) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(REVISION), t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = new Matrix3().getNormalMatrix(REVISION);
                    n.applyNormalMatrix(t), n.needsUpdate = !0;
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(REVISION), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
            }
            applyQuaternion(REVISION) {
                return _m1.makeRotationFromQuaternion(REVISION), this.applyMatrix4(_m1), this;
            }
            rotateX(REVISION) {
                return _m1.makeRotationX(REVISION), this.applyMatrix4(_m1), this;
            }
            rotateY(REVISION) {
                return _m1.makeRotationY(REVISION), this.applyMatrix4(_m1), this;
            }
            rotateZ(REVISION) {
                return _m1.makeRotationZ(REVISION), this.applyMatrix4(_m1), this;
            }
            translate(REVISION, t, n) {
                return _m1.makeTranslation(REVISION, t, n), this.applyMatrix4(_m1), this;
            }
            scale(REVISION, t, n) {
                return _m1.makeScale(REVISION, t, n), this.applyMatrix4(_m1), this;
            }
            lookAt(REVISION) {
                return _obj.lookAt(REVISION), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
            }
            setFromPoints(REVISION) {
                const t = this.getAttribute('position');
                if (void 0 === t) {
                    const t = [];
                    for (let n = 0, i = REVISION.length; n < i; n++) {
                        const i = REVISION[n];
                        t.push(i.x, i.y, i.z || 0);
                    }
                    this.setAttribute('position', new Float32BufferAttribute(t, 3));
                } else {
                    const n = Math.min(REVISION.length, t.count);
                    for (let i = 0; i < n; i++) {
                        const n = REVISION[i];
                        t.setXYZ(i, n.x, n.y, n.z || 0);
                    }
                    REVISION.length > t.count && console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.'), t.needsUpdate = !0;
                }
                return this;
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new Box3());
                const REVISION = this.attributes.position, t = this.morphAttributes.position;
                if (REVISION && REVISION.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this), void this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== REVISION) {
                    if (this.boundingBox.setFromBufferAttribute(REVISION), t)
                        for (let REVISION = 0, n = t.length; REVISION < n; REVISION++) {
                            const n = t[REVISION];
                            _box$2.setFromBufferAttribute(n), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max));
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Sphere());
                const REVISION = this.attributes.position, t = this.morphAttributes.position;
                if (REVISION && REVISION.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this), void this.boundingSphere.set(new Vector3(), 1 / 0);
                if (REVISION) {
                    const n = this.boundingSphere.center;
                    if (_box$2.setFromBufferAttribute(REVISION), t)
                        for (let REVISION = 0, n = t.length; REVISION < n; REVISION++) {
                            const n = t[REVISION];
                            _boxMorphTargets.setFromBufferAttribute(n), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max));
                        }
                    _box$2.getCenter(n);
                    let i = 0;
                    for (let t = 0, r = REVISION.count; t < r; t++)
                        _vector$8.fromBufferAttribute(REVISION, t), i = Math.max(i, n.distanceToSquared(_vector$8));
                    if (t)
                        for (let r = 0, AddEquation = t.length; r < AddEquation; r++) {
                            const AddEquation = t[r], SubtractEquation = this.morphTargetsRelative;
                            for (let t = 0, r = AddEquation.count; t < r; t++)
                                _vector$8.fromBufferAttribute(AddEquation, t), SubtractEquation && (_offset.fromBufferAttribute(REVISION, t), _vector$8.add(_offset)), i = Math.max(i, n.distanceToSquared(_vector$8));
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            }
            computeTangents() {
                const REVISION = this.index, t = this.attributes;
                if (null === REVISION || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                    return void console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
                const n = t.position, i = t.normal, r = t.uv;
                !1 === this.hasAttribute('tangent') && this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * n.count), 4));
                const AddEquation = this.getAttribute('tangent'), SubtractEquation = [], ReverseSubtractEquation = [];
                for (let REVISION = 0; REVISION < n.count; REVISION++)
                    SubtractEquation[REVISION] = new Vector3(), ReverseSubtractEquation[REVISION] = new Vector3();
                const ZeroFactor = new Vector3(), OneFactor = new Vector3(), SrcColorFactor = new Vector3(), OneMinusSrcColorFactor = new Vector2(), SrcAlphaFactor = new Vector2(), OneMinusSrcAlphaFactor = new Vector2(), DstAlphaFactor = new Vector3(), OneMinusDstAlphaFactor = new Vector3();
                function DstColorFactor(REVISION, t, i) {
                    ZeroFactor.fromBufferAttribute(n, REVISION), OneFactor.fromBufferAttribute(n, t), SrcColorFactor.fromBufferAttribute(n, i), OneMinusSrcColorFactor.fromBufferAttribute(r, REVISION), SrcAlphaFactor.fromBufferAttribute(r, t), OneMinusSrcAlphaFactor.fromBufferAttribute(r, i), OneFactor.sub(ZeroFactor), SrcColorFactor.sub(ZeroFactor), SrcAlphaFactor.sub(OneMinusSrcColorFactor), OneMinusSrcAlphaFactor.sub(OneMinusSrcColorFactor);
                    const AddEquation = 1 / (SrcAlphaFactor.x * OneMinusSrcAlphaFactor.y - OneMinusSrcAlphaFactor.x * SrcAlphaFactor.y);
                    isFinite(AddEquation) && (DstAlphaFactor.copy(OneFactor).multiplyScalar(OneMinusSrcAlphaFactor.y).addScaledVector(SrcColorFactor, -SrcAlphaFactor.y).multiplyScalar(AddEquation), OneMinusDstAlphaFactor.copy(SrcColorFactor).multiplyScalar(SrcAlphaFactor.x).addScaledVector(OneFactor, -OneMinusSrcAlphaFactor.x).multiplyScalar(AddEquation), SubtractEquation[REVISION].add(DstAlphaFactor), SubtractEquation[t].add(DstAlphaFactor), SubtractEquation[i].add(DstAlphaFactor), ReverseSubtractEquation[REVISION].add(OneMinusDstAlphaFactor), ReverseSubtractEquation[t].add(OneMinusDstAlphaFactor), ReverseSubtractEquation[i].add(OneMinusDstAlphaFactor));
                }
                let OneMinusDstColorFactor = this.groups;
                0 === OneMinusDstColorFactor.length && (OneMinusDstColorFactor = [{
                        start: 0,
                        count: REVISION.count
                    }]);
                for (let t = 0, n = OneMinusDstColorFactor.length; t < n; ++t) {
                    const n = OneMinusDstColorFactor[t], i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3)
                        DstColorFactor(REVISION.getX(t + 0), REVISION.getX(t + 1), REVISION.getX(t + 2));
                }
                const SrcAlphaSaturateFactor = new Vector3(), ConstantColorFactor = new Vector3(), OneMinusConstantColorFactor = new Vector3(), ConstantAlphaFactor = new Vector3();
                function OneMinusConstantAlphaFactor(REVISION) {
                    OneMinusConstantColorFactor.fromBufferAttribute(i, REVISION), ConstantAlphaFactor.copy(OneMinusConstantColorFactor);
                    const t = SubtractEquation[REVISION];
                    SrcAlphaSaturateFactor.copy(t), SrcAlphaSaturateFactor.sub(OneMinusConstantColorFactor.multiplyScalar(OneMinusConstantColorFactor.dot(t))).normalize(), ConstantColorFactor.crossVectors(ConstantAlphaFactor, t);
                    const n = ConstantColorFactor.dot(ReverseSubtractEquation[REVISION]) < 0 ? -1 : 1;
                    AddEquation.setXYZW(REVISION, SrcAlphaSaturateFactor.x, SrcAlphaSaturateFactor.y, SrcAlphaSaturateFactor.z, n);
                }
                for (let t = 0, n = OneMinusDstColorFactor.length; t < n; ++t) {
                    const n = OneMinusDstColorFactor[t], i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3)
                        OneMinusConstantAlphaFactor(REVISION.getX(t + 0)), OneMinusConstantAlphaFactor(REVISION.getX(t + 1)), OneMinusConstantAlphaFactor(REVISION.getX(t + 2));
                }
            }
            computeVertexNormals() {
                const REVISION = this.index, t = this.getAttribute('position');
                if (void 0 !== t) {
                    let n = this.getAttribute('normal');
                    if (void 0 === n)
                        n = new BufferAttribute(new Float32Array(3 * t.count), 3), this.setAttribute('normal', n);
                    else
                        for (let REVISION = 0, t = n.count; REVISION < t; REVISION++)
                            n.setXYZ(REVISION, 0, 0, 0);
                    const i = new Vector3(), r = new Vector3(), AddEquation = new Vector3(), SubtractEquation = new Vector3(), ReverseSubtractEquation = new Vector3(), ZeroFactor = new Vector3(), OneFactor = new Vector3(), SrcColorFactor = new Vector3();
                    if (REVISION)
                        for (let OneMinusSrcColorFactor = 0, SrcAlphaFactor = REVISION.count; OneMinusSrcColorFactor < SrcAlphaFactor; OneMinusSrcColorFactor += 3) {
                            const SrcAlphaFactor = REVISION.getX(OneMinusSrcColorFactor + 0), OneMinusSrcAlphaFactor = REVISION.getX(OneMinusSrcColorFactor + 1), DstAlphaFactor = REVISION.getX(OneMinusSrcColorFactor + 2);
                            i.fromBufferAttribute(t, SrcAlphaFactor), r.fromBufferAttribute(t, OneMinusSrcAlphaFactor), AddEquation.fromBufferAttribute(t, DstAlphaFactor), OneFactor.subVectors(AddEquation, r), SrcColorFactor.subVectors(i, r), OneFactor.cross(SrcColorFactor), SubtractEquation.fromBufferAttribute(n, SrcAlphaFactor), ReverseSubtractEquation.fromBufferAttribute(n, OneMinusSrcAlphaFactor), ZeroFactor.fromBufferAttribute(n, DstAlphaFactor), SubtractEquation.add(OneFactor), ReverseSubtractEquation.add(OneFactor), ZeroFactor.add(OneFactor), n.setXYZ(SrcAlphaFactor, SubtractEquation.x, SubtractEquation.y, SubtractEquation.z), n.setXYZ(OneMinusSrcAlphaFactor, ReverseSubtractEquation.x, ReverseSubtractEquation.y, ReverseSubtractEquation.z), n.setXYZ(DstAlphaFactor, ZeroFactor.x, ZeroFactor.y, ZeroFactor.z);
                        }
                    else
                        for (let REVISION = 0, SubtractEquation = t.count; REVISION < SubtractEquation; REVISION += 3)
                            i.fromBufferAttribute(t, REVISION + 0), r.fromBufferAttribute(t, REVISION + 1), AddEquation.fromBufferAttribute(t, REVISION + 2), OneFactor.subVectors(AddEquation, r), SrcColorFactor.subVectors(i, r), OneFactor.cross(SrcColorFactor), n.setXYZ(REVISION + 0, OneFactor.x, OneFactor.y, OneFactor.z), n.setXYZ(REVISION + 1, OneFactor.x, OneFactor.y, OneFactor.z), n.setXYZ(REVISION + 2, OneFactor.x, OneFactor.y, OneFactor.z);
                    this.normalizeNormals(), n.needsUpdate = !0;
                }
            }
            normalizeNormals() {
                const REVISION = this.attributes.normal;
                for (let t = 0, n = REVISION.count; t < n; t++)
                    _vector$8.fromBufferAttribute(REVISION, t), _vector$8.normalize(), REVISION.setXYZ(t, _vector$8.x, _vector$8.y, _vector$8.z);
            }
            toNonIndexed() {
                function REVISION(REVISION, t) {
                    const n = REVISION.array, i = REVISION.itemSize, r = REVISION.normalized, AddEquation = new n.constructor(t.length * i);
                    let SubtractEquation = 0, ReverseSubtractEquation = 0;
                    for (let r = 0, ZeroFactor = t.length; r < ZeroFactor; r++) {
                        SubtractEquation = REVISION.isInterleavedBufferAttribute ? t[r] * REVISION.data.stride + REVISION.offset : t[r] * i;
                        for (let REVISION = 0; REVISION < i; REVISION++)
                            AddEquation[ReverseSubtractEquation++] = n[SubtractEquation++];
                    }
                    return new BufferAttribute(AddEquation, i, r);
                }
                if (null === this.index)
                    return console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'), this;
                const t = new BufferGeometry(), n = this.index.array, i = this.attributes;
                for (const r in i) {
                    const AddEquation = REVISION(i[r], n);
                    t.setAttribute(r, AddEquation);
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const AddEquation = [], SubtractEquation = r[i];
                    for (let t = 0, i = SubtractEquation.length; t < i; t++) {
                        const i = REVISION(SubtractEquation[t], n);
                        AddEquation.push(i);
                    }
                    t.morphAttributes[i] = AddEquation;
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const AddEquation = this.groups;
                for (let REVISION = 0, n = AddEquation.length; REVISION < n; REVISION++) {
                    const n = AddEquation[REVISION];
                    t.addGroup(n.start, n.count, n.materialIndex);
                }
                return t;
            }
            toJSON() {
                const REVISION = {
                    metadata: {
                        version: 4.6,
                        type: 'BufferGeometry',
                        generator: 'BufferGeometry.toJSON'
                    }
                };
                if (REVISION.uuid = this.uuid, REVISION.type = this.type, '' !== this.name && (REVISION.name = this.name), Object.keys(this.userData).length > 0 && (REVISION.userData = this.userData), void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t)
                        void 0 !== t[n] && (REVISION[n] = t[n]);
                    return REVISION;
                }
                REVISION.data = { attributes: {} };
                const t = this.index;
                null !== t && (REVISION.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const t in n) {
                    const i = n[t];
                    REVISION.data.attributes[t] = i.toJSON(REVISION.data);
                }
                const i = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const n = this.morphAttributes[t], AddEquation = [];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        AddEquation.push(i.toJSON(REVISION.data));
                    }
                    AddEquation.length > 0 && (i[t] = AddEquation, r = !0);
                }
                r && (REVISION.data.morphAttributes = i, REVISION.data.morphTargetsRelative = this.morphTargetsRelative);
                const AddEquation = this.groups;
                AddEquation.length > 0 && (REVISION.data.groups = JSON.parse(JSON.stringify(AddEquation)));
                const SubtractEquation = this.boundingSphere;
                return null !== SubtractEquation && (REVISION.data.boundingSphere = {
                    center: SubtractEquation.center.toArray(),
                    radius: SubtractEquation.radius
                }), REVISION;
            }
            clone() {
                return new this.constructor().copy(this);
            }
            copy(REVISION) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const t = {};
                this.name = REVISION.name;
                const n = REVISION.index;
                null !== n && this.setIndex(n.clone(t));
                const i = REVISION.attributes;
                for (const REVISION in i) {
                    const n = i[REVISION];
                    this.setAttribute(REVISION, n.clone(t));
                }
                const r = REVISION.morphAttributes;
                for (const REVISION in r) {
                    const n = [], i = r[REVISION];
                    for (let REVISION = 0, r = i.length; REVISION < r; REVISION++)
                        n.push(i[REVISION].clone(t));
                    this.morphAttributes[REVISION] = n;
                }
                this.morphTargetsRelative = REVISION.morphTargetsRelative;
                const AddEquation = REVISION.groups;
                for (let REVISION = 0, t = AddEquation.length; REVISION < t; REVISION++) {
                    const t = AddEquation[REVISION];
                    this.addGroup(t.start, t.count, t.materialIndex);
                }
                const SubtractEquation = REVISION.boundingBox;
                null !== SubtractEquation && (this.boundingBox = SubtractEquation.clone());
                const ReverseSubtractEquation = REVISION.boundingSphere;
                return null !== ReverseSubtractEquation && (this.boundingSphere = ReverseSubtractEquation.clone()), this.drawRange.start = REVISION.drawRange.start, this.drawRange.count = REVISION.drawRange.count, this.userData = REVISION.userData, this;
            }
            dispose() {
                this.dispatchEvent({ type: 'dispose' });
            }
        }
        const _inverseMatrix$3 = new Matrix4(), _ray$3 = new Ray(), _sphere$6 = new Sphere(), _sphereHitAt = new Vector3(), _vA$1 = new Vector3(), _vB$1 = new Vector3(), _vC$1 = new Vector3(), _tempA = new Vector3(), _morphA = new Vector3(), _intersectionPoint = new Vector3(), _intersectionPointWorld = new Vector3();
        class Mesh extends Object3D {
            constructor(REVISION = new BufferGeometry(), t = new Si()) {
                super(), this.isMesh = !0, this.type = 'Mesh', this.geometry = REVISION, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), void 0 !== REVISION.morphTargetInfluences && (this.morphTargetInfluences = REVISION.morphTargetInfluences.slice()), void 0 !== REVISION.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, REVISION.morphTargetDictionary)), this.material = Array.isArray(REVISION.material) ? REVISION.material.slice() : REVISION.material, this.geometry = REVISION.geometry, this;
            }
            updateMorphTargets() {
                const REVISION = this.geometry.morphAttributes, t = Object.keys(REVISION);
                if (t.length > 0) {
                    const n = REVISION[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let REVISION = 0, t = n.length; REVISION < t; REVISION++) {
                            const t = n[REVISION].name || String(REVISION);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = REVISION;
                        }
                    }
                }
            }
            getVertexPosition(REVISION, t) {
                const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, AddEquation = n.morphTargetsRelative;
                t.fromBufferAttribute(i, REVISION);
                const SubtractEquation = this.morphTargetInfluences;
                if (r && SubtractEquation) {
                    _morphA.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = SubtractEquation[n], ReverseSubtractEquation = r[n];
                        0 !== i && (_tempA.fromBufferAttribute(ReverseSubtractEquation, REVISION), AddEquation ? _morphA.addScaledVector(_tempA, i) : _morphA.addScaledVector(_tempA.sub(t), i));
                    }
                    t.add(_morphA);
                }
                return t;
            }
            raycast(REVISION, t) {
                const n = this.geometry, i = this.material, r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere$6.copy(n.boundingSphere), _sphere$6.applyMatrix4(r), _ray$3.copy(REVISION.ray).recast(REVISION.near), !1 === _sphere$6.containsPoint(_ray$3.origin)) {
                        if (null === _ray$3.intersectSphere(_sphere$6, _sphereHitAt))
                            return;
                        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (REVISION.far - REVISION.near) ** 2)
                            return;
                    }
                    _inverseMatrix$3.copy(r).invert(), _ray$3.copy(REVISION.ray).applyMatrix4(_inverseMatrix$3), null !== n.boundingBox && !1 === _ray$3.intersectsBox(n.boundingBox) || this._computeIntersections(REVISION, t, _ray$3);
                }
            }
            _computeIntersections(REVISION, t, n) {
                let i;
                const r = this.geometry, AddEquation = this.material, SubtractEquation = r.index, ReverseSubtractEquation = r.attributes.position, ZeroFactor = r.attributes.uv, OneFactor = r.attributes.uv1, SrcColorFactor = r.attributes.normal, OneMinusSrcColorFactor = r.groups, SrcAlphaFactor = r.drawRange;
                if (null !== SubtractEquation)
                    if (Array.isArray(AddEquation))
                        for (let r = 0, ReverseSubtractEquation = OneMinusSrcColorFactor.length; r < ReverseSubtractEquation; r++) {
                            const ReverseSubtractEquation = OneMinusSrcColorFactor[r], OneMinusSrcAlphaFactor = AddEquation[ReverseSubtractEquation.materialIndex];
                            for (let r = Math.max(ReverseSubtractEquation.start, SrcAlphaFactor.start), AddEquation = Math.min(SubtractEquation.count, Math.min(ReverseSubtractEquation.start + ReverseSubtractEquation.count, SrcAlphaFactor.start + SrcAlphaFactor.count)); r < AddEquation; r += 3) {
                                i = Ji(this, OneMinusSrcAlphaFactor, REVISION, n, ZeroFactor, OneFactor, SrcColorFactor, SubtractEquation.getX(r), SubtractEquation.getX(r + 1), SubtractEquation.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = ReverseSubtractEquation.materialIndex, t.push(i));
                            }
                        }
                    else {
                        for (let r = Math.max(0, SrcAlphaFactor.start), ReverseSubtractEquation = Math.min(SubtractEquation.count, SrcAlphaFactor.start + SrcAlphaFactor.count); r < ReverseSubtractEquation; r += 3) {
                            i = Ji(this, AddEquation, REVISION, n, ZeroFactor, OneFactor, SrcColorFactor, SubtractEquation.getX(r), SubtractEquation.getX(r + 1), SubtractEquation.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), t.push(i));
                        }
                    }
                else if (void 0 !== ReverseSubtractEquation)
                    if (Array.isArray(AddEquation))
                        for (let r = 0, SubtractEquation = OneMinusSrcColorFactor.length; r < SubtractEquation; r++) {
                            const SubtractEquation = OneMinusSrcColorFactor[r], OneMinusSrcAlphaFactor = AddEquation[SubtractEquation.materialIndex];
                            for (let r = Math.max(SubtractEquation.start, SrcAlphaFactor.start), AddEquation = Math.min(ReverseSubtractEquation.count, Math.min(SubtractEquation.start + SubtractEquation.count, SrcAlphaFactor.start + SrcAlphaFactor.count)); r < AddEquation; r += 3) {
                                i = Ji(this, OneMinusSrcAlphaFactor, REVISION, n, ZeroFactor, OneFactor, SrcColorFactor, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = SubtractEquation.materialIndex, t.push(i));
                            }
                        }
                    else {
                        for (let r = Math.max(0, SrcAlphaFactor.start), SubtractEquation = Math.min(ReverseSubtractEquation.count, SrcAlphaFactor.start + SrcAlphaFactor.count); r < SubtractEquation; r += 3) {
                            i = Ji(this, AddEquation, REVISION, n, ZeroFactor, OneFactor, SrcColorFactor, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), t.push(i));
                        }
                    }
            }
        }
        function Ji(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) {
            REVISION.getVertexPosition(ReverseSubtractEquation, _vA$1), REVISION.getVertexPosition(ZeroFactor, _vB$1), REVISION.getVertexPosition(OneFactor, _vC$1);
            const SrcColorFactor = function (REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                let ZeroFactor;
                if (ZeroFactor = 1 === t.side ? i.intersectTriangle(SubtractEquation, AddEquation, r, !0, ReverseSubtractEquation) : i.intersectTriangle(r, AddEquation, SubtractEquation, 0 === t.side, ReverseSubtractEquation), null === ZeroFactor)
                    return null;
                _intersectionPointWorld.copy(ReverseSubtractEquation), _intersectionPointWorld.applyMatrix4(REVISION.matrixWorld);
                const OneFactor = n.ray.origin.distanceTo(_intersectionPointWorld);
                return OneFactor < n.near || OneFactor > n.far ? null : {
                    distance: OneFactor,
                    point: _intersectionPointWorld.clone(),
                    object: REVISION
                };
            }(REVISION, t, n, i, _vA$1, _vB$1, _vC$1, _intersectionPoint);
            if (SrcColorFactor) {
                const REVISION = new Vector3();
                Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, REVISION), r && (SrcColorFactor.uv = Triangle.getInterpolatedAttribute(r, ReverseSubtractEquation, ZeroFactor, OneFactor, REVISION, new Vector2())), AddEquation && (SrcColorFactor.uv1 = Triangle.getInterpolatedAttribute(AddEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, REVISION, new Vector2())), SubtractEquation && (SrcColorFactor.normal = Triangle.getInterpolatedAttribute(SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, REVISION, new Vector3()), SrcColorFactor.normal.dot(i.direction) > 0 && SrcColorFactor.normal.multiplyScalar(-1));
                const t = {
                    a: ReverseSubtractEquation,
                    b: ZeroFactor,
                    c,
                    normal: new Vector3(),
                    materialIndex: 0
                };
                Triangle.getNormal(_vA$1, _vB$1, _vC$1, t.normal), SrcColorFactor.face = t, SrcColorFactor.barycoord = REVISION;
            }
            return SrcColorFactor;
        }
        class $i extends BufferGeometry {
            constructor(REVISION = 1, t = 1, n = 1, i = 1, r = 1, AddEquation = 1) {
                super(), this.type = 'BoxGeometry', this.parameters = {
                    width: REVISION,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: AddEquation
                };
                const SubtractEquation = this;
                i = Math.floor(i), r = Math.floor(r), AddEquation = Math.floor(AddEquation);
                const ReverseSubtractEquation = [], ZeroFactor = [], OneFactor = [], SrcColorFactor = [];
                let OneMinusSrcColorFactor = 0, SrcAlphaFactor = 0;
                function OneMinusSrcAlphaFactor(REVISION, t, n, i, r, AddEquation, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor) {
                    const SrcAlphaSaturateFactor = AddEquation / OneMinusDstAlphaFactor, ConstantColorFactor = OneMinusSrcAlphaFactor / DstColorFactor, OneMinusConstantColorFactor = AddEquation / 2, ConstantAlphaFactor = OneMinusSrcAlphaFactor / 2, OneMinusConstantAlphaFactor = DstAlphaFactor / 2, b = OneMinusDstAlphaFactor + 1, aspect = DstColorFactor + 1;
                    let CullFaceFront = 0, LessEqualDepth = 0;
                    const MultiplyBlending = new Vector3();
                    for (let AddEquation = 0; AddEquation < aspect; AddEquation++) {
                        const SubtractEquation = AddEquation * ConstantColorFactor - ConstantAlphaFactor;
                        for (let ReverseSubtractEquation = 0; ReverseSubtractEquation < b; ReverseSubtractEquation++) {
                            const OneMinusSrcColorFactor = ReverseSubtractEquation * SrcAlphaSaturateFactor - OneMinusConstantColorFactor;
                            MultiplyBlending[REVISION] = OneMinusSrcColorFactor * i, MultiplyBlending[t] = SubtractEquation * r, MultiplyBlending[n] = OneMinusConstantAlphaFactor, ZeroFactor.push(MultiplyBlending.x, MultiplyBlending.y, MultiplyBlending.z), MultiplyBlending[REVISION] = 0, MultiplyBlending[t] = 0, MultiplyBlending[n] = DstAlphaFactor > 0 ? 1 : -1, OneFactor.push(MultiplyBlending.x, MultiplyBlending.y, MultiplyBlending.z), SrcColorFactor.push(ReverseSubtractEquation / OneMinusDstAlphaFactor), SrcColorFactor.push(1 - AddEquation / DstColorFactor), CullFaceFront += 1;
                        }
                    }
                    for (let REVISION = 0; REVISION < DstColorFactor; REVISION++)
                        for (let t = 0; t < OneMinusDstAlphaFactor; t++) {
                            const n = OneMinusSrcColorFactor + t + b * REVISION, i = OneMinusSrcColorFactor + t + b * (REVISION + 1), r = OneMinusSrcColorFactor + (t + 1) + b * (REVISION + 1), AddEquation = OneMinusSrcColorFactor + (t + 1) + b * REVISION;
                            ReverseSubtractEquation.push(n, i, AddEquation), ReverseSubtractEquation.push(i, r, AddEquation), LessEqualDepth += 6;
                        }
                    SubtractEquation.addGroup(SrcAlphaFactor, LessEqualDepth, OneMinusDstColorFactor), SrcAlphaFactor += LessEqualDepth, OneMinusSrcColorFactor += CullFaceFront;
                }
                OneMinusSrcAlphaFactor('z', 'y', 'x', -1, -1, n, t, REVISION, AddEquation, r, 0), OneMinusSrcAlphaFactor('z', 'y', 'x', 1, -1, n, t, -REVISION, AddEquation, r, 1), OneMinusSrcAlphaFactor('x', 'z', 'y', 1, 1, REVISION, n, t, i, AddEquation, 2), OneMinusSrcAlphaFactor('x', 'z', 'y', 1, -1, REVISION, n, -t, i, AddEquation, 3), OneMinusSrcAlphaFactor('x', 'y', 'z', 1, -1, REVISION, t, n, i, r, 4), OneMinusSrcAlphaFactor('x', 'y', 'z', -1, -1, REVISION, t, -n, i, r, 5), this.setIndex(ReverseSubtractEquation), this.setAttribute('position', new Float32BufferAttribute(ZeroFactor, 3)), this.setAttribute('normal', new Float32BufferAttribute(OneFactor, 3)), this.setAttribute('uv', new Float32BufferAttribute(SrcColorFactor, 2));
            }
            copy(REVISION) {
                return super.copy(REVISION), this.parameters = Object.assign({}, REVISION.parameters), this;
            }
            static fromJSON(REVISION) {
                return new $i(REVISION.width, REVISION.height, REVISION.depth, REVISION.widthSegments, REVISION.heightSegments, REVISION.depthSegments);
            }
        }
        function er(REVISION) {
            const t = {};
            for (const n in REVISION) {
                t[n] = {};
                for (const i in REVISION[n]) {
                    const r = REVISION[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'), t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r;
                }
            }
            return t;
        }
        function tr(REVISION) {
            const t = {};
            for (let n = 0; n < REVISION.length; n++) {
                const i = er(REVISION[n]);
                for (const REVISION in i)
                    t[REVISION] = i[REVISION];
            }
            return t;
        }
        function nr(REVISION) {
            const t = REVISION.getRenderTarget();
            return null === t ? REVISION.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : _tables.workingColorSpace;
        }
        const UniformsUtils = {
            clone: er,
            merge: tr
        };
        class rr extends Material {
            constructor(REVISION) {
                super(), this.isShaderMaterial = !0, this.type = 'ShaderMaterial', this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}', this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}', this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    clipCullDistance: !1,
                    multiDraw: !1
                }, this.defaultAttributeValues = {
                    color: [
                        1,
                        1,
                        1
                    ],
                    uv: [
                        0,
                        0
                    ],
                    uv1: [
                        0,
                        0
                    ]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== REVISION && this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.fragmentShader = REVISION.fragmentShader, this.vertexShader = REVISION.vertexShader, this.uniforms = er(REVISION.uniforms), this.uniformsGroups = function (REVISION) {
                    const t = [];
                    for (let n = 0; n < REVISION.length; n++)
                        t.push(REVISION[n].clone());
                    return t;
                }(REVISION.uniformsGroups), this.defines = Object.assign({}, REVISION.defines), this.wireframe = REVISION.wireframe, this.wireframeLinewidth = REVISION.wireframeLinewidth, this.fog = REVISION.fog, this.lights = REVISION.lights, this.clipping = REVISION.clipping, this.extensions = Object.assign({}, REVISION.extensions), this.glslVersion = REVISION.glslVersion, this;
            }
            toJSON(REVISION) {
                const t = super.toJSON(REVISION);
                t.glslVersion = this.glslVersion, t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: 't',
                        value: i.toJSON(REVISION).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: 'c',
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: 'v2',
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: 'v3',
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: 'v4',
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: 'm3',
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: 'm4',
                        value: i.toArray()
                    } : t.uniforms[n] = { value: i };
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                const n = {};
                for (const REVISION in this.extensions)
                    !0 === this.extensions[REVISION] && (n[REVISION] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n), t;
            }
        }
        class Camera extends Object3D {
            constructor() {
                super(), this.isCamera = !0, this.type = 'Camera', this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4(), this.coordinateSystem = WebGLCoordinateSystem;
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.matrixWorldInverse.copy(REVISION.matrixWorldInverse), this.projectionMatrix.copy(REVISION.projectionMatrix), this.projectionMatrixInverse.copy(REVISION.projectionMatrixInverse), this.coordinateSystem = REVISION.coordinateSystem, this;
            }
            getWorldDirection(REVISION) {
                return super.getWorldDirection(REVISION).negate();
            }
            updateMatrixWorld(REVISION) {
                super.updateMatrixWorld(REVISION), this.matrixWorldInverse.copy(this.matrixWorld).invert();
            }
            updateWorldMatrix(REVISION, t) {
                super.updateWorldMatrix(REVISION, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
            }
            clone() {
                return new this.constructor().copy(this);
            }
        }
        const _v3$1 = new Vector3(), _minTarget = new Vector2(), _maxTarget = new Vector2();
        class PerspectiveCamera extends Camera {
            constructor(REVISION = 50, t = 1, n = 0.1, i = 2000) {
                super(), this.isPerspectiveCamera = !0, this.type = 'PerspectiveCamera', this.fov = REVISION, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.fov = REVISION.fov, this.zoom = REVISION.zoom, this.near = REVISION.near, this.far = REVISION.far, this.focus = REVISION.focus, this.aspect = REVISION.aspect, this.view = null === REVISION.view ? null : Object.assign({}, REVISION.view), this.filmGauge = REVISION.filmGauge, this.filmOffset = REVISION.filmOffset, this;
            }
            setFocalLength(REVISION) {
                const t = 0.5 * this.getFilmHeight() / REVISION;
                this.fov = 2 * RAD2DEG * Math.atan(t), this.updateProjectionMatrix();
            }
            getFocalLength() {
                const REVISION = Math.tan(0.5 * DEG2RAD * this.fov);
                return 0.5 * this.getFilmHeight() / REVISION;
            }
            getEffectiveFOV() {
                return 2 * RAD2DEG * Math.atan(Math.tan(0.5 * DEG2RAD * this.fov) / this.zoom);
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1);
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1);
            }
            getViewBounds(REVISION, t, n) {
                _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(_v3$1.x, _v3$1.y).multiplyScalar(-REVISION / _v3$1.z), _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(_v3$1.x, _v3$1.y).multiplyScalar(-REVISION / _v3$1.z);
            }
            getViewSize(REVISION, t) {
                return this.getViewBounds(REVISION, _minTarget, _maxTarget), t.subVectors(_maxTarget, _minTarget);
            }
            setViewOffset(REVISION, t, n, i, r, AddEquation) {
                this.aspect = REVISION / t, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = REVISION, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = AddEquation, this.updateProjectionMatrix();
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
            }
            updateProjectionMatrix() {
                const REVISION = this.near;
                let t = REVISION * Math.tan(0.5 * DEG2RAD * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
                const AddEquation = this.view;
                if (null !== this.view && this.view.enabled) {
                    const REVISION = AddEquation.fullWidth, SubtractEquation = AddEquation.fullHeight;
                    r += AddEquation.offsetX * i / REVISION, t -= AddEquation.offsetY * n / SubtractEquation, i *= AddEquation.width / REVISION, n *= AddEquation.height / SubtractEquation;
                }
                const SubtractEquation = this.filmOffset;
                0 !== SubtractEquation && (r += REVISION * SubtractEquation / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, REVISION, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
            toJSON(REVISION) {
                const t = super.toJSON(REVISION);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
            }
        }
        const fov = -90;
        class CubeCamera extends Object3D {
            constructor(REVISION, t, n) {
                super(), this.type = 'CubeCamera', this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                const i = new PerspectiveCamera(fov, 1, REVISION, t);
                i.layers = this.layers, this.add(i);
                const r = new PerspectiveCamera(fov, 1, REVISION, t);
                r.layers = this.layers, this.add(r);
                const AddEquation = new PerspectiveCamera(fov, 1, REVISION, t);
                AddEquation.layers = this.layers, this.add(AddEquation);
                const SubtractEquation = new PerspectiveCamera(fov, 1, REVISION, t);
                SubtractEquation.layers = this.layers, this.add(SubtractEquation);
                const ReverseSubtractEquation = new PerspectiveCamera(fov, 1, REVISION, t);
                ReverseSubtractEquation.layers = this.layers, this.add(ReverseSubtractEquation);
                const ZeroFactor = new PerspectiveCamera(fov, 1, REVISION, t);
                ZeroFactor.layers = this.layers, this.add(ZeroFactor);
            }
            updateCoordinateSystem() {
                const REVISION = this.coordinateSystem, t = this.children.concat(), [n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation] = t;
                for (const REVISION of t)
                    this.remove(REVISION);
                if (REVISION === WebGLCoordinateSystem)
                    n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), AddEquation.up.set(0, 0, 1), AddEquation.lookAt(0, -1, 0), SubtractEquation.up.set(0, 1, 0), SubtractEquation.lookAt(0, 0, 1), ReverseSubtractEquation.up.set(0, 1, 0), ReverseSubtractEquation.lookAt(0, 0, -1);
                else {
                    if (REVISION !== WebGPUCoordinateSystem)
                        throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + REVISION);
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), AddEquation.up.set(0, 0, -1), AddEquation.lookAt(0, -1, 0), SubtractEquation.up.set(0, -1, 0), SubtractEquation.lookAt(0, 0, 1), ReverseSubtractEquation.up.set(0, -1, 0), ReverseSubtractEquation.lookAt(0, 0, -1);
                }
                for (const REVISION of t)
                    this.add(REVISION), REVISION.updateMatrixWorld();
            }
            update(REVISION, t) {
                null === this.parent && this.updateMatrixWorld();
                const {
                    renderTarget: n,
                    activeMipmapLevel: i
                } = this;
                this.coordinateSystem !== REVISION.coordinateSystem && (this.coordinateSystem = REVISION.coordinateSystem, this.updateCoordinateSystem());
                const [r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor] = this.children, SrcColorFactor = REVISION.getRenderTarget(), OneMinusSrcColorFactor = REVISION.getActiveCubeFace(), SrcAlphaFactor = REVISION.getActiveMipmapLevel(), OneMinusSrcAlphaFactor = REVISION.xr.enabled;
                REVISION.xr.enabled = !1;
                const DstAlphaFactor = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, REVISION.setRenderTarget(n, 0, i), REVISION.render(t, r), REVISION.setRenderTarget(n, 1, i), REVISION.render(t, AddEquation), REVISION.setRenderTarget(n, 2, i), REVISION.render(t, SubtractEquation), REVISION.setRenderTarget(n, 3, i), REVISION.render(t, ReverseSubtractEquation), REVISION.setRenderTarget(n, 4, i), REVISION.render(t, ZeroFactor), n.texture.generateMipmaps = DstAlphaFactor, REVISION.setRenderTarget(n, 5, i), REVISION.render(t, OneFactor), REVISION.setRenderTarget(SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor), REVISION.xr.enabled = OneMinusSrcAlphaFactor, n.texture.needsPMREMUpdate = !0;
            }
        }
        class CubeTexture extends Texture {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) {
                super(REVISION = void 0 !== REVISION ? REVISION : [], t = void 0 !== t ? t : CubeReflectionMapping, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor), this.isCubeTexture = !0, this.flipY = !1;
            }
            get images() {
                return this.image;
            }
            set images(REVISION) {
                this.image = REVISION;
            }
        }
        class WebGLCubeRenderTarget extends jt {
            constructor(REVISION = 1, t = {}) {
                super(REVISION, REVISION, t), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: REVISION,
                        height: REVISION,
                        depth: 1
                    }, i = [
                        n,
                        n,
                        n,
                        n,
                        n,
                        n
                    ];
                this.texture = new CubeTexture(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : LinearFilter;
            }
            fromEquirectangularTexture(REVISION, t) {
                this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                const n = {
                        uniforms: { tEquirect: { value: null } },
                        vertexShader: '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
                        fragmentShader: '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t'
                    }, i = new $i(5, 5, 5), r = new rr({
                        name: 'CubemapFromEquirect',
                        uniforms: er(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: 1,
                        blending: 0
                    });
                r.uniforms.tEquirect.value = t;
                const AddEquation = new Mesh(i, r), SubtractEquation = t.minFilter;
                t.minFilter === LinearMipMapLinearFilter && (t.minFilter = LinearFilter);
                return new CubeCamera(1, 10, this).update(REVISION, AddEquation), t.minFilter = SubtractEquation, AddEquation.geometry.dispose(), AddEquation.material.dispose(), this;
            }
            clear(REVISION, t, n, i) {
                const r = REVISION.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    REVISION.setRenderTarget(this, r), REVISION.clear(t, n, i);
                REVISION.setRenderTarget(r);
            }
        }
        class pr extends Object3D {
            constructor() {
                super(), this.isGroup = !0, this.type = 'Group';
            }
        }
        const _moveEvent = { type: 'move' };
        class WebXRController {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null;
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new pr(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new pr(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3()), this._targetRay;
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new pr(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3()), this._grip;
            }
            dispatchEvent(REVISION) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(REVISION), null !== this._grip && this._grip.dispatchEvent(REVISION), null !== this._hand && this._hand.dispatchEvent(REVISION), this;
            }
            connect(REVISION) {
                if (REVISION && REVISION.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of REVISION.hand.values())
                            this._getHandJoint(t, n);
                }
                return this.dispatchEvent({
                    type: 'connected',
                    data: REVISION
                }), this;
            }
            disconnect(REVISION) {
                return this.dispatchEvent({
                    type: 'disconnected',
                    data: REVISION
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
            }
            update(REVISION, t, n) {
                let i = null, r = null, AddEquation = null;
                const SubtractEquation = this._targetRay, ReverseSubtractEquation = this._grip, ZeroFactor = this._hand;
                if (REVISION && 'visible-blurred' !== t.session.visibilityState) {
                    if (ZeroFactor && REVISION.hand) {
                        AddEquation = !0;
                        for (const i of REVISION.hand.values()) {
                            const REVISION = t.getJointPose(i, n), r = this._getHandJoint(ZeroFactor, i);
                            null !== REVISION && (r.matrix.fromArray(REVISION.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = REVISION.radius), r.visible = null !== REVISION;
                        }
                        const i = ZeroFactor.joints['index-finger-tip'], r = ZeroFactor.joints['thumb-tip'], SubtractEquation = i.position.distanceTo(r.position), ReverseSubtractEquation = 0.02, OneFactor = 0.005;
                        ZeroFactor.inputState.pinching && SubtractEquation > ReverseSubtractEquation + OneFactor ? (ZeroFactor.inputState.pinching = !1, this.dispatchEvent({
                            type: 'pinchend',
                            handedness: REVISION.handedness,
                            target: this
                        })) : !ZeroFactor.inputState.pinching && SubtractEquation <= ReverseSubtractEquation - OneFactor && (ZeroFactor.inputState.pinching = !0, this.dispatchEvent({
                            type: 'pinchstart',
                            handedness: REVISION.handedness,
                            target: this
                        }));
                    } else
                        null !== ReverseSubtractEquation && REVISION.gripSpace && (r = t.getPose(REVISION.gripSpace, n), null !== r && (ReverseSubtractEquation.matrix.fromArray(r.transform.matrix), ReverseSubtractEquation.matrix.decompose(ReverseSubtractEquation.position, ReverseSubtractEquation.rotation, ReverseSubtractEquation.scale), ReverseSubtractEquation.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (ReverseSubtractEquation.hasLinearVelocity = !0, ReverseSubtractEquation.linearVelocity.copy(r.linearVelocity)) : ReverseSubtractEquation.hasLinearVelocity = !1, r.angularVelocity ? (ReverseSubtractEquation.hasAngularVelocity = !0, ReverseSubtractEquation.angularVelocity.copy(r.angularVelocity)) : ReverseSubtractEquation.hasAngularVelocity = !1));
                    null !== SubtractEquation && (i = t.getPose(REVISION.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (SubtractEquation.matrix.fromArray(i.transform.matrix), SubtractEquation.matrix.decompose(SubtractEquation.position, SubtractEquation.rotation, SubtractEquation.scale), SubtractEquation.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (SubtractEquation.hasLinearVelocity = !0, SubtractEquation.linearVelocity.copy(i.linearVelocity)) : SubtractEquation.hasLinearVelocity = !1, i.angularVelocity ? (SubtractEquation.hasAngularVelocity = !0, SubtractEquation.angularVelocity.copy(i.angularVelocity)) : SubtractEquation.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent)));
                }
                return null !== SubtractEquation && (SubtractEquation.visible = null !== i), null !== ReverseSubtractEquation && (ReverseSubtractEquation.visible = null !== r), null !== ZeroFactor && (ZeroFactor.visible = null !== AddEquation), this;
            }
            _getHandJoint(REVISION, t) {
                if (void 0 === REVISION.joints[t.jointName]) {
                    const n = new pr();
                    n.matrixAutoUpdate = !1, n.visible = !1, REVISION.joints[t.jointName] = n, REVISION.add(n);
                }
                return REVISION.joints[t.jointName];
            }
        }
        class Fog {
            constructor(REVISION, t = 1, n = 1000) {
                this.isFog = !0, this.name = '', this.color = new Color(REVISION), this.near = t, this.far = n;
            }
            clone() {
                return new Fog(this.color, this.near, this.far);
            }
            toJSON() {
                return {
                    type: 'Fog',
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                };
            }
        }
        class _r extends Object3D {
            constructor() {
                super(), this.isScene = !0, this.type = 'Scene', this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Euler(), this.environmentIntensity = 1, this.environmentRotation = new Euler(), this.overrideMaterial = null, 'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), null !== REVISION.background && (this.background = REVISION.background.clone()), null !== REVISION.environment && (this.environment = REVISION.environment.clone()), null !== REVISION.fog && (this.fog = REVISION.fog.clone()), this.backgroundBlurriness = REVISION.backgroundBlurriness, this.backgroundIntensity = REVISION.backgroundIntensity, this.backgroundRotation.copy(REVISION.backgroundRotation), this.environmentIntensity = REVISION.environmentIntensity, this.environmentRotation.copy(REVISION.environmentRotation), null !== REVISION.overrideMaterial && (this.overrideMaterial = REVISION.overrideMaterial.clone()), this.matrixAutoUpdate = REVISION.matrixAutoUpdate, this;
            }
            toJSON(REVISION) {
                const t = super.toJSON(REVISION);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
            }
        }
        class InterleavedBuffer {
            constructor(REVISION, t) {
                this.isInterleavedBuffer = !0, this.array = REVISION, this.stride = t, this.count = void 0 !== REVISION ? REVISION.length / t : 0, this.usage = StaticDrawUsage, this.updateRanges = [], this.version = 0, this.uuid = At();
            }
            onUploadCallback() {
            }
            set needsUpdate(REVISION) {
                !0 === REVISION && this.version++;
            }
            setUsage(REVISION) {
                return this.usage = REVISION, this;
            }
            addUpdateRange(REVISION, t) {
                this.updateRanges.push({
                    start: REVISION,
                    count: t
                });
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0;
            }
            copy(REVISION) {
                return this.array = new REVISION.array.constructor(REVISION.array), this.count = REVISION.count, this.stride = REVISION.stride, this.usage = REVISION.usage, this;
            }
            copyAt(REVISION, t, n) {
                REVISION *= this.stride, n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[REVISION + i] = t.array[n + i];
                return this;
            }
            set(REVISION, t = 0) {
                return this.array.set(REVISION, t), this;
            }
            clone(REVISION) {
                void 0 === REVISION.arrayBuffers && (REVISION.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = At()), void 0 === REVISION.arrayBuffers[this.array.buffer._uuid] && (REVISION.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(REVISION.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
                return n.setUsage(this.usage), n;
            }
            onUpload(REVISION) {
                return this.onUploadCallback = REVISION, this;
            }
            toJSON(REVISION) {
                return void 0 === REVISION.arrayBuffers && (REVISION.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = At()), void 0 === REVISION.arrayBuffers[this.array.buffer._uuid] && (REVISION.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                };
            }
        }
        const _vector$7 = new Vector3();
        class InterleavedBufferAttribute {
            constructor(REVISION, t, n, i = !1) {
                this.isInterleavedBufferAttribute = !0, this.name = '', this.data = REVISION, this.itemSize = t, this.offset = n, this.normalized = i;
            }
            get count() {
                return this.data.count;
            }
            get array() {
                return this.data.array;
            }
            set needsUpdate(REVISION) {
                this.data.needsUpdate = REVISION;
            }
            applyMatrix4(REVISION) {
                for (let t = 0, n = this.data.count; t < n; t++)
                    _vector$7.fromBufferAttribute(this, t), _vector$7.applyMatrix4(REVISION), this.setXYZ(t, _vector$7.x, _vector$7.y, _vector$7.z);
                return this;
            }
            applyNormalMatrix(REVISION) {
                for (let t = 0, n = this.count; t < n; t++)
                    _vector$7.fromBufferAttribute(this, t), _vector$7.applyNormalMatrix(REVISION), this.setXYZ(t, _vector$7.x, _vector$7.y, _vector$7.z);
                return this;
            }
            transformDirection(REVISION) {
                for (let t = 0, n = this.count; t < n; t++)
                    _vector$7.fromBufferAttribute(this, t), _vector$7.transformDirection(REVISION), this.setXYZ(t, _vector$7.x, _vector$7.y, _vector$7.z);
                return this;
            }
            getComponent(REVISION, t) {
                let n = this.array[REVISION * this.data.stride + this.offset + t];
                return this.normalized && (n = denormalize(n, this.array)), n;
            }
            setComponent(REVISION, t, n) {
                return this.normalized && (n = xt(n, this.array)), this.data.array[REVISION * this.data.stride + this.offset + t] = n, this;
            }
            setX(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.data.array[REVISION * this.data.stride + this.offset] = t, this;
            }
            setY(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.data.array[REVISION * this.data.stride + this.offset + 1] = t, this;
            }
            setZ(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.data.array[REVISION * this.data.stride + this.offset + 2] = t, this;
            }
            setW(REVISION, t) {
                return this.normalized && (t = xt(t, this.array)), this.data.array[REVISION * this.data.stride + this.offset + 3] = t, this;
            }
            getX(REVISION) {
                let t = this.data.array[REVISION * this.data.stride + this.offset];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            getY(REVISION) {
                let t = this.data.array[REVISION * this.data.stride + this.offset + 1];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            getZ(REVISION) {
                let t = this.data.array[REVISION * this.data.stride + this.offset + 2];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            getW(REVISION) {
                let t = this.data.array[REVISION * this.data.stride + this.offset + 3];
                return this.normalized && (t = denormalize(t, this.array)), t;
            }
            setXY(REVISION, t, n) {
                return REVISION = REVISION * this.data.stride + this.offset, this.normalized && (t = xt(t, this.array), n = xt(n, this.array)), this.data.array[REVISION + 0] = t, this.data.array[REVISION + 1] = n, this;
            }
            setXYZ(REVISION, t, n, i) {
                return REVISION = REVISION * this.data.stride + this.offset, this.normalized && (t = xt(t, this.array), n = xt(n, this.array), i = xt(i, this.array)), this.data.array[REVISION + 0] = t, this.data.array[REVISION + 1] = n, this.data.array[REVISION + 2] = i, this;
            }
            setXYZW(REVISION, t, n, i, r) {
                return REVISION = REVISION * this.data.stride + this.offset, this.normalized && (t = xt(t, this.array), n = xt(n, this.array), i = xt(i, this.array), r = xt(r, this.array)), this.data.array[REVISION + 0] = t, this.data.array[REVISION + 1] = n, this.data.array[REVISION + 2] = i, this.data.array[REVISION + 3] = r, this;
            }
            clone(REVISION) {
                if (void 0 === REVISION) {
                    console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
                    const REVISION = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            REVISION.push(this.data.array[n + t]);
                    }
                    return new BufferAttribute(new this.array.constructor(REVISION), this.itemSize, this.normalized);
                }
                return void 0 === REVISION.interleavedBuffers && (REVISION.interleavedBuffers = {}), void 0 === REVISION.interleavedBuffers[this.data.uuid] && (REVISION.interleavedBuffers[this.data.uuid] = this.data.clone(REVISION)), new InterleavedBufferAttribute(REVISION.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
            }
            toJSON(REVISION) {
                if (void 0 === REVISION) {
                    console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
                    const REVISION = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            REVISION.push(this.data.array[n + t]);
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: REVISION,
                        normalized: this.normalized
                    };
                }
                return void 0 === REVISION.interleavedBuffers && (REVISION.interleavedBuffers = {}), void 0 === REVISION.interleavedBuffers[this.data.uuid] && (REVISION.interleavedBuffers[this.data.uuid] = this.data.toJSON(REVISION)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                };
            }
        }
        const _viewWorldMatrix = new Vector3(), _skinIndex = new Vector4(), _skinWeight = new Vector4(), _vector3 = new Vector3(), _matrix4 = new Matrix4(), _vertex = new Vector3(), _sphere$5 = new Sphere(), _basePosition = new Matrix4(), _ray$2 = new Ray();
        class SkinnedMesh extends Mesh {
            constructor(REVISION, t) {
                super(REVISION, t), this.isSkinnedMesh = !0, this.type = 'SkinnedMesh', this.bindMode = AttachedBindMode, this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4(), this.boundingBox = null, this.boundingSphere = null;
            }
            computeBoundingBox() {
                const REVISION = this.geometry;
                null === this.boundingBox && (this.boundingBox = new Box3()), this.boundingBox.makeEmpty();
                const t = REVISION.getAttribute('position');
                for (let REVISION = 0; REVISION < t.count; REVISION++)
                    this.getVertexPosition(REVISION, _vertex), this.boundingBox.expandByPoint(_vertex);
            }
            computeBoundingSphere() {
                const REVISION = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Sphere()), this.boundingSphere.makeEmpty();
                const t = REVISION.getAttribute('position');
                for (let REVISION = 0; REVISION < t.count; REVISION++)
                    this.getVertexPosition(REVISION, _vertex), this.boundingSphere.expandByPoint(_vertex);
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.bindMode = REVISION.bindMode, this.bindMatrix.copy(REVISION.bindMatrix), this.bindMatrixInverse.copy(REVISION.bindMatrixInverse), this.skeleton = REVISION.skeleton, null !== REVISION.boundingBox && (this.boundingBox = REVISION.boundingBox.clone()), null !== REVISION.boundingSphere && (this.boundingSphere = REVISION.boundingSphere.clone()), this;
            }
            raycast(REVISION, t) {
                const n = this.material, i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), _sphere$5.copy(this.boundingSphere), _sphere$5.applyMatrix4(i), !1 !== REVISION.ray.intersectsSphere(_sphere$5) && (_basePosition.copy(i).invert(), _ray$2.copy(REVISION.ray).applyMatrix4(_basePosition), null !== this.boundingBox && !1 === _ray$2.intersectsBox(this.boundingBox) || this._computeIntersections(REVISION, t, _ray$2)));
            }
            getVertexPosition(REVISION, t) {
                return super.getVertexPosition(REVISION, t), this.applyBoneTransform(REVISION, t), t;
            }
            bind(REVISION, t) {
                this.skeleton = REVISION, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
            }
            pose() {
                this.skeleton.pose();
            }
            normalizeSkinWeights() {
                const REVISION = new Vector4(), t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    REVISION.fromBufferAttribute(t, n);
                    const i = 1 / REVISION.manhattanLength();
                    i !== 1 / 0 ? REVISION.multiplyScalar(i) : REVISION.set(1, 0, 0, 0), t.setXYZW(n, REVISION.x, REVISION.y, REVISION.z, REVISION.w);
                }
            }
            updateMatrixWorld(REVISION) {
                super.updateMatrixWorld(REVISION), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : 'detached' === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
            }
            applyBoneTransform(REVISION, t) {
                const n = this.skeleton, i = this.geometry;
                _skinIndex.fromBufferAttribute(i.attributes.skinIndex, REVISION), _skinWeight.fromBufferAttribute(i.attributes.skinWeight, REVISION), _viewWorldMatrix.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                for (let REVISION = 0; REVISION < 4; REVISION++) {
                    const i = _skinWeight.getComponent(REVISION);
                    if (0 !== i) {
                        const r = _skinIndex.getComponent(REVISION);
                        _matrix4.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(_vector3.copy(_viewWorldMatrix).applyMatrix4(_matrix4), i);
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse);
            }
        }
        class Br extends Object3D {
            constructor() {
                super(), this.isBone = !0, this.type = 'Bone';
            }
        }
        class Dr extends Texture {
            constructor(REVISION = null, t = 1, n = 1, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor = 1003, OneFactor = 1003, SrcColorFactor, OneMinusSrcColorFactor) {
                super(null, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, i, r, SrcColorFactor, OneMinusSrcColorFactor), this.isDataTexture = !0, this.image = {
                    data: REVISION,
                    width: t,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
            }
        }
        const _offsetMatrix = new Matrix4(), _identityMatrix = new Matrix4();
        class Skeleton {
            constructor(REVISION = [], t = []) {
                this.uuid = At(), this.bones = REVISION.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
            }
            init() {
                const REVISION = this.bones, t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * REVISION.length), 0 === t.length)
                    this.calculateInverses();
                else if (REVISION.length !== t.length) {
                    console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'), this.boneInverses = [];
                    for (let REVISION = 0, t = this.bones.length; REVISION < t; REVISION++)
                        this.boneInverses.push(new Matrix4());
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let REVISION = 0, t = this.bones.length; REVISION < t; REVISION++) {
                    const t = new Matrix4();
                    this.bones[REVISION] && t.copy(this.bones[REVISION].matrixWorld).invert(), this.boneInverses.push(t);
                }
            }
            pose() {
                for (let REVISION = 0, t = this.bones.length; REVISION < t; REVISION++) {
                    const t = this.bones[REVISION];
                    t && t.matrixWorld.copy(this.boneInverses[REVISION]).invert();
                }
                for (let REVISION = 0, t = this.bones.length; REVISION < t; REVISION++) {
                    const t = this.bones[REVISION];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
                }
            }
            update() {
                const REVISION = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
                for (let i = 0, r = REVISION.length; i < r; i++) {
                    const r = REVISION[i] ? REVISION[i].matrixWorld : _identityMatrix;
                    _offsetMatrix.multiplyMatrices(r, t[i]), _offsetMatrix.toArray(n, 16 * i);
                }
                null !== i && (i.needsUpdate = !0);
            }
            clone() {
                return new Skeleton(this.bones, this.boneInverses);
            }
            computeBoneTexture() {
                let REVISION = Math.sqrt(4 * this.bones.length);
                REVISION = 4 * Math.ceil(REVISION / 4), REVISION = Math.max(REVISION, 4);
                const t = new Float32Array(REVISION * REVISION * 4);
                t.set(this.boneMatrices);
                const n = new Dr(t, REVISION, REVISION, RGBAFormat, FloatType);
                return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
            }
            getBoneByName(REVISION) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === REVISION)
                        return n;
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
            }
            fromJSON(REVISION, t) {
                this.uuid = REVISION.uuid;
                for (let n = 0, i = REVISION.bones.length; n < i; n++) {
                    const i = REVISION.bones[n];
                    let r = t[i];
                    void 0 === r && (console.warn('THREE.Skeleton: No bone found with UUID:', i), r = new Br()), this.bones.push(r), this.boneInverses.push(new Matrix4().fromArray(REVISION.boneInverses[n]));
                }
                return this.init(), this;
            }
            toJSON() {
                const REVISION = {
                    metadata: {
                        version: 4.6,
                        type: 'Skeleton',
                        generator: 'Skeleton.toJSON'
                    },
                    bones: [],
                    boneInverses: []
                };
                REVISION.uuid = this.uuid;
                const t = this.bones, n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    REVISION.bones.push(r.uuid);
                    const AddEquation = n[i];
                    REVISION.boneInverses.push(AddEquation.toArray());
                }
                return REVISION;
            }
        }
        class kr extends BufferAttribute {
            constructor(REVISION, t, n, i = 1) {
                super(REVISION, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
            }
            copy(REVISION) {
                return super.copy(REVISION), this.meshPerAttribute = REVISION.meshPerAttribute, this;
            }
            toJSON() {
                const REVISION = super.toJSON();
                return REVISION.meshPerAttribute = this.meshPerAttribute, REVISION.isInstancedBufferAttribute = !0, REVISION;
            }
        }
        const _instanceLocalMatrix = new Matrix4(), _instanceWorldMatrix = new Matrix4(), _instanceIntersects = [], _inverseMatrix$2 = new Box3(), _identity = new Matrix4(), _mesh$1 = new Mesh(), _sphere$4 = new Sphere();
        class InstancedMesh extends Mesh {
            constructor(REVISION, t, n) {
                super(REVISION, t), this.isInstancedMesh = !0, this.instanceMatrix = new kr(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                for (let REVISION = 0; REVISION < n; REVISION++)
                    this.setMatrixAt(REVISION, _identity);
            }
            computeBoundingBox() {
                const REVISION = this.geometry, t = this.count;
                null === this.boundingBox && (this.boundingBox = new Box3()), null === REVISION.boundingBox && REVISION.computeBoundingBox(), this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, _instanceLocalMatrix), _inverseMatrix$2.copy(REVISION.boundingBox).applyMatrix4(_instanceLocalMatrix), this.boundingBox.union(_inverseMatrix$2);
            }
            computeBoundingSphere() {
                const REVISION = this.geometry, t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Sphere()), null === REVISION.boundingSphere && REVISION.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, _instanceLocalMatrix), _sphere$4.copy(REVISION.boundingSphere).applyMatrix4(_instanceLocalMatrix), this.boundingSphere.union(_sphere$4);
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.instanceMatrix.copy(REVISION.instanceMatrix), null !== REVISION.morphTexture && (this.morphTexture = REVISION.morphTexture.clone()), null !== REVISION.instanceColor && (this.instanceColor = REVISION.instanceColor.clone()), this.count = REVISION.count, null !== REVISION.boundingBox && (this.boundingBox = REVISION.boundingBox.clone()), null !== REVISION.boundingSphere && (this.boundingSphere = REVISION.boundingSphere.clone()), this;
            }
            getColorAt(REVISION, t) {
                t.fromArray(this.instanceColor.array, 3 * REVISION);
            }
            getMatrixAt(REVISION, t) {
                t.fromArray(this.instanceMatrix.array, 16 * REVISION);
            }
            getMorphAt(REVISION, t) {
                const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, r = REVISION * (n.length + 1) + 1;
                for (let REVISION = 0; REVISION < n.length; REVISION++)
                    n[REVISION] = i[r + REVISION];
            }
            raycast(REVISION, t) {
                const n = this.matrixWorld, i = this.count;
                if (_mesh$1.geometry = this.geometry, _mesh$1.material = this.material, void 0 !== _mesh$1.material && (null === this.boundingSphere && this.computeBoundingSphere(), _sphere$4.copy(this.boundingSphere), _sphere$4.applyMatrix4(n), !1 !== REVISION.ray.intersectsSphere(_sphere$4)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(n, _instanceLocalMatrix), _mesh$1.matrixWorld = _instanceWorldMatrix, _mesh$1.raycast(REVISION, _instanceIntersects);
                        for (let REVISION = 0, n = _instanceIntersects.length; REVISION < n; REVISION++) {
                            const n = _instanceIntersects[REVISION];
                            n.instanceId = r, n.object = this, t.push(n);
                        }
                        _instanceIntersects.length = 0;
                    }
            }
            setColorAt(REVISION, t) {
                null === this.instanceColor && (this.instanceColor = new kr(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * REVISION);
            }
            setMatrixAt(REVISION, t) {
                t.toArray(this.instanceMatrix.array, 16 * REVISION);
            }
            setMorphAt(REVISION, t) {
                const n = t.morphTargetInfluences, i = n.length + 1;
                null === this.morphTexture && (this.morphTexture = new Dr(new Float32Array(i * this.count), i, this.count, RedFormat, FloatType));
                const r = this.morphTexture.source.data.data;
                let AddEquation = 0;
                for (let REVISION = 0; REVISION < n.length; REVISION++)
                    AddEquation += n[REVISION];
                const SubtractEquation = this.geometry.morphTargetsRelative ? 1 : 1 - AddEquation, ReverseSubtractEquation = i * REVISION;
                r[ReverseSubtractEquation] = SubtractEquation, r.set(n, ReverseSubtractEquation + 1);
            }
            updateMorphTargets() {
            }
            dispose() {
                this.dispatchEvent({ type: 'dispose' }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null);
            }
        }
        const _vector1 = new Vector3(), _vector2 = new Vector3(), _normalMatrix = new Matrix3();
        class Plane {
            constructor(REVISION = new Vector3(1, 0, 0), t = 0) {
                this.isPlane = !0, this.normal = REVISION, this.constant = t;
            }
            set(REVISION, t) {
                return this.normal.copy(REVISION), this.constant = t, this;
            }
            setComponents(REVISION, t, n, i) {
                return this.normal.set(REVISION, t, n), this.constant = i, this;
            }
            setFromNormalAndCoplanarPoint(REVISION, t) {
                return this.normal.copy(REVISION), this.constant = -t.dot(this.normal), this;
            }
            setFromCoplanarPoints(REVISION, t, n) {
                const i = _vector1.subVectors(n, t).cross(_vector2.subVectors(REVISION, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, REVISION), this;
            }
            copy(REVISION) {
                return this.normal.copy(REVISION.normal), this.constant = REVISION.constant, this;
            }
            normalize() {
                const REVISION = 1 / this.normal.length();
                return this.normal.multiplyScalar(REVISION), this.constant *= REVISION, this;
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this;
            }
            distanceToPoint(REVISION) {
                return this.normal.dot(REVISION) + this.constant;
            }
            distanceToSphere(REVISION) {
                return this.distanceToPoint(REVISION.center) - REVISION.radius;
            }
            projectPoint(REVISION, t) {
                return t.copy(REVISION).addScaledVector(this.normal, -this.distanceToPoint(REVISION));
            }
            intersectLine(REVISION, t) {
                const n = REVISION.delta(_vector1), i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(REVISION.start) ? t.copy(REVISION.start) : null;
                const r = -(REVISION.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(REVISION.start).addScaledVector(n, r);
            }
            intersectsLine(REVISION) {
                const t = this.distanceToPoint(REVISION.start), n = this.distanceToPoint(REVISION.end);
                return t < 0 && n > 0 || n < 0 && t > 0;
            }
            intersectsBox(REVISION) {
                return REVISION.intersectsPlane(this);
            }
            intersectsSphere(REVISION) {
                return REVISION.intersectsPlane(this);
            }
            coplanarPoint(REVISION) {
                return REVISION.copy(this.normal).multiplyScalar(-this.constant);
            }
            applyMatrix4(REVISION, t) {
                const n = t || _normalMatrix.getNormalMatrix(REVISION), i = this.coplanarPoint(_vector1).applyMatrix4(REVISION), r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this;
            }
            translate(REVISION) {
                return this.constant -= REVISION.dot(this.normal), this;
            }
            equals(REVISION) {
                return REVISION.normal.equals(this.normal) && REVISION.constant === this.constant;
            }
            clone() {
                return new this.constructor().copy(this);
            }
        }
        const _sphere$3 = new Sphere(), _vector$6 = new Vector3();
        class Frustum {
            constructor(REVISION = new Plane(), t = new Plane(), n = new Plane(), i = new Plane(), r = new Plane(), AddEquation = new Plane()) {
                this.planes = [
                    REVISION,
                    t,
                    n,
                    i,
                    r,
                    AddEquation
                ];
            }
            set(REVISION, t, n, i, r, AddEquation) {
                const SubtractEquation = this.planes;
                return SubtractEquation[0].copy(REVISION), SubtractEquation[1].copy(t), SubtractEquation[2].copy(n), SubtractEquation[3].copy(i), SubtractEquation[4].copy(r), SubtractEquation[5].copy(AddEquation), this;
            }
            copy(REVISION) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    t[n].copy(REVISION.planes[n]);
                return this;
            }
            setFromProjectionMatrix(REVISION, t = 2000) {
                const n = this.planes, i = REVISION.elements, r = i[0], AddEquation = i[1], SubtractEquation = i[2], ReverseSubtractEquation = i[3], ZeroFactor = i[4], OneFactor = i[5], SrcColorFactor = i[6], OneMinusSrcColorFactor = i[7], SrcAlphaFactor = i[8], OneMinusSrcAlphaFactor = i[9], DstAlphaFactor = i[10], OneMinusDstAlphaFactor = i[11], DstColorFactor = i[12], OneMinusDstColorFactor = i[13], SrcAlphaSaturateFactor = i[14], ConstantColorFactor = i[15];
                if (n[0].setComponents(ReverseSubtractEquation - r, OneMinusSrcColorFactor - ZeroFactor, OneMinusDstAlphaFactor - SrcAlphaFactor, ConstantColorFactor - DstColorFactor).normalize(), n[1].setComponents(ReverseSubtractEquation + r, OneMinusSrcColorFactor + ZeroFactor, OneMinusDstAlphaFactor + SrcAlphaFactor, ConstantColorFactor + DstColorFactor).normalize(), n[2].setComponents(ReverseSubtractEquation + AddEquation, OneMinusSrcColorFactor + OneFactor, OneMinusDstAlphaFactor + OneMinusSrcAlphaFactor, ConstantColorFactor + OneMinusDstColorFactor).normalize(), n[3].setComponents(ReverseSubtractEquation - AddEquation, OneMinusSrcColorFactor - OneFactor, OneMinusDstAlphaFactor - OneMinusSrcAlphaFactor, ConstantColorFactor - OneMinusDstColorFactor).normalize(), n[4].setComponents(ReverseSubtractEquation - SubtractEquation, OneMinusSrcColorFactor - SrcColorFactor, OneMinusDstAlphaFactor - DstAlphaFactor, ConstantColorFactor - SrcAlphaSaturateFactor).normalize(), t === WebGLCoordinateSystem)
                    n[5].setComponents(ReverseSubtractEquation + SubtractEquation, OneMinusSrcColorFactor + SrcColorFactor, OneMinusDstAlphaFactor + DstAlphaFactor, ConstantColorFactor + SrcAlphaSaturateFactor).normalize();
                else {
                    if (t !== WebGPUCoordinateSystem)
                        throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + t);
                    n[5].setComponents(SubtractEquation, SrcColorFactor, DstAlphaFactor, SrcAlphaSaturateFactor).normalize();
                }
                return this;
            }
            intersectsObject(REVISION) {
                if (void 0 !== REVISION.boundingSphere)
                    null === REVISION.boundingSphere && REVISION.computeBoundingSphere(), _sphere$3.copy(REVISION.boundingSphere).applyMatrix4(REVISION.matrixWorld);
                else {
                    const t = REVISION.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(), _sphere$3.copy(t.boundingSphere).applyMatrix4(REVISION.matrixWorld);
                }
                return this.intersectsSphere(_sphere$3);
            }
            intersectsSprite(REVISION) {
                return _sphere$3.center.set(0, 0, 0), _sphere$3.radius = 0.7071067811865476, _sphere$3.applyMatrix4(REVISION.matrixWorld), this.intersectsSphere(_sphere$3);
            }
            intersectsSphere(REVISION) {
                const t = this.planes, n = REVISION.center, i = -REVISION.radius;
                for (let REVISION = 0; REVISION < 6; REVISION++) {
                    if (t[REVISION].distanceToPoint(n) < i)
                        return !1;
                }
                return !0;
            }
            intersectsBox(REVISION) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (_vector$6.x = i.normal.x > 0 ? REVISION.max.x : REVISION.min.x, _vector$6.y = i.normal.y > 0 ? REVISION.max.y : REVISION.min.y, _vector$6.z = i.normal.z > 0 ? REVISION.max.z : REVISION.min.z, i.distanceToPoint(_vector$6) < 0)
                        return !1;
                }
                return !0;
            }
            containsPoint(REVISION) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(REVISION) < 0)
                        return !1;
                return !0;
            }
            clone() {
                return new this.constructor().copy(this);
            }
        }
        class $r extends Material {
            constructor(REVISION) {
                super(), this.isLineBasicMaterial = !0, this.type = 'LineBasicMaterial', this.color = new Color(16777215), this.map = null, this.linewidth = 1, this.linecap = 'round', this.linejoin = 'round', this.fog = !0, this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.color.copy(REVISION.color), this.map = REVISION.map, this.linewidth = REVISION.linewidth, this.linecap = REVISION.linecap, this.linejoin = REVISION.linejoin, this.fog = REVISION.fog, this;
            }
        }
        const _vStart = new Vector3(), _vEnd = new Vector3(), _box3 = new Matrix4(), _ray$1 = new Ray(), _sphere$1 = new Sphere(), _intersectPointOnRay = new Vector3(), _intersectPointOnSegment = new Vector3();
        class Line extends Object3D {
            constructor(REVISION = new BufferGeometry(), t = new $r()) {
                super(), this.isLine = !0, this.type = 'Line', this.geometry = REVISION, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.material = Array.isArray(REVISION.material) ? REVISION.material.slice() : REVISION.material, this.geometry = REVISION.geometry, this;
            }
            computeLineDistances() {
                const REVISION = this.geometry;
                if (null === REVISION.index) {
                    const t = REVISION.attributes.position, n = [0];
                    for (let REVISION = 1, i = t.count; REVISION < i; REVISION++)
                        _vStart.fromBufferAttribute(t, REVISION - 1), _vEnd.fromBufferAttribute(t, REVISION), n[REVISION] = n[REVISION - 1], n[REVISION] += _vStart.distanceTo(_vEnd);
                    REVISION.setAttribute('lineDistance', new Float32BufferAttribute(n, 1));
                } else
                    console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                return this;
            }
            raycast(REVISION, t) {
                const n = this.geometry, i = this.matrixWorld, r = REVISION.params.Line.threshold, AddEquation = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere$1.copy(n.boundingSphere), _sphere$1.applyMatrix4(i), _sphere$1.radius += r, !1 === REVISION.ray.intersectsSphere(_sphere$1))
                    return;
                _box3.copy(i).invert(), _ray$1.copy(REVISION.ray).applyMatrix4(_box3);
                const SubtractEquation = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), ReverseSubtractEquation = SubtractEquation * SubtractEquation, ZeroFactor = this.isLineSegments ? 2 : 1, OneFactor = n.index, SrcColorFactor = n.attributes.position;
                if (null !== OneFactor) {
                    const n = Math.max(0, AddEquation.start), i = Math.min(OneFactor.count, AddEquation.start + AddEquation.count);
                    for (let r = n, AddEquation = i - 1; r < AddEquation; r += ZeroFactor) {
                        const n = OneFactor.getX(r), i = OneFactor.getX(r + 1), AddEquation = la(this, REVISION, _ray$1, ReverseSubtractEquation, n, i, r);
                        AddEquation && t.push(AddEquation);
                    }
                    if (this.isLineLoop) {
                        const r = OneFactor.getX(i - 1), AddEquation = OneFactor.getX(n), SubtractEquation = la(this, REVISION, _ray$1, ReverseSubtractEquation, r, AddEquation, i - 1);
                        SubtractEquation && t.push(SubtractEquation);
                    }
                } else {
                    const n = Math.max(0, AddEquation.start), i = Math.min(SrcColorFactor.count, AddEquation.start + AddEquation.count);
                    for (let r = n, AddEquation = i - 1; r < AddEquation; r += ZeroFactor) {
                        const n = la(this, REVISION, _ray$1, ReverseSubtractEquation, r, r + 1, r);
                        n && t.push(n);
                    }
                    if (this.isLineLoop) {
                        const r = la(this, REVISION, _ray$1, ReverseSubtractEquation, i - 1, n, i - 1);
                        r && t.push(r);
                    }
                }
            }
            updateMorphTargets() {
                const REVISION = this.geometry.morphAttributes, t = Object.keys(REVISION);
                if (t.length > 0) {
                    const n = REVISION[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let REVISION = 0, t = n.length; REVISION < t; REVISION++) {
                            const t = n[REVISION].name || String(REVISION);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = REVISION;
                        }
                    }
                }
            }
        }
        function la(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
            const ReverseSubtractEquation = REVISION.geometry.attributes.position;
            _vStart.fromBufferAttribute(ReverseSubtractEquation, r), _vEnd.fromBufferAttribute(ReverseSubtractEquation, AddEquation);
            if (n.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment) > i)
                return;
            _intersectPointOnRay.applyMatrix4(REVISION.matrixWorld);
            const ZeroFactor = t.ray.origin.distanceTo(_intersectPointOnRay);
            return ZeroFactor < t.near || ZeroFactor > t.far ? void 0 : {
                distance: ZeroFactor,
                point: _intersectPointOnSegment.clone().applyMatrix4(REVISION.matrixWorld),
                index: SubtractEquation,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: REVISION
            };
        }
        const _start = new Vector3(), _end = new Vector3();
        class LineSegments extends Line {
            constructor(REVISION, t) {
                super(REVISION, t), this.isLineSegments = !0, this.type = 'LineSegments';
            }
            computeLineDistances() {
                const REVISION = this.geometry;
                if (null === REVISION.index) {
                    const t = REVISION.attributes.position, n = [];
                    for (let REVISION = 0, i = t.count; REVISION < i; REVISION += 2)
                        _start.fromBufferAttribute(t, REVISION), _end.fromBufferAttribute(t, REVISION + 1), n[REVISION] = 0 === REVISION ? 0 : n[REVISION - 1], n[REVISION + 1] = n[REVISION] + _start.distanceTo(_end);
                    REVISION.setAttribute('lineDistance', new Float32BufferAttribute(n, 1));
                } else
                    console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                return this;
            }
        }
        class ua extends Line {
            constructor(REVISION, t) {
                super(REVISION, t), this.isLineLoop = !0, this.type = 'LineLoop';
            }
        }
        class fa extends Material {
            constructor(REVISION) {
                super(), this.isPointsMaterial = !0, this.type = 'PointsMaterial', this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.color.copy(REVISION.color), this.map = REVISION.map, this.alphaMap = REVISION.alphaMap, this.size = REVISION.size, this.sizeAttenuation = REVISION.sizeAttenuation, this.fog = REVISION.fog, this;
            }
        }
        const _inverseMatrix$1 = new Matrix4(), _ray = new Ray(), _sphere = new Sphere(), _position$2 = new Vector3();
        class Points extends Object3D {
            constructor(REVISION = new BufferGeometry(), t = new fa()) {
                super(), this.isPoints = !0, this.type = 'Points', this.geometry = REVISION, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.material = Array.isArray(REVISION.material) ? REVISION.material.slice() : REVISION.material, this.geometry = REVISION.geometry, this;
            }
            raycast(REVISION, t) {
                const n = this.geometry, i = this.matrixWorld, r = REVISION.params.Points.threshold, AddEquation = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere.copy(n.boundingSphere), _sphere.applyMatrix4(i), _sphere.radius += r, !1 === REVISION.ray.intersectsSphere(_sphere))
                    return;
                _inverseMatrix$1.copy(i).invert(), _ray.copy(REVISION.ray).applyMatrix4(_inverseMatrix$1);
                const SubtractEquation = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), ReverseSubtractEquation = SubtractEquation * SubtractEquation, ZeroFactor = n.index, OneFactor = n.attributes.position;
                if (null !== ZeroFactor) {
                    for (let n = Math.max(0, AddEquation.start), r = Math.min(ZeroFactor.count, AddEquation.start + AddEquation.count); n < r; n++) {
                        const r = ZeroFactor.getX(n);
                        _position$2.fromBufferAttribute(OneFactor, r), va(_position$2, r, ReverseSubtractEquation, i, REVISION, t, this);
                    }
                } else {
                    for (let n = Math.max(0, AddEquation.start), r = Math.min(OneFactor.count, AddEquation.start + AddEquation.count); n < r; n++)
                        _position$2.fromBufferAttribute(OneFactor, n), va(_position$2, n, ReverseSubtractEquation, i, REVISION, t, this);
                }
            }
            updateMorphTargets() {
                const REVISION = this.geometry.morphAttributes, t = Object.keys(REVISION);
                if (t.length > 0) {
                    const n = REVISION[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let REVISION = 0, t = n.length; REVISION < t; REVISION++) {
                            const t = n[REVISION].name || String(REVISION);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = REVISION;
                        }
                    }
                }
            }
        }
        function va(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
            const ReverseSubtractEquation = _ray.distanceSqToPoint(REVISION);
            if (ReverseSubtractEquation < n) {
                const n = new Vector3();
                _ray.closestPointToPoint(REVISION, n), n.applyMatrix4(i);
                const ZeroFactor = r.ray.origin.distanceTo(n);
                if (ZeroFactor < r.near || ZeroFactor > r.far)
                    return;
                AddEquation.push({
                    distance: ZeroFactor,
                    distanceToRay: Math.sqrt(ReverseSubtractEquation),
                    point: n,
                    index: t,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: SubtractEquation
                });
            }
        }
        class InstancedBufferGeometry extends Texture {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor = 1026) {
                if (OneFactor !== DepthFormat && OneFactor !== DepthStencilFormat)
                    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
                void 0 === n && OneFactor === DepthFormat && (n = UnsignedIntType), void 0 === n && OneFactor === DepthStencilFormat && (n = UnsignedInt248Type), super(null, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, OneFactor, n, ZeroFactor), this.isDepthTexture = !0, this.image = {
                    width: REVISION,
                    height: t
                }, this.magFilter = void 0 !== SubtractEquation ? SubtractEquation : NearestFilter, this.minFilter = void 0 !== ReverseSubtractEquation ? ReverseSubtractEquation : NearestFilter, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
            }
            copy(REVISION) {
                return super.copy(REVISION), this.source = new Source(Object.assign({}, REVISION.image)), this.compareFunction = REVISION.compareFunction, this;
            }
            toJSON(REVISION) {
                const t = super.toJSON(REVISION);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t;
            }
        }
        class TorusKnotGeometry extends BufferGeometry {
            constructor(REVISION = 1, t = 1, n = 1, i = 1) {
                super(), this.type = 'PlaneGeometry', this.parameters = {
                    width: REVISION,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = REVISION / 2, AddEquation = t / 2, SubtractEquation = Math.floor(n), ReverseSubtractEquation = Math.floor(i), ZeroFactor = SubtractEquation + 1, OneFactor = ReverseSubtractEquation + 1, SrcColorFactor = REVISION / SubtractEquation, OneMinusSrcColorFactor = t / ReverseSubtractEquation, SrcAlphaFactor = [], OneMinusSrcAlphaFactor = [], DstAlphaFactor = [], OneMinusDstAlphaFactor = [];
                for (let REVISION = 0; REVISION < OneFactor; REVISION++) {
                    const t = REVISION * OneMinusSrcColorFactor - AddEquation;
                    for (let n = 0; n < ZeroFactor; n++) {
                        const i = n * SrcColorFactor - r;
                        OneMinusSrcAlphaFactor.push(i, -t, 0), DstAlphaFactor.push(0, 0, 1), OneMinusDstAlphaFactor.push(n / SubtractEquation), OneMinusDstAlphaFactor.push(1 - REVISION / ReverseSubtractEquation);
                    }
                }
                for (let REVISION = 0; REVISION < ReverseSubtractEquation; REVISION++)
                    for (let t = 0; t < SubtractEquation; t++) {
                        const n = t + ZeroFactor * REVISION, i = t + ZeroFactor * (REVISION + 1), r = t + 1 + ZeroFactor * (REVISION + 1), AddEquation = t + 1 + ZeroFactor * REVISION;
                        SrcAlphaFactor.push(n, i, AddEquation), SrcAlphaFactor.push(i, r, AddEquation);
                    }
                this.setIndex(SrcAlphaFactor), this.setAttribute('position', new Float32BufferAttribute(OneMinusSrcAlphaFactor, 3)), this.setAttribute('normal', new Float32BufferAttribute(DstAlphaFactor, 3)), this.setAttribute('uv', new Float32BufferAttribute(OneMinusDstAlphaFactor, 2));
            }
            copy(REVISION) {
                return super.copy(REVISION), this.parameters = Object.assign({}, REVISION.parameters), this;
            }
            static fromJSON(REVISION) {
                return new TorusKnotGeometry(REVISION.width, REVISION.height, REVISION.widthSegments, REVISION.heightSegments);
            }
        }
        class xa extends Material {
            constructor(REVISION) {
                super(), this.isMeshStandardMaterial = !0, this.type = 'MeshStandardMaterial', this.defines = { STANDARD: '' }, this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.flatShading = !1, this.fog = !0, this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.defines = { STANDARD: '' }, this.color.copy(REVISION.color), this.roughness = REVISION.roughness, this.metalness = REVISION.metalness, this.map = REVISION.map, this.lightMap = REVISION.lightMap, this.lightMapIntensity = REVISION.lightMapIntensity, this.aoMap = REVISION.aoMap, this.aoMapIntensity = REVISION.aoMapIntensity, this.emissive.copy(REVISION.emissive), this.emissiveMap = REVISION.emissiveMap, this.emissiveIntensity = REVISION.emissiveIntensity, this.bumpMap = REVISION.bumpMap, this.bumpScale = REVISION.bumpScale, this.normalMap = REVISION.normalMap, this.normalMapType = REVISION.normalMapType, this.normalScale.copy(REVISION.normalScale), this.displacementMap = REVISION.displacementMap, this.displacementScale = REVISION.displacementScale, this.displacementBias = REVISION.displacementBias, this.roughnessMap = REVISION.roughnessMap, this.metalnessMap = REVISION.metalnessMap, this.alphaMap = REVISION.alphaMap, this.envMap = REVISION.envMap, this.envMapRotation.copy(REVISION.envMapRotation), this.envMapIntensity = REVISION.envMapIntensity, this.wireframe = REVISION.wireframe, this.wireframeLinewidth = REVISION.wireframeLinewidth, this.wireframeLinecap = REVISION.wireframeLinecap, this.wireframeLinejoin = REVISION.wireframeLinejoin, this.flatShading = REVISION.flatShading, this.fog = REVISION.fog, this;
            }
        }
        class MeshPhysicalMaterial extends xa {
            constructor(REVISION) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: '',
                    PHYSICAL: ''
                }, this.type = 'MeshPhysicalMaterial', this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, 'reflectivity', {
                    get: function () {
                        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
                    },
                    set: function (REVISION) {
                        this.ior = (1 + 0.4 * REVISION) / (1 - 0.4 * REVISION);
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
                    100,
                    400
                ], this.iridescenceThicknessMap = null, this.sheenColor = new Color(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(REVISION);
            }
            get anisotropy() {
                return this._anisotropy;
            }
            set anisotropy(REVISION) {
                this._anisotropy > 0 != REVISION > 0 && this.version++, this._anisotropy = REVISION;
            }
            get clearcoat() {
                return this._clearcoat;
            }
            set clearcoat(REVISION) {
                this._clearcoat > 0 != REVISION > 0 && this.version++, this._clearcoat = REVISION;
            }
            get iridescence() {
                return this._iridescence;
            }
            set iridescence(REVISION) {
                this._iridescence > 0 != REVISION > 0 && this.version++, this._iridescence = REVISION;
            }
            get dispersion() {
                return this._dispersion;
            }
            set dispersion(REVISION) {
                this._dispersion > 0 != REVISION > 0 && this.version++, this._dispersion = REVISION;
            }
            get sheen() {
                return this._sheen;
            }
            set sheen(REVISION) {
                this._sheen > 0 != REVISION > 0 && this.version++, this._sheen = REVISION;
            }
            get transmission() {
                return this._transmission;
            }
            set transmission(REVISION) {
                this._transmission > 0 != REVISION > 0 && this.version++, this._transmission = REVISION;
            }
            copy(REVISION) {
                return super.copy(REVISION), this.defines = {
                    STANDARD: '',
                    PHYSICAL: ''
                }, this.anisotropy = REVISION.anisotropy, this.anisotropyRotation = REVISION.anisotropyRotation, this.anisotropyMap = REVISION.anisotropyMap, this.clearcoat = REVISION.clearcoat, this.clearcoatMap = REVISION.clearcoatMap, this.clearcoatRoughness = REVISION.clearcoatRoughness, this.clearcoatRoughnessMap = REVISION.clearcoatRoughnessMap, this.clearcoatNormalMap = REVISION.clearcoatNormalMap, this.clearcoatNormalScale.copy(REVISION.clearcoatNormalScale), this.dispersion = REVISION.dispersion, this.ior = REVISION.ior, this.iridescence = REVISION.iridescence, this.iridescenceMap = REVISION.iridescenceMap, this.iridescenceIOR = REVISION.iridescenceIOR, this.iridescenceThicknessRange = [...REVISION.iridescenceThicknessRange], this.iridescenceThicknessMap = REVISION.iridescenceThicknessMap, this.sheen = REVISION.sheen, this.sheenColor.copy(REVISION.sheenColor), this.sheenColorMap = REVISION.sheenColorMap, this.sheenRoughness = REVISION.sheenRoughness, this.sheenRoughnessMap = REVISION.sheenRoughnessMap, this.transmission = REVISION.transmission, this.transmissionMap = REVISION.transmissionMap, this.thickness = REVISION.thickness, this.thicknessMap = REVISION.thicknessMap, this.attenuationDistance = REVISION.attenuationDistance, this.attenuationColor.copy(REVISION.attenuationColor), this.specularIntensity = REVISION.specularIntensity, this.specularIntensityMap = REVISION.specularIntensityMap, this.specularColor.copy(REVISION.specularColor), this.specularColorMap = REVISION.specularColorMap, this;
            }
        }
        class Sa extends Material {
            constructor(REVISION) {
                super(), this.isMeshDepthMaterial = !0, this.type = 'MeshDepthMaterial', this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.depthPacking = REVISION.depthPacking, this.map = REVISION.map, this.alphaMap = REVISION.alphaMap, this.displacementMap = REVISION.displacementMap, this.displacementScale = REVISION.displacementScale, this.displacementBias = REVISION.displacementBias, this.wireframe = REVISION.wireframe, this.wireframeLinewidth = REVISION.wireframeLinewidth, this;
            }
        }
        class Ea extends Material {
            constructor(REVISION) {
                super(), this.isMeshDistanceMaterial = !0, this.type = 'MeshDistanceMaterial', this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.map = REVISION.map, this.alphaMap = REVISION.alphaMap, this.displacementMap = REVISION.displacementMap, this.displacementScale = REVISION.displacementScale, this.displacementBias = REVISION.displacementBias, this;
            }
        }
        function Ma(REVISION, t, n) {
            return !REVISION || !n && REVISION.constructor === t ? REVISION : 'number' == typeof t.BYTES_PER_ELEMENT ? new t(REVISION) : Array.prototype.slice.call(REVISION);
        }
        function isTypedArray(REVISION) {
            return ArrayBuffer.isView(REVISION) && !(REVISION instanceof DataView);
        }
        function Ca(REVISION) {
            const t = REVISION.length, n = new Array(t);
            for (let REVISION = 0; REVISION !== t; ++REVISION)
                n[REVISION] = REVISION;
            return n.sort(function (t, n) {
                return REVISION[t] - REVISION[n];
            }), n;
        }
        function Ia(REVISION, t, n) {
            const i = REVISION.length, r = new REVISION.constructor(i);
            for (let AddEquation = 0, SubtractEquation = 0; SubtractEquation !== i; ++AddEquation) {
                const i = n[AddEquation] * t;
                for (let n = 0; n !== t; ++n)
                    r[SubtractEquation++] = REVISION[i + n];
            }
            return r;
        }
        function Ra(REVISION, t, n, i) {
            let r = 1, AddEquation = REVISION[0];
            for (; void 0 !== AddEquation && void 0 === AddEquation[i];)
                AddEquation = REVISION[r++];
            if (void 0 === AddEquation)
                return;
            let SubtractEquation = AddEquation[i];
            if (void 0 !== SubtractEquation)
                if (Array.isArray(SubtractEquation))
                    do {
                        SubtractEquation = AddEquation[i], void 0 !== SubtractEquation && (t.push(AddEquation.time), n.push(...SubtractEquation)), AddEquation = REVISION[r++];
                    } while (void 0 !== AddEquation);
                else if (void 0 !== SubtractEquation.toArray)
                    do {
                        SubtractEquation = AddEquation[i], void 0 !== SubtractEquation && (t.push(AddEquation.time), SubtractEquation.toArray(n, n.length)), AddEquation = REVISION[r++];
                    } while (void 0 !== AddEquation);
                else
                    do {
                        SubtractEquation = AddEquation[i], void 0 !== SubtractEquation && (t.push(AddEquation.time), n.push(SubtractEquation)), AddEquation = REVISION[r++];
                    } while (void 0 !== AddEquation);
        }
        class Interpolant {
            constructor(REVISION, t, n, i) {
                this.parameterPositions = REVISION, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
            }
            evaluate(REVISION) {
                const t = this.parameterPositions;
                let n = this._cachedIndex, i = t[n], r = t[n - 1];
                REVISION: {
                    t: {
                        let AddEquation;
                        n: {
                            i:
                                if (!(REVISION < i)) {
                                    for (let AddEquation = n + 2;;) {
                                        if (void 0 === i) {
                                            if (REVISION < r)
                                                break i;
                                            return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                                        }
                                        if (n === AddEquation)
                                            break;
                                        if (r = i, i = t[++n], REVISION < i)
                                            break t;
                                    }
                                    AddEquation = t.length;
                                    break n;
                                }
                            if (REVISION >= r)
                                break REVISION;
                            {
                                const SubtractEquation = t[1];
                                REVISION < SubtractEquation && (n = 2, r = SubtractEquation);
                                for (let AddEquation = n - 2;;) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === AddEquation)
                                        break;
                                    if (i = r, r = t[--n - 1], REVISION >= r)
                                        break t;
                                }
                                AddEquation = n, n = 0;
                            }
                        }
                        for (; n < AddEquation;) {
                            const i = n + AddEquation >>> 1;
                            REVISION < t[i] ? AddEquation = i : n = i + 1;
                        }
                        if (i = t[n], r = t[n - 1], void 0 === r)
                            return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (void 0 === i)
                            return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                    }
                    this._cachedIndex = n, this.intervalChanged_(n, r, i);
                }
                return this.interpolate_(n, r, REVISION, i);
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_;
            }
            copySampleValue_(REVISION) {
                const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = REVISION * i;
                for (let REVISION = 0; REVISION !== i; ++REVISION)
                    t[REVISION] = n[r + REVISION];
                return t;
            }
            interpolate_() {
                throw new Error('call to abstract method');
            }
            intervalChanged_() {
            }
        }
        class CubicInterpolant extends Interpolant {
            constructor(REVISION, t, n, i) {
                super(REVISION, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: ZeroCurvatureEnding,
                    endingEnd: ZeroCurvatureEnding
                };
            }
            intervalChanged_(REVISION, t, n) {
                const i = this.parameterPositions;
                let r = REVISION - 2, AddEquation = REVISION + 1, SubtractEquation = i[r], ReverseSubtractEquation = i[AddEquation];
                if (void 0 === SubtractEquation)
                    switch (this.getSettings_().endingStart) {
                    case ZeroSlopeEnding:
                        r = REVISION, SubtractEquation = 2 * t - n;
                        break;
                    case WrapAroundEnding:
                        r = i.length - 2, SubtractEquation = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = REVISION, SubtractEquation = n;
                    }
                if (void 0 === ReverseSubtractEquation)
                    switch (this.getSettings_().endingEnd) {
                    case ZeroSlopeEnding:
                        AddEquation = REVISION, ReverseSubtractEquation = 2 * n - t;
                        break;
                    case WrapAroundEnding:
                        AddEquation = 1, ReverseSubtractEquation = n + i[1] - i[0];
                        break;
                    default:
                        AddEquation = REVISION - 1, ReverseSubtractEquation = t;
                    }
                const ZeroFactor = 0.5 * (n - t), OneFactor = this.valueSize;
                this._weightPrev = ZeroFactor / (t - SubtractEquation), this._weightNext = ZeroFactor / (ReverseSubtractEquation - n), this._offsetPrev = r * OneFactor, this._offsetNext = AddEquation * OneFactor;
            }
            interpolate_(REVISION, t, n, i) {
                const r = this.resultBuffer, AddEquation = this.sampleValues, SubtractEquation = this.valueSize, ReverseSubtractEquation = REVISION * SubtractEquation, ZeroFactor = ReverseSubtractEquation - SubtractEquation, OneFactor = this._offsetPrev, SrcColorFactor = this._offsetNext, OneMinusSrcColorFactor = this._weightPrev, SrcAlphaFactor = this._weightNext, OneMinusSrcAlphaFactor = (n - t) / (i - t), DstAlphaFactor = OneMinusSrcAlphaFactor * OneMinusSrcAlphaFactor, OneMinusDstAlphaFactor = DstAlphaFactor * OneMinusSrcAlphaFactor, DstColorFactor = -OneMinusSrcColorFactor * OneMinusDstAlphaFactor + 2 * OneMinusSrcColorFactor * DstAlphaFactor - OneMinusSrcColorFactor * OneMinusSrcAlphaFactor, OneMinusDstColorFactor = (1 + OneMinusSrcColorFactor) * OneMinusDstAlphaFactor + (-1.5 - 2 * OneMinusSrcColorFactor) * DstAlphaFactor + (-0.5 + OneMinusSrcColorFactor) * OneMinusSrcAlphaFactor + 1, SrcAlphaSaturateFactor = (-1 - SrcAlphaFactor) * OneMinusDstAlphaFactor + (1.5 + SrcAlphaFactor) * DstAlphaFactor + 0.5 * OneMinusSrcAlphaFactor, ConstantColorFactor = SrcAlphaFactor * OneMinusDstAlphaFactor - SrcAlphaFactor * DstAlphaFactor;
                for (let REVISION = 0; REVISION !== SubtractEquation; ++REVISION)
                    r[REVISION] = DstColorFactor * AddEquation[OneFactor + REVISION] + OneMinusDstColorFactor * AddEquation[ZeroFactor + REVISION] + SrcAlphaSaturateFactor * AddEquation[ReverseSubtractEquation + REVISION] + ConstantColorFactor * AddEquation[SrcColorFactor + REVISION];
                return r;
            }
        }
        class Da extends Interpolant {
            constructor(REVISION, t, n, i) {
                super(REVISION, t, n, i);
            }
            interpolate_(REVISION, t, n, i) {
                const r = this.resultBuffer, AddEquation = this.sampleValues, SubtractEquation = this.valueSize, ReverseSubtractEquation = REVISION * SubtractEquation, ZeroFactor = ReverseSubtractEquation - SubtractEquation, OneFactor = (n - t) / (i - t), SrcColorFactor = 1 - OneFactor;
                for (let REVISION = 0; REVISION !== SubtractEquation; ++REVISION)
                    r[REVISION] = AddEquation[ZeroFactor + REVISION] * SrcColorFactor + AddEquation[ReverseSubtractEquation + REVISION] * OneFactor;
                return r;
            }
        }
        class DiscreteInterpolant extends Interpolant {
            constructor(REVISION, t, n, i) {
                super(REVISION, t, n, i);
            }
            interpolate_(REVISION) {
                return this.copySampleValue_(REVISION - 1);
            }
        }
        class KeyframeTrack {
            constructor(REVISION, t, n, i) {
                if (void 0 === REVISION)
                    throw new Error('THREE.KeyframeTrack: track name is undefined');
                if (void 0 === t || 0 === t.length)
                    throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + REVISION);
                this.name = REVISION, this.times = Ma(t, this.TimeBufferType), this.values = Ma(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
            }
            static toJSON(REVISION) {
                const t = REVISION.constructor;
                let n;
                if (t.toJSON !== this.toJSON)
                    n = t.toJSON(REVISION);
                else {
                    n = {
                        name: REVISION.name,
                        times: Ma(REVISION.times, Array),
                        values: Ma(REVISION.values, Array)
                    };
                    const t = REVISION.getInterpolation();
                    t !== REVISION.DefaultInterpolation && (n.interpolation = t);
                }
                return n.type = REVISION.ValueTypeName, n;
            }
            InterpolantFactoryMethodDiscrete(REVISION) {
                return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), REVISION);
            }
            InterpolantFactoryMethodLinear(REVISION) {
                return new Da(this.times, this.values, this.getValueSize(), REVISION);
            }
            InterpolantFactoryMethodSmooth(REVISION) {
                return new CubicInterpolant(this.times, this.values, this.getValueSize(), REVISION);
            }
            setInterpolation(REVISION) {
                let t;
                switch (REVISION) {
                case InterpolateDiscrete:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case InterpolateLinear:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case InterpolateSmooth:
                    t = this.InterpolantFactoryMethodSmooth;
                }
                if (void 0 === t) {
                    const t = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (REVISION === this.DefaultInterpolation)
                            throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation);
                    }
                    return console.warn('THREE.KeyframeTrack:', t), this;
                }
                return this.createInterpolant = t, this;
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return InterpolateSmooth;
                }
            }
            getValueSize() {
                return this.values.length / this.times.length;
            }
            shift(REVISION) {
                if (0 !== REVISION) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] += REVISION;
                }
                return this;
            }
            scale(REVISION) {
                if (1 !== REVISION) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] *= REVISION;
                }
                return this;
            }
            trim(REVISION, t) {
                const n = this.times, i = n.length;
                let r = 0, AddEquation = i - 1;
                for (; r !== i && n[r] < REVISION;)
                    ++r;
                for (; -1 !== AddEquation && n[AddEquation] > t;)
                    --AddEquation;
                if (++AddEquation, 0 !== r || AddEquation !== i) {
                    r >= AddEquation && (AddEquation = Math.max(AddEquation, 1), r = AddEquation - 1);
                    const REVISION = this.getValueSize();
                    this.times = n.slice(r, AddEquation), this.values = this.values.slice(r * REVISION, AddEquation * REVISION);
                }
                return this;
            }
            validate() {
                let REVISION = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), REVISION = !1);
                const n = this.times, i = this.values, r = n.length;
                0 === r && (console.error('THREE.KeyframeTrack: Track is empty.', this), REVISION = !1);
                let AddEquation = null;
                for (let t = 0; t !== r; t++) {
                    const i = n[t];
                    if ('number' == typeof i && isNaN(i)) {
                        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, t, i), REVISION = !1;
                        break;
                    }
                    if (null !== AddEquation && AddEquation > i) {
                        console.error('THREE.KeyframeTrack: Out of order keys.', this, t, i, AddEquation), REVISION = !1;
                        break;
                    }
                    AddEquation = i;
                }
                if (void 0 !== i && isTypedArray(i))
                    for (let t = 0, n = i.length; t !== n; ++t) {
                        const n = i[t];
                        if (isNaN(n)) {
                            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, t, n), REVISION = !1;
                            break;
                        }
                    }
                return REVISION;
            }
            optimize() {
                const REVISION = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === InterpolateSmooth, r = REVISION.length - 1;
                let AddEquation = 1;
                for (let SubtractEquation = 1; SubtractEquation < r; ++SubtractEquation) {
                    let r = !1;
                    const ReverseSubtractEquation = REVISION[SubtractEquation];
                    if (ReverseSubtractEquation !== REVISION[SubtractEquation + 1] && (1 !== SubtractEquation || ReverseSubtractEquation !== REVISION[0]))
                        if (i)
                            r = !0;
                        else {
                            const REVISION = SubtractEquation * n, i = REVISION - n, AddEquation = REVISION + n;
                            for (let SubtractEquation = 0; SubtractEquation !== n; ++SubtractEquation) {
                                const n = t[REVISION + SubtractEquation];
                                if (n !== t[i + SubtractEquation] || n !== t[AddEquation + SubtractEquation]) {
                                    r = !0;
                                    break;
                                }
                            }
                        }
                    if (r) {
                        if (SubtractEquation !== AddEquation) {
                            REVISION[AddEquation] = REVISION[SubtractEquation];
                            const i = SubtractEquation * n, r = AddEquation * n;
                            for (let REVISION = 0; REVISION !== n; ++REVISION)
                                t[r + REVISION] = t[i + REVISION];
                        }
                        ++AddEquation;
                    }
                }
                if (r > 0) {
                    REVISION[AddEquation] = REVISION[r];
                    for (let REVISION = r * n, i = AddEquation * n, SubtractEquation = 0; SubtractEquation !== n; ++SubtractEquation)
                        t[i + SubtractEquation] = t[REVISION + SubtractEquation];
                    ++AddEquation;
                }
                return AddEquation !== REVISION.length ? (this.times = REVISION.slice(0, AddEquation), this.values = t.slice(0, AddEquation * n)) : (this.times = REVISION, this.values = t), this;
            }
            clone() {
                const REVISION = this.times.slice(), t = this.values.slice(), n = new (0, this.constructor)(this.name, REVISION, t);
                return n.createInterpolant = this.createInterpolant, n;
            }
        }
        KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
        class BooleanKeyframeTrack extends KeyframeTrack {
            constructor(REVISION, t, n) {
                super(REVISION, t, n);
            }
        }
        BooleanKeyframeTrack.prototype.ValueTypeName = 'bool', BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
        class ColorKeyframeTrack extends KeyframeTrack {
        }
        ColorKeyframeTrack.prototype.ValueTypeName = 'color';
        class Fa extends KeyframeTrack {
        }
        Fa.prototype.ValueTypeName = 'number';
        class QuaternionLinearInterpolant extends Interpolant {
            constructor(REVISION, t, n, i) {
                super(REVISION, t, n, i);
            }
            interpolate_(REVISION, t, n, i) {
                const r = this.resultBuffer, AddEquation = this.sampleValues, SubtractEquation = this.valueSize, ReverseSubtractEquation = (n - t) / (i - t);
                let ZeroFactor = REVISION * SubtractEquation;
                for (let REVISION = ZeroFactor + SubtractEquation; ZeroFactor !== REVISION; ZeroFactor += 4)
                    Quaternion.slerpFlat(r, 0, AddEquation, ZeroFactor - SubtractEquation, AddEquation, ZeroFactor, ReverseSubtractEquation);
                return r;
            }
        }
        class QuaternionKeyframeTrack extends KeyframeTrack {
            InterpolantFactoryMethodLinear(REVISION) {
                return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), REVISION);
            }
        }
        QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion', QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
        class StringKeyframeTrack extends KeyframeTrack {
            constructor(REVISION, t, n) {
                super(REVISION, t, n);
            }
        }
        StringKeyframeTrack.prototype.ValueTypeName = 'string', StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
        class VectorKeyframeTrack extends KeyframeTrack {
        }
        VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
        class AnimationClip {
            constructor(REVISION = '', t = -1, n = [], i = 2500) {
                this.name = REVISION, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = At(), this.duration < 0 && this.resetDuration();
            }
            static parse(REVISION) {
                const t = [], n = REVISION.tracks, i = 1 / (REVISION.fps || 1);
                for (let REVISION = 0, r = n.length; REVISION !== r; ++REVISION)
                    t.push(Ga(n[REVISION]).scale(i));
                const r = new this(REVISION.name, REVISION.duration, t, REVISION.blendMode);
                return r.uuid = REVISION.uuid, r;
            }
            static toJSON(REVISION) {
                const t = [], n = REVISION.tracks, i = {
                        name: REVISION.name,
                        duration: REVISION.duration,
                        tracks: t,
                        uuid: REVISION.uuid,
                        blendMode: REVISION.blendMode
                    };
                for (let REVISION = 0, i = n.length; REVISION !== i; ++REVISION)
                    t.push(KeyframeTrack.toJSON(n[REVISION]));
                return i;
            }
            static CreateFromMorphTargetSequence(REVISION, t, n, i) {
                const r = t.length, AddEquation = [];
                for (let REVISION = 0; REVISION < r; REVISION++) {
                    let SubtractEquation = [], ReverseSubtractEquation = [];
                    SubtractEquation.push((REVISION + r - 1) % r, REVISION, (REVISION + 1) % r), ReverseSubtractEquation.push(0, 1, 0);
                    const ZeroFactor = Ca(SubtractEquation);
                    SubtractEquation = Ia(SubtractEquation, 1, ZeroFactor), ReverseSubtractEquation = Ia(ReverseSubtractEquation, 1, ZeroFactor), i || 0 !== SubtractEquation[0] || (SubtractEquation.push(r), ReverseSubtractEquation.push(ReverseSubtractEquation[0])), AddEquation.push(new Fa('.morphTargetInfluences[' + t[REVISION].name + ']', SubtractEquation, ReverseSubtractEquation).scale(1 / n));
                }
                return new this(REVISION, -1, AddEquation);
            }
            static findByName(REVISION, t) {
                let n = REVISION;
                if (!Array.isArray(REVISION)) {
                    const t = REVISION;
                    n = t.geometry && t.geometry.animations || t.animations;
                }
                for (let REVISION = 0; REVISION < n.length; REVISION++)
                    if (n[REVISION].name === t)
                        return n[REVISION];
                return null;
            }
            static CreateClipsFromMorphTargetSequences(REVISION, t, n) {
                const i = {}, r = /^([\w-]*?)([\d]+)$/;
                for (let t = 0, n = REVISION.length; t < n; t++) {
                    const n = REVISION[t], AddEquation = n.name.match(r);
                    if (AddEquation && AddEquation.length > 1) {
                        const REVISION = AddEquation[1];
                        let t = i[REVISION];
                        t || (i[REVISION] = t = []), t.push(n);
                    }
                }
                const AddEquation = [];
                for (const REVISION in i)
                    AddEquation.push(this.CreateFromMorphTargetSequence(REVISION, i[REVISION], t, n));
                return AddEquation;
            }
            static parseAnimation(REVISION, t) {
                if (!REVISION)
                    return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null;
                const n = function (REVISION, t, n, i, r) {
                        if (0 !== n.length) {
                            const AddEquation = [], SubtractEquation = [];
                            Ra(n, AddEquation, SubtractEquation, i), 0 !== AddEquation.length && r.push(new REVISION(t, AddEquation, SubtractEquation));
                        }
                    }, i = [], r = REVISION.name || 'default', AddEquation = REVISION.fps || 30, SubtractEquation = REVISION.blendMode;
                let ReverseSubtractEquation = REVISION.length || -1;
                const ZeroFactor = REVISION.hierarchy || [];
                for (let REVISION = 0; REVISION < ZeroFactor.length; REVISION++) {
                    const r = ZeroFactor[REVISION].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const REVISION = {};
                            let t;
                            for (t = 0; t < r.length; t++)
                                if (r[t].morphTargets)
                                    for (let n = 0; n < r[t].morphTargets.length; n++)
                                        REVISION[r[t].morphTargets[n]] = -1;
                            for (const n in REVISION) {
                                const REVISION = [], AddEquation = [];
                                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                    const i = r[t];
                                    REVISION.push(i.time), AddEquation.push(i.morphTarget === n ? 1 : 0);
                                }
                                i.push(new Fa('.morphTargetInfluence[' + n + ']', REVISION, AddEquation));
                            }
                            ReverseSubtractEquation = REVISION.length * AddEquation;
                        } else {
                            const AddEquation = '.bones[' + t[REVISION].name + ']';
                            n(VectorKeyframeTrack, AddEquation + '.position', r, 'pos', i), n(QuaternionKeyframeTrack, AddEquation + '.quaternion', r, 'rot', i), n(VectorKeyframeTrack, AddEquation + '.scale', r, 'scl', i);
                        }
                }
                if (0 === i.length)
                    return null;
                return new this(r, ReverseSubtractEquation, i, SubtractEquation);
            }
            resetDuration() {
                let REVISION = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    REVISION = Math.max(REVISION, n.times[n.times.length - 1]);
                }
                return this.duration = REVISION, this;
            }
            trim() {
                for (let REVISION = 0; REVISION < this.tracks.length; REVISION++)
                    this.tracks[REVISION].trim(0, this.duration);
                return this;
            }
            validate() {
                let REVISION = !0;
                for (let t = 0; t < this.tracks.length; t++)
                    REVISION = REVISION && this.tracks[t].validate();
                return REVISION;
            }
            optimize() {
                for (let REVISION = 0; REVISION < this.tracks.length; REVISION++)
                    this.tracks[REVISION].optimize();
                return this;
            }
            clone() {
                const REVISION = [];
                for (let t = 0; t < this.tracks.length; t++)
                    REVISION.push(this.tracks[t].clone());
                return new this.constructor(this.name, this.duration, REVISION, this.blendMode);
            }
            toJSON() {
                return this.constructor.toJSON(this);
            }
        }
        function Ga(REVISION) {
            if (void 0 === REVISION.type)
                throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
            const t = function (REVISION) {
                switch (REVISION.toLowerCase()) {
                case 'scalar':
                case 'double':
                case 'float':
                case 'number':
                case 'integer':
                    return Fa;
                case 'vector':
                case 'vector2':
                case 'vector3':
                case 'vector4':
                    return VectorKeyframeTrack;
                case 'color':
                    return ColorKeyframeTrack;
                case 'quaternion':
                    return QuaternionKeyframeTrack;
                case 'bool':
                case 'boolean':
                    return BooleanKeyframeTrack;
                case 'string':
                    return StringKeyframeTrack;
                }
                throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + REVISION);
            }(REVISION.type);
            if (void 0 === REVISION.times) {
                const t = [], n = [];
                Ra(REVISION.keys, t, n, 'value'), REVISION.times = t, REVISION.values = n;
            }
            return void 0 !== t.parse ? t.parse(REVISION) : new t(REVISION.name, REVISION.times, REVISION.values, REVISION.interpolation);
        }
        const Qa = {
            enabled: !1,
            files: {},
            add: function (REVISION, t) {
                !1 !== this.enabled && (this.files[REVISION] = t);
            },
            get: function (REVISION) {
                if (!1 !== this.enabled)
                    return this.files[REVISION];
            },
            remove: function (REVISION) {
                delete this.files[REVISION];
            },
            clear: function () {
                this.files = {};
            }
        };
        class Xa {
            constructor(REVISION, t, n) {
                const i = this;
                let r, AddEquation = !1, SubtractEquation = 0, ReverseSubtractEquation = 0;
                const ZeroFactor = [];
                this.onStart = void 0, this.onLoad = REVISION, this.onProgress = t, this.onError = n, this.itemStart = function (REVISION) {
                    ReverseSubtractEquation++, !1 === AddEquation && void 0 !== i.onStart && i.onStart(REVISION, SubtractEquation, ReverseSubtractEquation), AddEquation = !0;
                }, this.itemEnd = function (REVISION) {
                    SubtractEquation++, void 0 !== i.onProgress && i.onProgress(REVISION, SubtractEquation, ReverseSubtractEquation), SubtractEquation === ReverseSubtractEquation && (AddEquation = !1, void 0 !== i.onLoad && i.onLoad());
                }, this.itemError = function (REVISION) {
                    void 0 !== i.onError && i.onError(REVISION);
                }, this.resolveURL = function (REVISION) {
                    return r ? r(REVISION) : REVISION;
                }, this.setURLModifier = function (REVISION) {
                    return r = REVISION, this;
                }, this.addHandler = function (REVISION, t) {
                    return ZeroFactor.push(REVISION, t), this;
                }, this.removeHandler = function (REVISION) {
                    const t = ZeroFactor.indexOf(REVISION);
                    return -1 !== t && ZeroFactor.splice(t, 2), this;
                }, this.getHandler = function (REVISION) {
                    for (let t = 0, n = ZeroFactor.length; t < n; t += 2) {
                        const n = ZeroFactor[t], i = ZeroFactor[t + 1];
                        if (n.global && (n.lastIndex = 0), n.test(REVISION))
                            return i;
                    }
                    return null;
                };
            }
        }
        const DefaultLoadingManager = new Xa();
        class Loader {
            constructor(REVISION) {
                this.manager = void 0 !== REVISION ? REVISION : DefaultLoadingManager, this.crossOrigin = 'anonymous', this.withCredentials = !1, this.path = '', this.resourcePath = '', this.requestHeader = {};
            }
            load() {
            }
            loadAsync(REVISION, t) {
                const n = this;
                return new Promise(function (i, r) {
                    n.load(REVISION, i, t, r);
                });
            }
            parse() {
            }
            setCrossOrigin(REVISION) {
                return this.crossOrigin = REVISION, this;
            }
            setWithCredentials(REVISION) {
                return this.withCredentials = REVISION, this;
            }
            setPath(REVISION) {
                return this.path = REVISION, this;
            }
            setResourcePath(REVISION) {
                return this.resourcePath = REVISION, this;
            }
            setRequestHeader(REVISION) {
                return this.requestHeader = REVISION, this;
            }
        }
        Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
        const loading = {};
        class Ka extends Error {
            constructor(REVISION, t) {
                super(REVISION), this.response = t;
            }
        }
        class FileLoader extends Loader {
            constructor(REVISION) {
                super(REVISION);
            }
            load(REVISION, t, n, i) {
                void 0 === REVISION && (REVISION = ''), void 0 !== this.path && (REVISION = this.path + REVISION), REVISION = this.manager.resolveURL(REVISION);
                const r = Qa.get(REVISION);
                if (void 0 !== r)
                    return this.manager.itemStart(REVISION), setTimeout(() => {
                        t && t(r), this.manager.itemEnd(REVISION);
                    }, 0), r;
                if (void 0 !== loading[REVISION])
                    return void loading[REVISION].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                loading[REVISION] = [], loading[REVISION].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                const AddEquation = new Request(REVISION, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? 'include' : 'same-origin'
                    }), SubtractEquation = this.mimeType, ReverseSubtractEquation = this.responseType;
                fetch(AddEquation).then(t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn('THREE.FileLoader: HTTP Status 0 received.'), 'undefined' == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                            return t;
                        const n = loading[REVISION], i = t.body.getReader(), r = t.headers.get('X-File-Size') || t.headers.get('Content-Length'), AddEquation = r ? parseInt(r) : 0, SubtractEquation = 0 !== AddEquation;
                        let ReverseSubtractEquation = 0;
                        const ZeroFactor = new ReadableStream({
                            start(REVISION) {
                                !function t() {
                                    i.read().then(({
                                        done: i,
                                        value: r
                                    }) => {
                                        if (i)
                                            REVISION.close();
                                        else {
                                            ReverseSubtractEquation += r.byteLength;
                                            const i = new ProgressEvent('progress', {
                                                lengthComputable: SubtractEquation,
                                                loaded: ReverseSubtractEquation,
                                                total: AddEquation
                                            });
                                            for (let REVISION = 0, t = n.length; REVISION < t; REVISION++) {
                                                const t = n[REVISION];
                                                t.onProgress && t.onProgress(i);
                                            }
                                            REVISION.enqueue(r), t();
                                        }
                                    }, t => {
                                        REVISION.error(t);
                                    });
                                }();
                            }
                        });
                        return new Response(ZeroFactor);
                    }
                    throw new Ka(`fetch for "${ t.url }" responded with ${ t.status }: ${ t.statusText }`, t);
                }).then(REVISION => {
                    switch (ReverseSubtractEquation) {
                    case 'arraybuffer':
                        return REVISION.arrayBuffer();
                    case 'blob':
                        return REVISION.blob();
                    case 'document':
                        return REVISION.text().then(REVISION => new DOMParser().parseFromString(REVISION, SubtractEquation));
                    case 'json':
                        return REVISION.json();
                    default:
                        if (void 0 === SubtractEquation)
                            return REVISION.text();
                        {
                            const t = /charset="?([^;"\s]*)"?/i.exec(SubtractEquation), n = t && t[1] ? t[1].toLowerCase() : void 0, i = new TextDecoder(n);
                            return REVISION.arrayBuffer().then(REVISION => i.decode(REVISION));
                        }
                    }
                }).then(t => {
                    Qa.add(REVISION, t);
                    const n = loading[REVISION];
                    delete loading[REVISION];
                    for (let REVISION = 0, i = n.length; REVISION < i; REVISION++) {
                        const i = n[REVISION];
                        i.onLoad && i.onLoad(t);
                    }
                }).catch(t => {
                    const n = loading[REVISION];
                    if (void 0 === n)
                        throw this.manager.itemError(REVISION), t;
                    delete loading[REVISION];
                    for (let REVISION = 0, i = n.length; REVISION < i; REVISION++) {
                        const i = n[REVISION];
                        i.onError && i.onError(t);
                    }
                    this.manager.itemError(REVISION);
                }).finally(() => {
                    this.manager.itemEnd(REVISION);
                }), this.manager.itemStart(REVISION);
            }
            setResponseType(REVISION) {
                return this.responseType = REVISION, this;
            }
            setMimeType(REVISION) {
                return this.mimeType = REVISION, this;
            }
        }
        class Ja extends Loader {
            constructor(REVISION) {
                super(REVISION);
            }
            load(REVISION, t, n, i) {
                void 0 !== this.path && (REVISION = this.path + REVISION), REVISION = this.manager.resolveURL(REVISION);
                const r = this, AddEquation = Qa.get(REVISION);
                if (void 0 !== AddEquation)
                    return r.manager.itemStart(REVISION), setTimeout(function () {
                        t && t(AddEquation), r.manager.itemEnd(REVISION);
                    }, 0), AddEquation;
                const SubtractEquation = createElementNS('img');
                function ReverseSubtractEquation() {
                    OneFactor(), Qa.add(REVISION, this), t && t(this), r.manager.itemEnd(REVISION);
                }
                function ZeroFactor(t) {
                    OneFactor(), i && i(t), r.manager.itemError(REVISION), r.manager.itemEnd(REVISION);
                }
                function OneFactor() {
                    SubtractEquation.removeEventListener('load', ReverseSubtractEquation, !1), SubtractEquation.removeEventListener('error', ZeroFactor, !1);
                }
                return SubtractEquation.addEventListener('load', ReverseSubtractEquation, !1), SubtractEquation.addEventListener('error', ZeroFactor, !1), 'data:' !== REVISION.slice(0, 5) && void 0 !== this.crossOrigin && (SubtractEquation.crossOrigin = this.crossOrigin), r.manager.itemStart(REVISION), SubtractEquation.src = REVISION, SubtractEquation;
            }
        }
        class AudioLoader extends Loader {
            constructor(REVISION) {
                super(REVISION);
            }
            load(REVISION, t, n, i) {
                const r = new Texture(), AddEquation = new Ja(this.manager);
                return AddEquation.setCrossOrigin(this.crossOrigin), AddEquation.setPath(this.path), AddEquation.load(REVISION, function (REVISION) {
                    r.image = REVISION, r.needsUpdate = !0, void 0 !== t && t(r);
                }, n, i), r;
            }
        }
        class Light extends Object3D {
            constructor(REVISION, t = 1) {
                super(), this.isLight = !0, this.type = 'Light', this.color = new Color(REVISION), this.intensity = t;
            }
            dispose() {
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.color.copy(REVISION.color), this.intensity = REVISION.intensity, this;
            }
            toJSON(REVISION) {
                const t = super.toJSON(REVISION);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t;
            }
        }
        class HemisphereLight extends Light {
            constructor(REVISION, t, n) {
                super(REVISION, n), this.isHemisphereLight = !0, this.type = 'HemisphereLight', this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Color(t);
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.groundColor.copy(REVISION.groundColor), this;
            }
        }
        const _projScreenMatrix$1 = new Matrix4(), _v2$1 = new Vector3(), _lightPositionWorld$1 = new Vector3();
        class LightShadow {
            constructor(REVISION) {
                this.camera = REVISION, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)];
            }
            getViewportCount() {
                return this._viewportCount;
            }
            getFrustum() {
                return this._frustum;
            }
            updateMatrices(REVISION) {
                const t = this.camera, n = this.matrix;
                _v2$1.setFromMatrixPosition(REVISION.matrixWorld), t.position.copy(_v2$1), _lightPositionWorld$1.setFromMatrixPosition(REVISION.target.matrixWorld), t.lookAt(_lightPositionWorld$1), t.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(_projScreenMatrix$1);
            }
            getViewport(REVISION) {
                return this._viewports[REVISION];
            }
            getFrameExtents() {
                return this._frameExtents;
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
            }
            copy(REVISION) {
                return this.camera = REVISION.camera.clone(), this.intensity = REVISION.intensity, this.bias = REVISION.bias, this.radius = REVISION.radius, this.mapSize.copy(REVISION.mapSize), this;
            }
            clone() {
                return new this.constructor().copy(this);
            }
            toJSON() {
                const REVISION = {};
                return 1 !== this.intensity && (REVISION.intensity = this.intensity), 0 !== this.bias && (REVISION.bias = this.bias), 0 !== this.normalBias && (REVISION.normalBias = this.normalBias), 1 !== this.radius && (REVISION.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (REVISION.mapSize = this.mapSize.toArray()), REVISION.camera = this.camera.toJSON(!1).object, delete REVISION.camera.matrix, REVISION;
            }
        }
        class SpotLightShadow extends LightShadow {
            constructor() {
                super(new PerspectiveCamera(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
            }
            updateMatrices(REVISION) {
                const t = this.camera, n = 2 * RAD2DEG * REVISION.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = REVISION.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(REVISION);
            }
            copy(REVISION) {
                return super.copy(REVISION), this.focus = REVISION.focus, this;
            }
        }
        class os extends Light {
            constructor(REVISION, t, n = 0, i = Math.PI / 3, r = 0, AddEquation = 2) {
                super(REVISION, t), this.isSpotLight = !0, this.type = 'SpotLight', this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = AddEquation, this.map = null, this.shadow = new SpotLightShadow();
            }
            get power() {
                return this.intensity * Math.PI;
            }
            set power(REVISION) {
                this.intensity = REVISION / Math.PI;
            }
            dispose() {
                this.shadow.dispose();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.distance = REVISION.distance, this.angle = REVISION.angle, this.penumbra = REVISION.penumbra, this.decay = REVISION.decay, this.target = REVISION.target.clone(), this.shadow = REVISION.shadow.clone(), this;
            }
        }
        const _projScreenMatrix = new Matrix4(), _lightPositionWorld = new Vector3(), _lookTarget = new Vector3();
        class PointLightShadow extends LightShadow {
            constructor() {
                super(new PerspectiveCamera(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [
                    new Vector4(2, 1, 1, 1),
                    new Vector4(0, 1, 1, 1),
                    new Vector4(3, 1, 1, 1),
                    new Vector4(1, 1, 1, 1),
                    new Vector4(3, 0, 1, 1),
                    new Vector4(1, 0, 1, 1)
                ], this._cubeDirections = [
                    new Vector3(1, 0, 0),
                    new Vector3(-1, 0, 0),
                    new Vector3(0, 0, 1),
                    new Vector3(0, 0, -1),
                    new Vector3(0, 1, 0),
                    new Vector3(0, -1, 0)
                ], this._cubeUps = [
                    new Vector3(0, 1, 0),
                    new Vector3(0, 1, 0),
                    new Vector3(0, 1, 0),
                    new Vector3(0, 1, 0),
                    new Vector3(0, 0, 1),
                    new Vector3(0, 0, -1)
                ];
            }
            updateMatrices(REVISION, t = 0) {
                const n = this.camera, i = this.matrix, r = REVISION.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(REVISION.matrixWorld), n.position.copy(_lightPositionWorld), _lookTarget.copy(n.position), _lookTarget.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(_lookTarget), n.updateMatrixWorld(), i.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix);
            }
        }
        class PointLight extends Light {
            constructor(REVISION, t, n = 0, i = 2) {
                super(REVISION, t), this.isPointLight = !0, this.type = 'PointLight', this.distance = n, this.decay = i, this.shadow = new PointLightShadow();
            }
            get power() {
                return 4 * this.intensity * Math.PI;
            }
            set power(REVISION) {
                this.intensity = REVISION / (4 * Math.PI);
            }
            dispose() {
                this.shadow.dispose();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.distance = REVISION.distance, this.decay = REVISION.decay, this.shadow = REVISION.shadow.clone(), this;
            }
        }
        class OrthographicCamera extends Camera {
            constructor(REVISION = -1, t = 1, n = 1, i = -1, r = 0.1, AddEquation = 2000) {
                super(), this.isOrthographicCamera = !0, this.type = 'OrthographicCamera', this.zoom = 1, this.view = null, this.left = REVISION, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = AddEquation, this.updateProjectionMatrix();
            }
            copy(REVISION, t) {
                return super.copy(REVISION, t), this.left = REVISION.left, this.right = REVISION.right, this.top = REVISION.top, this.bottom = REVISION.bottom, this.near = REVISION.near, this.far = REVISION.far, this.zoom = REVISION.zoom, this.view = null === REVISION.view ? null : Object.assign({}, REVISION.view), this;
            }
            setViewOffset(REVISION, t, n, i, r, AddEquation) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = REVISION, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = AddEquation, this.updateProjectionMatrix();
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
            }
            updateProjectionMatrix() {
                const REVISION = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
                let r = n - REVISION, AddEquation = n + REVISION, SubtractEquation = i + t, ReverseSubtractEquation = i - t;
                if (null !== this.view && this.view.enabled) {
                    const REVISION = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += REVISION * this.view.offsetX, AddEquation = r + REVISION * this.view.width, SubtractEquation -= t * this.view.offsetY, ReverseSubtractEquation = SubtractEquation - t * this.view.height;
                }
                this.projectionMatrix.makeOrthographic(r, AddEquation, SubtractEquation, ReverseSubtractEquation, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
            toJSON(REVISION) {
                const t = super.toJSON(REVISION);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t;
            }
        }
        class ps extends LightShadow {
            constructor() {
                super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
            }
        }
        class DirectionalLight extends Light {
            constructor(REVISION, t) {
                super(REVISION, t), this.isDirectionalLight = !0, this.type = 'DirectionalLight', this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D(), this.shadow = new ps();
            }
            dispose() {
                this.shadow.dispose();
            }
            copy(REVISION) {
                return super.copy(REVISION), this.target = REVISION.target.clone(), this.shadow = REVISION.shadow.clone(), this;
            }
        }
        class LoaderUtils {
            static decodeText(REVISION) {
                if (console.warn('THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.'), 'undefined' != typeof TextDecoder)
                    return new TextDecoder().decode(REVISION);
                let t = '';
                for (let n = 0, i = REVISION.length; n < i; n++)
                    t += String.fromCharCode(REVISION[n]);
                try {
                    return decodeURIComponent(escape(t));
                } catch (REVISION) {
                    return t;
                }
            }
            static extractUrlBase(REVISION) {
                const t = REVISION.lastIndexOf('/');
                return -1 === t ? './' : REVISION.slice(0, t + 1);
            }
            static resolveURL(REVISION, t) {
                return 'string' != typeof REVISION || '' === REVISION ? '' : (/^https?:\/\//i.test(t) && /^\//.test(REVISION) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')), /^(https?:)?\/\//i.test(REVISION) || /^data:.*,.*$/i.test(REVISION) || /^blob:.*$/i.test(REVISION) ? REVISION : t + REVISION);
            }
        }
        class ImageBitmapLoader extends Loader {
            constructor(REVISION) {
                super(REVISION), this.isImageBitmapLoader = !0, 'undefined' == typeof createImageBitmap && console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'), 'undefined' == typeof fetch && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'), this.options = { premultiplyAlpha: 'none' };
            }
            setOptions(REVISION) {
                return this.options = REVISION, this;
            }
            load(REVISION, t, n, i) {
                void 0 === REVISION && (REVISION = ''), void 0 !== this.path && (REVISION = this.path + REVISION), REVISION = this.manager.resolveURL(REVISION);
                const r = this, AddEquation = Qa.get(REVISION);
                if (void 0 !== AddEquation)
                    return r.manager.itemStart(REVISION), AddEquation.then ? void AddEquation.then(n => {
                        t && t(n), r.manager.itemEnd(REVISION);
                    }).catch(REVISION => {
                        i && i(REVISION);
                    }) : (setTimeout(function () {
                        t && t(AddEquation), r.manager.itemEnd(REVISION);
                    }, 0), AddEquation);
                const SubtractEquation = {};
                SubtractEquation.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include', SubtractEquation.headers = this.requestHeader;
                const ReverseSubtractEquation = fetch(REVISION, SubtractEquation).then(function (REVISION) {
                    return REVISION.blob();
                }).then(function (REVISION) {
                    return createImageBitmap(REVISION, Object.assign(r.options, { colorSpaceConversion: 'none' }));
                }).then(function (n) {
                    return Qa.add(REVISION, n), t && t(n), r.manager.itemEnd(REVISION), n;
                }).catch(function (t) {
                    i && i(t), Qa.remove(REVISION), r.manager.itemError(REVISION), r.manager.itemEnd(REVISION);
                });
                Qa.add(REVISION, ReverseSubtractEquation), r.manager.itemStart(REVISION);
            }
        }
        class _s extends PerspectiveCamera {
            constructor(REVISION = []) {
                super(), this.isArrayCamera = !0, this.cameras = REVISION, this.index = 0;
            }
        }
        const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/', _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'), _wordChar = '[^' + _RESERVED_CHARS_RE + ']', _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']', bs = new RegExp('^' + /((?:WC+[\/:])*)/.source.replace('WC', _wordChar) + /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar) + /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar) + '$'), _supportedObjectNames = [
                'material',
                'materials',
                'bones',
                'map'
            ];
        class PropertyBinding {
            constructor(REVISION, t, n) {
                this.path = t, this.parsedPath = n || PropertyBinding.parseTrackName(t), this.node = PropertyBinding.findNode(REVISION, this.parsedPath.nodeName), this.rootNode = REVISION, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
            }
            static create(REVISION, t, n) {
                return REVISION && REVISION.isAnimationObjectGroup ? new PropertyBinding.Composite(REVISION, t, n) : new PropertyBinding(REVISION, t, n);
            }
            static sanitizeNodeName(REVISION) {
                return REVISION.replace(/\s/g, '_').replace(_reservedRe, '');
            }
            static parseTrackName(REVISION) {
                const t = bs.exec(REVISION);
                if (null === t)
                    throw new Error('PropertyBinding: Cannot parse trackName: ' + REVISION);
                const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    }, i = n.nodeName && n.nodeName.lastIndexOf('.');
                if (void 0 !== i && -1 !== i) {
                    const REVISION = n.nodeName.substring(i + 1);
                    -1 !== _supportedObjectNames.indexOf(REVISION) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = REVISION);
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + REVISION);
                return n;
            }
            static findNode(REVISION, t) {
                if (void 0 === t || '' === t || '.' === t || -1 === t || t === REVISION.name || t === REVISION.uuid)
                    return REVISION;
                if (REVISION.skeleton) {
                    const n = REVISION.skeleton.getBoneByName(t);
                    if (void 0 !== n)
                        return n;
                }
                if (REVISION.children) {
                    const n = function (REVISION) {
                            for (let i = 0; i < REVISION.length; i++) {
                                const r = REVISION[i];
                                if (r.name === t || r.uuid === t)
                                    return r;
                                const AddEquation = n(r.children);
                                if (AddEquation)
                                    return AddEquation;
                            }
                            return null;
                        }, i = n(REVISION.children);
                    if (i)
                        return i;
                }
                return null;
            }
            _getValue_unavailable() {
            }
            _setValue_unavailable() {
            }
            _getValue_direct(REVISION, t) {
                REVISION[t] = this.targetObject[this.propertyName];
            }
            _getValue_array(REVISION, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    REVISION[t++] = n[i];
            }
            _getValue_arrayElement(REVISION, t) {
                REVISION[t] = this.resolvedProperty[this.propertyIndex];
            }
            _getValue_toArray(REVISION, t) {
                this.resolvedProperty.toArray(REVISION, t);
            }
            _setValue_direct(REVISION, t) {
                this.targetObject[this.propertyName] = REVISION[t];
            }
            _setValue_direct_setNeedsUpdate(REVISION, t) {
                this.targetObject[this.propertyName] = REVISION[t], this.targetObject.needsUpdate = !0;
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(REVISION, t) {
                this.targetObject[this.propertyName] = REVISION[t], this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _setValue_array(REVISION, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = REVISION[t++];
            }
            _setValue_array_setNeedsUpdate(REVISION, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = REVISION[t++];
                this.targetObject.needsUpdate = !0;
            }
            _setValue_array_setMatrixWorldNeedsUpdate(REVISION, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = REVISION[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _setValue_arrayElement(REVISION, t) {
                this.resolvedProperty[this.propertyIndex] = REVISION[t];
            }
            _setValue_arrayElement_setNeedsUpdate(REVISION, t) {
                this.resolvedProperty[this.propertyIndex] = REVISION[t], this.targetObject.needsUpdate = !0;
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(REVISION, t) {
                this.resolvedProperty[this.propertyIndex] = REVISION[t], this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _setValue_fromArray(REVISION, t) {
                this.resolvedProperty.fromArray(REVISION, t);
            }
            _setValue_fromArray_setNeedsUpdate(REVISION, t) {
                this.resolvedProperty.fromArray(REVISION, t), this.targetObject.needsUpdate = !0;
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(REVISION, t) {
                this.resolvedProperty.fromArray(REVISION, t), this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _getValue_unbound(REVISION, t) {
                this.bind(), this.getValue(REVISION, t);
            }
            _setValue_unbound(REVISION, t) {
                this.bind(), this.setValue(REVISION, t);
            }
            bind() {
                let REVISION = this.node;
                const t = this.parsedPath, n = t.objectName, i = t.propertyName;
                let r = t.propertyIndex;
                if (REVISION || (REVISION = PropertyBinding.findNode(this.rootNode, t.nodeName), this.node = REVISION), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !REVISION)
                    return void console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
                if (n) {
                    let i = t.objectIndex;
                    switch (n) {
                    case 'materials':
                        if (!REVISION.material)
                            return void console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        if (!REVISION.material.materials)
                            return void console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        REVISION = REVISION.material.materials;
                        break;
                    case 'bones':
                        if (!REVISION.skeleton)
                            return void console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        REVISION = REVISION.skeleton.bones;
                        for (let t = 0; t < REVISION.length; t++)
                            if (REVISION[t].name === i) {
                                i = t;
                                break;
                            }
                        break;
                    case 'map':
                        if ('map' in REVISION) {
                            REVISION = REVISION.map;
                            break;
                        }
                        if (!REVISION.material)
                            return void console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        if (!REVISION.material.map)
                            return void console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
                        REVISION = REVISION.material.map;
                        break;
                    default:
                        if (void 0 === REVISION[n])
                            return void console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        REVISION = REVISION[n];
                    }
                    if (void 0 !== i) {
                        if (void 0 === REVISION[i])
                            return void console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, REVISION);
                        REVISION = REVISION[i];
                    }
                }
                const AddEquation = REVISION[i];
                if (void 0 === AddEquation) {
                    const n = t.nodeName;
                    return void console.error('THREE.PropertyBinding: Trying to update property for track: ' + n + '.' + i + ' but it wasn\'t found.', REVISION);
                }
                let SubtractEquation = this.Versioning.None;
                this.targetObject = REVISION, !0 === REVISION.isMaterial ? SubtractEquation = this.Versioning.NeedsUpdate : !0 === REVISION.isObject3D && (SubtractEquation = this.Versioning.MatrixWorldNeedsUpdate);
                let ReverseSubtractEquation = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ('morphTargetInfluences' === i) {
                        if (!REVISION.geometry)
                            return void console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                        if (!REVISION.geometry.morphAttributes)
                            return void console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        void 0 !== REVISION.morphTargetDictionary[r] && (r = REVISION.morphTargetDictionary[r]);
                    }
                    ReverseSubtractEquation = this.BindingType.ArrayElement, this.resolvedProperty = AddEquation, this.propertyIndex = r;
                } else
                    void 0 !== AddEquation.fromArray && void 0 !== AddEquation.toArray ? (ReverseSubtractEquation = this.BindingType.HasFromToArray, this.resolvedProperty = AddEquation) : Array.isArray(AddEquation) ? (ReverseSubtractEquation = this.BindingType.EntireArray, this.resolvedProperty = AddEquation) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[ReverseSubtractEquation], this.setValue = this.SetterByBindingTypeAndVersioning[ReverseSubtractEquation][SubtractEquation];
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
            }
        }
        PropertyBinding.Composite = class {
            constructor(REVISION, t, n) {
                const i = n || PropertyBinding.parseTrackName(t);
                this._targetGroup = REVISION, this._bindings = REVISION.subscribe_(t, i);
            }
            getValue(REVISION, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
                void 0 !== i && i.getValue(REVISION, t);
            }
            setValue(REVISION, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(REVISION, t);
            }
            bind() {
                const REVISION = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = REVISION.length; t !== n; ++t)
                    REVISION[t].bind();
            }
            unbind() {
                const REVISION = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = REVISION.length; t !== n; ++t)
                    REVISION[t].unbind();
            }
        }, PropertyBinding.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, PropertyBinding.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, PropertyBinding.prototype.GetterByBindingType = [
            PropertyBinding.prototype._getValue_direct,
            PropertyBinding.prototype._getValue_array,
            PropertyBinding.prototype._getValue_arrayElement,
            PropertyBinding.prototype._getValue_toArray
        ], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
            [
                PropertyBinding.prototype._setValue_direct,
                PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
                PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
            ],
            [
                PropertyBinding.prototype._setValue_array,
                PropertyBinding.prototype._setValue_array_setNeedsUpdate,
                PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
            ],
            [
                PropertyBinding.prototype._setValue_arrayElement,
                PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
                PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
            ],
            [
                PropertyBinding.prototype._setValue_fromArray,
                PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
                PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
            ]
        ];
        new Float32Array(1);
        function Ms(REVISION, t, n, i) {
            const r = function (REVISION) {
                switch (REVISION) {
                case UnsignedByteType:
                case ByteType:
                    return {
                        byteLength: 1,
                        components: 1
                    };
                case UnsignedShortType:
                case ShortType:
                case HalfFloatType:
                    return {
                        byteLength: 2,
                        components: 1
                    };
                case UnsignedShort4444Type:
                case UnsignedShort5551Type:
                    return {
                        byteLength: 2,
                        components: 4
                    };
                case UnsignedIntType:
                case IntType:
                case FloatType:
                    return {
                        byteLength: 4,
                        components: 1
                    };
                case UnsignedInt5999Type:
                    return {
                        byteLength: 4,
                        components: 3
                    };
                }
                throw new Error(`Unknown texture type ${ REVISION }.`);
            }(i);
            switch (n) {
            case 1021:
            case 1024:
                return REVISION * t;
            case 1025:
                return REVISION * t * 2;
            case RedFormat:
            case RedIntegerFormat:
                return REVISION * t / r.components * r.byteLength;
            case 1030:
            case RGIntegerFormat:
                return REVISION * t * 2 / r.components * r.byteLength;
            case 1022:
                return REVISION * t * 3 / r.components * r.byteLength;
            case RGBAFormat:
            case RGBAIntegerFormat:
                return REVISION * t * 4 / r.components * r.byteLength;
            case RGB_S3TC_DXT1_Format:
            case RGBA_S3TC_DXT1_Format:
                return Math.floor((REVISION + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case RGBA_S3TC_DXT3_Format:
            case RGBA_S3TC_DXT5_Format:
                return Math.floor((REVISION + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case RGB_PVRTC_2BPPV1_Format:
            case RGBA_PVRTC_2BPPV1_Format:
                return Math.max(REVISION, 16) * Math.max(t, 8) / 4;
            case RGB_PVRTC_4BPPV1_Format:
            case RGBA_PVRTC_4BPPV1_Format:
                return Math.max(REVISION, 8) * Math.max(t, 8) / 2;
            case RGB_ETC1_Format:
            case RGB_ETC2_Format:
                return Math.floor((REVISION + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case RGBA_ETC2_EAC_Format:
            case RGBA_ASTC_4x4_Format:
                return Math.floor((REVISION + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case RGBA_ASTC_5x4_Format:
                return Math.floor((REVISION + 4) / 5) * Math.floor((t + 3) / 4) * 16;
            case RGBA_ASTC_5x5_Format:
                return Math.floor((REVISION + 4) / 5) * Math.floor((t + 4) / 5) * 16;
            case RGBA_ASTC_6x5_Format:
                return Math.floor((REVISION + 5) / 6) * Math.floor((t + 4) / 5) * 16;
            case RGBA_ASTC_6x6_Format:
                return Math.floor((REVISION + 5) / 6) * Math.floor((t + 5) / 6) * 16;
            case RGBA_ASTC_8x5_Format:
                return Math.floor((REVISION + 7) / 8) * Math.floor((t + 4) / 5) * 16;
            case RGBA_ASTC_8x6_Format:
                return Math.floor((REVISION + 7) / 8) * Math.floor((t + 5) / 6) * 16;
            case RGBA_ASTC_8x8_Format:
                return Math.floor((REVISION + 7) / 8) * Math.floor((t + 7) / 8) * 16;
            case RGBA_ASTC_10x5_Format:
                return Math.floor((REVISION + 9) / 10) * Math.floor((t + 4) / 5) * 16;
            case RGBA_ASTC_10x6_Format:
                return Math.floor((REVISION + 9) / 10) * Math.floor((t + 5) / 6) * 16;
            case RGBA_ASTC_10x8_Format:
                return Math.floor((REVISION + 9) / 10) * Math.floor((t + 7) / 8) * 16;
            case RGBA_ASTC_10x10_Format:
                return Math.floor((REVISION + 9) / 10) * Math.floor((t + 9) / 10) * 16;
            case RGBA_ASTC_12x10_Format:
                return Math.floor((REVISION + 11) / 12) * Math.floor((t + 9) / 10) * 16;
            case RGBA_ASTC_12x12_Format:
                return Math.floor((REVISION + 11) / 12) * Math.floor((t + 11) / 12) * 16;
            case RGBA_BPTC_Format:
            case RGB_BPTC_SIGNED_Format:
            case RGB_BPTC_UNSIGNED_Format:
                return Math.ceil(REVISION / 4) * Math.ceil(t / 4) * 16;
            case 36283:
            case SIGNED_RED_RGTC1_Format:
                return Math.ceil(REVISION / 4) * Math.ceil(t / 4) * 8;
            case RED_GREEN_RGTC2_Format:
            case SIGNED_RED_GREEN_RGTC2_Format:
                return Math.ceil(REVISION / 4) * Math.ceil(t / 4) * 16;
            }
            throw new Error(`Unable to determine texture byte length for ${ n } format.`);
        }
        'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: REVISION } })), 'undefined' != typeof window && (window.__THREE__ ? console.warn('WARNING: Multiple instances of Three.js being imported.') : window.__THREE__ = REVISION);
        const Ts = {
                c: null,
                u: [
                    new Vector3(),
                    new Vector3(),
                    new Vector3()
                ],
                e: []
            }, Cs = {
                c: null,
                u: [
                    new Vector3(),
                    new Vector3(),
                    new Vector3()
                ],
                e: []
            }, Is = [
                [],
                [],
                []
            ], Rs = [
                [],
                [],
                []
            ], Ps = [], Bs = new Vector3(), Ds = new Vector3(), Ls = new Vector3(), Us = new Vector3(), _quaternion$1 = new Vector3(), ks = new Vector3(), Fs = new Matrix3(), Os = new Box3(), zs = new Matrix4(), _inverseMatrix = new Matrix4(), Ws = new Ray();
        class Vs {
            constructor(REVISION = new Vector3(), t = new Vector3(), n = new Matrix3()) {
                this.center = REVISION, this.halfSize = t, this.rotation = n;
            }
            set(REVISION, t, n) {
                return this.center = REVISION, this.halfSize = t, this.rotation = n, this;
            }
            copy(REVISION) {
                return this.center.copy(REVISION.center), this.halfSize.copy(REVISION.halfSize), this.rotation.copy(REVISION.rotation), this;
            }
            clone() {
                return new this.constructor().copy(this);
            }
            getSize(REVISION) {
                return REVISION.copy(this.halfSize).multiplyScalar(2);
            }
            clampPoint(REVISION, t) {
                const n = this.halfSize;
                Us.subVectors(REVISION, this.center), this.rotation.extractBasis(Bs, Ds, Ls), t.copy(this.center);
                const i = bt.clamp(Us.dot(Bs), -n.x, n.x);
                t.add(Bs.multiplyScalar(i));
                const r = bt.clamp(Us.dot(Ds), -n.y, n.y);
                t.add(Ds.multiplyScalar(r));
                const AddEquation = bt.clamp(Us.dot(Ls), -n.z, n.z);
                return t.add(Ls.multiplyScalar(AddEquation)), t;
            }
            containsPoint(REVISION) {
                return Us.subVectors(REVISION, this.center), this.rotation.extractBasis(Bs, Ds, Ls), Math.abs(Us.dot(Bs)) <= this.halfSize.x && Math.abs(Us.dot(Ds)) <= this.halfSize.y && Math.abs(Us.dot(Ls)) <= this.halfSize.z;
            }
            intersectsBox3(REVISION) {
                return this.intersectsOBB(Gs.fromBox3(REVISION));
            }
            intersectsSphere(REVISION) {
                return this.clampPoint(REVISION.center, ks), ks.distanceToSquared(REVISION.center) <= REVISION.radius * REVISION.radius;
            }
            intersectsOBB(REVISION, t = Number.EPSILON) {
                Ts.c = this.center, Ts.e[0] = this.halfSize.x, Ts.e[1] = this.halfSize.y, Ts.e[2] = this.halfSize.z, this.rotation.extractBasis(Ts.u[0], Ts.u[1], Ts.u[2]), Cs.c = REVISION.center, Cs.e[0] = REVISION.halfSize.x, Cs.e[1] = REVISION.halfSize.y, Cs.e[2] = REVISION.halfSize.z, REVISION.rotation.extractBasis(Cs.u[0], Cs.u[1], Cs.u[2]);
                for (let REVISION = 0; REVISION < 3; REVISION++)
                    for (let t = 0; t < 3; t++)
                        Is[REVISION][t] = Ts.u[REVISION].dot(Cs.u[t]);
                Us.subVectors(Cs.c, Ts.c), Ps[0] = Us.dot(Ts.u[0]), Ps[1] = Us.dot(Ts.u[1]), Ps[2] = Us.dot(Ts.u[2]);
                for (let REVISION = 0; REVISION < 3; REVISION++)
                    for (let n = 0; n < 3; n++)
                        Rs[REVISION][n] = Math.abs(Is[REVISION][n]) + t;
                let n, i;
                for (let REVISION = 0; REVISION < 3; REVISION++)
                    if (n = Ts.e[REVISION], i = Cs.e[0] * Rs[REVISION][0] + Cs.e[1] * Rs[REVISION][1] + Cs.e[2] * Rs[REVISION][2], Math.abs(Ps[REVISION]) > n + i)
                        return !1;
                for (let REVISION = 0; REVISION < 3; REVISION++)
                    if (n = Ts.e[0] * Rs[0][REVISION] + Ts.e[1] * Rs[1][REVISION] + Ts.e[2] * Rs[2][REVISION], i = Cs.e[REVISION], Math.abs(Ps[0] * Is[0][REVISION] + Ps[1] * Is[1][REVISION] + Ps[2] * Is[2][REVISION]) > n + i)
                        return !1;
                return n = Ts.e[1] * Rs[2][0] + Ts.e[2] * Rs[1][0], i = Cs.e[1] * Rs[0][2] + Cs.e[2] * Rs[0][1], !(Math.abs(Ps[2] * Is[1][0] - Ps[1] * Is[2][0]) > n + i) && (n = Ts.e[1] * Rs[2][1] + Ts.e[2] * Rs[1][1], i = Cs.e[0] * Rs[0][2] + Cs.e[2] * Rs[0][0], !(Math.abs(Ps[2] * Is[1][1] - Ps[1] * Is[2][1]) > n + i) && (n = Ts.e[1] * Rs[2][2] + Ts.e[2] * Rs[1][2], i = Cs.e[0] * Rs[0][1] + Cs.e[1] * Rs[0][0], !(Math.abs(Ps[2] * Is[1][2] - Ps[1] * Is[2][2]) > n + i) && (n = Ts.e[0] * Rs[2][0] + Ts.e[2] * Rs[0][0], i = Cs.e[1] * Rs[1][2] + Cs.e[2] * Rs[1][1], !(Math.abs(Ps[0] * Is[2][0] - Ps[2] * Is[0][0]) > n + i) && (n = Ts.e[0] * Rs[2][1] + Ts.e[2] * Rs[0][1], i = Cs.e[0] * Rs[1][2] + Cs.e[2] * Rs[1][0], !(Math.abs(Ps[0] * Is[2][1] - Ps[2] * Is[0][1]) > n + i) && (n = Ts.e[0] * Rs[2][2] + Ts.e[2] * Rs[0][2], i = Cs.e[0] * Rs[1][1] + Cs.e[1] * Rs[1][0], !(Math.abs(Ps[0] * Is[2][2] - Ps[2] * Is[0][2]) > n + i) && (n = Ts.e[0] * Rs[1][0] + Ts.e[1] * Rs[0][0], i = Cs.e[1] * Rs[2][2] + Cs.e[2] * Rs[2][1], !(Math.abs(Ps[1] * Is[0][0] - Ps[0] * Is[1][0]) > n + i) && (n = Ts.e[0] * Rs[1][1] + Ts.e[1] * Rs[0][1], i = Cs.e[0] * Rs[2][2] + Cs.e[2] * Rs[2][0], !(Math.abs(Ps[1] * Is[0][1] - Ps[0] * Is[1][1]) > n + i) && (n = Ts.e[0] * Rs[1][2] + Ts.e[1] * Rs[0][2], i = Cs.e[0] * Rs[2][1] + Cs.e[1] * Rs[2][0], !(Math.abs(Ps[1] * Is[0][2] - Ps[0] * Is[1][2]) > n + i)))))))));
            }
            intersectsPlane(REVISION) {
                this.rotation.extractBasis(Bs, Ds, Ls);
                const t = this.halfSize.x * Math.abs(REVISION.normal.dot(Bs)) + this.halfSize.y * Math.abs(REVISION.normal.dot(Ds)) + this.halfSize.z * Math.abs(REVISION.normal.dot(Ls)), n = REVISION.normal.dot(this.center) - REVISION.constant;
                return Math.abs(n) <= t;
            }
            intersectRay(REVISION, t) {
                return this.getSize(_quaternion$1), Os.setFromCenterAndSize(Us.set(0, 0, 0), _quaternion$1), zs.setFromMatrix3(this.rotation), zs.setPosition(this.center), _inverseMatrix.copy(zs).invert(), Ws.copy(REVISION).applyMatrix4(_inverseMatrix), Ws.intersectBox(Os, t) ? t.applyMatrix4(zs) : null;
            }
            intersectsRay(REVISION) {
                return null !== this.intersectRay(REVISION, Us);
            }
            fromBox3(REVISION) {
                return REVISION.getCenter(this.center), REVISION.getSize(this.halfSize).multiplyScalar(0.5), this.rotation.identity(), this;
            }
            equals(REVISION) {
                return REVISION.center.equals(this.center) && REVISION.halfSize.equals(this.halfSize) && REVISION.rotation.equals(this.rotation);
            }
            applyMatrix4(REVISION) {
                const t = REVISION.elements;
                let n = Us.set(t[0], t[1], t[2]).length();
                const i = Us.set(t[4], t[5], t[6]).length(), r = Us.set(t[8], t[9], t[10]).length();
                REVISION.determinant() < 0 && (n = -n), Fs.setFromMatrix4(REVISION);
                const AddEquation = 1 / n, SubtractEquation = 1 / i, ReverseSubtractEquation = 1 / r;
                return Fs.elements[0] *= AddEquation, Fs.elements[1] *= AddEquation, Fs.elements[2] *= AddEquation, Fs.elements[3] *= SubtractEquation, Fs.elements[4] *= SubtractEquation, Fs.elements[5] *= SubtractEquation, Fs.elements[6] *= ReverseSubtractEquation, Fs.elements[7] *= ReverseSubtractEquation, Fs.elements[8] *= ReverseSubtractEquation, this.rotation.multiply(Fs), this.halfSize.x *= n, this.halfSize.y *= i, this.halfSize.z *= r, Us.setFromMatrixPosition(REVISION), this.center.add(Us), this;
            }
        }
        const Gs = new Vs();
        function Qs(REVISION) {
            let t = REVISION.length;
            for (; --t >= 0;)
                REVISION[t] = 0;
        }
        const Xs = 256, js = 286, qs = 30, Ys = 15, Ks = new Uint8Array([
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                3,
                3,
                3,
                3,
                4,
                4,
                4,
                4,
                5,
                5,
                5,
                5,
                0
            ]), Zs = new Uint8Array([
                0,
                0,
                0,
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                4,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                8,
                8,
                9,
                9,
                10,
                10,
                11,
                11,
                12,
                12,
                13,
                13
            ]), Js = new Uint8Array([
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                3,
                7
            ]), $s = new Uint8Array([
                16,
                17,
                18,
                0,
                8,
                7,
                9,
                6,
                10,
                5,
                11,
                4,
                12,
                3,
                13,
                2,
                14,
                1,
                15
            ]), eo = new Array(576);
        Qs(eo);
        const to = new Array(60);
        Qs(to);
        const no = new Array(512);
        Qs(no);
        const io = new Array(256);
        Qs(io);
        const ro = new Array(29);
        Qs(ro);
        const ao = new Array(qs);
        function so(REVISION, t, n, i, r) {
            this.static_tree = REVISION, this.extra_bits = t, this.extra_base = n, this.elems = i, this.max_length = r, this.has_stree = REVISION && REVISION.length;
        }
        let oo, lo, co;
        function ho(REVISION, t) {
            this.dyn_tree = REVISION, this.max_code = 0, this.stat_desc = t;
        }
        Qs(ao);
        const uo = REVISION => REVISION < 256 ? no[REVISION] : no[256 + (REVISION >>> 7)], fo = (REVISION, t) => {
                REVISION.pending_buf[REVISION.pending++] = 255 & t, REVISION.pending_buf[REVISION.pending++] = t >>> 8 & 255;
            }, po = (REVISION, t, n) => {
                REVISION.bi_valid > 16 - n ? (REVISION.bi_buf |= t << REVISION.bi_valid & 65535, fo(REVISION, REVISION.bi_buf), REVISION.bi_buf = t >> 16 - REVISION.bi_valid, REVISION.bi_valid += n - 16) : (REVISION.bi_buf |= t << REVISION.bi_valid & 65535, REVISION.bi_valid += n);
            }, mo = (REVISION, t, n) => {
                po(REVISION, n[2 * t], n[2 * t + 1]);
            }, go = (REVISION, t) => {
                let n = 0;
                do {
                    n |= 1 & REVISION, REVISION >>>= 1, n <<= 1;
                } while (--t > 0);
                return n >>> 1;
            }, Ao = (REVISION, t, n) => {
                const i = new Array(16);
                let r, AddEquation, SubtractEquation = 0;
                for (r = 1; r <= Ys; r++)
                    SubtractEquation = SubtractEquation + n[r - 1] << 1, i[r] = SubtractEquation;
                for (AddEquation = 0; AddEquation <= t; AddEquation++) {
                    let t = REVISION[2 * AddEquation + 1];
                    0 !== t && (REVISION[2 * AddEquation] = go(i[t]++, t));
                }
            }, _o = REVISION => {
                let t;
                for (t = 0; t < js; t++)
                    REVISION.dyn_ltree[2 * t] = 0;
                for (t = 0; t < qs; t++)
                    REVISION.dyn_dtree[2 * t] = 0;
                for (t = 0; t < 19; t++)
                    REVISION.bl_tree[2 * t] = 0;
                REVISION.dyn_ltree[512] = 1, REVISION.opt_len = REVISION.static_len = 0, REVISION.sym_next = REVISION.matches = 0;
            }, vo = REVISION => {
                REVISION.bi_valid > 8 ? fo(REVISION, REVISION.bi_buf) : REVISION.bi_valid > 0 && (REVISION.pending_buf[REVISION.pending++] = REVISION.bi_buf), REVISION.bi_buf = 0, REVISION.bi_valid = 0;
            }, wo = (REVISION, t, n, i) => {
                const r = 2 * t, AddEquation = 2 * n;
                return REVISION[r] < REVISION[AddEquation] || REVISION[r] === REVISION[AddEquation] && i[t] <= i[n];
            }, yo = (REVISION, t, n) => {
                const i = REVISION.heap[n];
                let r = n << 1;
                for (; r <= REVISION.heap_len && (r < REVISION.heap_len && wo(t, REVISION.heap[r + 1], REVISION.heap[r], REVISION.depth) && r++, !wo(t, i, REVISION.heap[r], REVISION.depth));)
                    REVISION.heap[n] = REVISION.heap[r], n = r, r <<= 1;
                REVISION.heap[n] = i;
            }, xo = (REVISION, t, n) => {
                let i, r, AddEquation, SubtractEquation, ReverseSubtractEquation = 0;
                if (0 !== REVISION.sym_next)
                    do {
                        i = 255 & REVISION.pending_buf[REVISION.sym_buf + ReverseSubtractEquation++], i += (255 & REVISION.pending_buf[REVISION.sym_buf + ReverseSubtractEquation++]) << 8, r = REVISION.pending_buf[REVISION.sym_buf + ReverseSubtractEquation++], 0 === i ? mo(REVISION, r, t) : (AddEquation = io[r], mo(REVISION, AddEquation + Xs + 1, t), SubtractEquation = Ks[AddEquation], 0 !== SubtractEquation && (r -= ro[AddEquation], po(REVISION, r, SubtractEquation)), i--, AddEquation = uo(i), mo(REVISION, AddEquation, n), SubtractEquation = Zs[AddEquation], 0 !== SubtractEquation && (i -= ao[AddEquation], po(REVISION, i, SubtractEquation)));
                    } while (ReverseSubtractEquation < REVISION.sym_next);
                mo(REVISION, 256, t);
            }, bo = (REVISION, t) => {
                const n = t.dyn_tree, i = t.stat_desc.static_tree, r = t.stat_desc.has_stree, AddEquation = t.stat_desc.elems;
                let SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor = -1;
                for (REVISION.heap_len = 0, REVISION.heap_max = 573, SubtractEquation = 0; SubtractEquation < AddEquation; SubtractEquation++)
                    0 !== n[2 * SubtractEquation] ? (REVISION.heap[++REVISION.heap_len] = OneFactor = SubtractEquation, REVISION.depth[SubtractEquation] = 0) : n[2 * SubtractEquation + 1] = 0;
                for (; REVISION.heap_len < 2;)
                    ZeroFactor = REVISION.heap[++REVISION.heap_len] = OneFactor < 2 ? ++OneFactor : 0, n[2 * ZeroFactor] = 1, REVISION.depth[ZeroFactor] = 0, REVISION.opt_len--, r && (REVISION.static_len -= i[2 * ZeroFactor + 1]);
                for (t.max_code = OneFactor, SubtractEquation = REVISION.heap_len >> 1; SubtractEquation >= 1; SubtractEquation--)
                    yo(REVISION, n, SubtractEquation);
                ZeroFactor = AddEquation;
                do {
                    SubtractEquation = REVISION.heap[1], REVISION.heap[1] = REVISION.heap[REVISION.heap_len--], yo(REVISION, n, 1), ReverseSubtractEquation = REVISION.heap[1], REVISION.heap[--REVISION.heap_max] = SubtractEquation, REVISION.heap[--REVISION.heap_max] = ReverseSubtractEquation, n[2 * ZeroFactor] = n[2 * SubtractEquation] + n[2 * ReverseSubtractEquation], REVISION.depth[ZeroFactor] = (REVISION.depth[SubtractEquation] >= REVISION.depth[ReverseSubtractEquation] ? REVISION.depth[SubtractEquation] : REVISION.depth[ReverseSubtractEquation]) + 1, n[2 * SubtractEquation + 1] = n[2 * ReverseSubtractEquation + 1] = ZeroFactor, REVISION.heap[1] = ZeroFactor++, yo(REVISION, n, 1);
                } while (REVISION.heap_len >= 2);
                REVISION.heap[--REVISION.heap_max] = REVISION.heap[1], ((REVISION, t) => {
                    const n = t.dyn_tree, i = t.max_code, r = t.stat_desc.static_tree, AddEquation = t.stat_desc.has_stree, SubtractEquation = t.stat_desc.extra_bits, ReverseSubtractEquation = t.stat_desc.extra_base, ZeroFactor = t.stat_desc.max_length;
                    let OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor = 0;
                    for (SrcAlphaFactor = 0; SrcAlphaFactor <= Ys; SrcAlphaFactor++)
                        REVISION.bl_count[SrcAlphaFactor] = 0;
                    for (n[2 * REVISION.heap[REVISION.heap_max] + 1] = 0, OneFactor = REVISION.heap_max + 1; OneFactor < 573; OneFactor++)
                        SrcColorFactor = REVISION.heap[OneFactor], SrcAlphaFactor = n[2 * n[2 * SrcColorFactor + 1] + 1] + 1, SrcAlphaFactor > ZeroFactor && (SrcAlphaFactor = ZeroFactor, OneMinusDstAlphaFactor++), n[2 * SrcColorFactor + 1] = SrcAlphaFactor, SrcColorFactor > i || (REVISION.bl_count[SrcAlphaFactor]++, OneMinusSrcAlphaFactor = 0, SrcColorFactor >= ReverseSubtractEquation && (OneMinusSrcAlphaFactor = SubtractEquation[SrcColorFactor - ReverseSubtractEquation]), DstAlphaFactor = n[2 * SrcColorFactor], REVISION.opt_len += DstAlphaFactor * (SrcAlphaFactor + OneMinusSrcAlphaFactor), AddEquation && (REVISION.static_len += DstAlphaFactor * (r[2 * SrcColorFactor + 1] + OneMinusSrcAlphaFactor)));
                    if (0 !== OneMinusDstAlphaFactor) {
                        do {
                            for (SrcAlphaFactor = ZeroFactor - 1; 0 === REVISION.bl_count[SrcAlphaFactor];)
                                SrcAlphaFactor--;
                            REVISION.bl_count[SrcAlphaFactor]--, REVISION.bl_count[SrcAlphaFactor + 1] += 2, REVISION.bl_count[ZeroFactor]--, OneMinusDstAlphaFactor -= 2;
                        } while (OneMinusDstAlphaFactor > 0);
                        for (SrcAlphaFactor = ZeroFactor; 0 !== SrcAlphaFactor; SrcAlphaFactor--)
                            for (SrcColorFactor = REVISION.bl_count[SrcAlphaFactor]; 0 !== SrcColorFactor;)
                                OneMinusSrcColorFactor = REVISION.heap[--OneFactor], OneMinusSrcColorFactor > i || (n[2 * OneMinusSrcColorFactor + 1] !== SrcAlphaFactor && (REVISION.opt_len += (SrcAlphaFactor - n[2 * OneMinusSrcColorFactor + 1]) * n[2 * OneMinusSrcColorFactor], n[2 * OneMinusSrcColorFactor + 1] = SrcAlphaFactor), SrcColorFactor--);
                    }
                })(REVISION, t), Ao(n, OneFactor, REVISION.bl_count);
            }, So = (REVISION, t, n) => {
                let i, r, AddEquation = -1, SubtractEquation = t[1], ReverseSubtractEquation = 0, ZeroFactor = 7, OneFactor = 4;
                for (0 === SubtractEquation && (ZeroFactor = 138, OneFactor = 3), t[2 * (n + 1) + 1] = 65535, i = 0; i <= n; i++)
                    r = SubtractEquation, SubtractEquation = t[2 * (i + 1) + 1], ++ReverseSubtractEquation < ZeroFactor && r === SubtractEquation || (ReverseSubtractEquation < OneFactor ? REVISION.bl_tree[2 * r] += ReverseSubtractEquation : 0 !== r ? (r !== AddEquation && REVISION.bl_tree[2 * r]++, REVISION.bl_tree[32]++) : ReverseSubtractEquation <= 10 ? REVISION.bl_tree[34]++ : REVISION.bl_tree[36]++, ReverseSubtractEquation = 0, AddEquation = r, 0 === SubtractEquation ? (ZeroFactor = 138, OneFactor = 3) : r === SubtractEquation ? (ZeroFactor = 6, OneFactor = 3) : (ZeroFactor = 7, OneFactor = 4));
            }, Eo = (REVISION, t, n) => {
                let i, r, AddEquation = -1, SubtractEquation = t[1], ReverseSubtractEquation = 0, ZeroFactor = 7, OneFactor = 4;
                for (0 === SubtractEquation && (ZeroFactor = 138, OneFactor = 3), i = 0; i <= n; i++)
                    if (r = SubtractEquation, SubtractEquation = t[2 * (i + 1) + 1], !(++ReverseSubtractEquation < ZeroFactor && r === SubtractEquation)) {
                        if (ReverseSubtractEquation < OneFactor)
                            do {
                                mo(REVISION, r, REVISION.bl_tree);
                            } while (0 != --ReverseSubtractEquation);
                        else
                            0 !== r ? (r !== AddEquation && (mo(REVISION, r, REVISION.bl_tree), ReverseSubtractEquation--), mo(REVISION, 16, REVISION.bl_tree), po(REVISION, ReverseSubtractEquation - 3, 2)) : ReverseSubtractEquation <= 10 ? (mo(REVISION, 17, REVISION.bl_tree), po(REVISION, ReverseSubtractEquation - 3, 3)) : (mo(REVISION, 18, REVISION.bl_tree), po(REVISION, ReverseSubtractEquation - 11, 7));
                        ReverseSubtractEquation = 0, AddEquation = r, 0 === SubtractEquation ? (ZeroFactor = 138, OneFactor = 3) : r === SubtractEquation ? (ZeroFactor = 6, OneFactor = 3) : (ZeroFactor = 7, OneFactor = 4);
                    }
            };
        let Mo = !1;
        const To = (REVISION, t, n, i) => {
            po(REVISION, 0 + (i ? 1 : 0), 3), vo(REVISION), fo(REVISION, n), fo(REVISION, ~n), n && REVISION.pending_buf.set(REVISION.window.subarray(t, t + n), REVISION.pending), REVISION.pending += n;
        };
        var Co = (REVISION, t, n, i) => {
                let r, AddEquation, SubtractEquation = 0;
                REVISION.level > 0 ? (2 === REVISION.strm.data_type && (REVISION.strm.data_type = (REVISION => {
                    let t, n = 4093624447;
                    for (t = 0; t <= 31; t++, n >>>= 1)
                        if (1 & n && 0 !== REVISION.dyn_ltree[2 * t])
                            return 0;
                    if (0 !== REVISION.dyn_ltree[18] || 0 !== REVISION.dyn_ltree[20] || 0 !== REVISION.dyn_ltree[26])
                        return 1;
                    for (t = 32; t < Xs; t++)
                        if (0 !== REVISION.dyn_ltree[2 * t])
                            return 1;
                    return 0;
                })(REVISION)), bo(REVISION, REVISION.l_desc), bo(REVISION, REVISION.d_desc), SubtractEquation = (REVISION => {
                    let t;
                    for (So(REVISION, REVISION.dyn_ltree, REVISION.l_desc.max_code), So(REVISION, REVISION.dyn_dtree, REVISION.d_desc.max_code), bo(REVISION, REVISION.bl_desc), t = 18; t >= 3 && 0 === REVISION.bl_tree[2 * $s[t] + 1]; t--);
                    return REVISION.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
                })(REVISION), r = REVISION.opt_len + 3 + 7 >>> 3, AddEquation = REVISION.static_len + 3 + 7 >>> 3, AddEquation <= r && (r = AddEquation)) : r = AddEquation = n + 5, n + 4 <= r && -1 !== t ? To(REVISION, t, n, i) : 4 === REVISION.strategy || AddEquation === r ? (po(REVISION, 2 + (i ? 1 : 0), 3), xo(REVISION, eo, to)) : (po(REVISION, 4 + (i ? 1 : 0), 3), ((REVISION, t, n, i) => {
                    let r;
                    for (po(REVISION, t - 257, 5), po(REVISION, n - 1, 5), po(REVISION, i - 4, 4), r = 0; r < i; r++)
                        po(REVISION, REVISION.bl_tree[2 * $s[r] + 1], 3);
                    Eo(REVISION, REVISION.dyn_ltree, t - 1), Eo(REVISION, REVISION.dyn_dtree, n - 1);
                })(REVISION, REVISION.l_desc.max_code + 1, REVISION.d_desc.max_code + 1, SubtractEquation + 1), xo(REVISION, REVISION.dyn_ltree, REVISION.dyn_dtree)), _o(REVISION), i && vo(REVISION);
            }, Io = {
                _tr_init: REVISION => {
                    Mo || ((() => {
                        let REVISION, t, n, i, r;
                        const AddEquation = new Array(16);
                        for (n = 0, i = 0; i < 28; i++)
                            for (ro[i] = n, REVISION = 0; REVISION < 1 << Ks[i]; REVISION++)
                                io[n++] = i;
                        for (io[n - 1] = i, r = 0, i = 0; i < 16; i++)
                            for (ao[i] = r, REVISION = 0; REVISION < 1 << Zs[i]; REVISION++)
                                no[r++] = i;
                        for (r >>= 7; i < qs; i++)
                            for (ao[i] = r << 7, REVISION = 0; REVISION < 1 << Zs[i] - 7; REVISION++)
                                no[256 + r++] = i;
                        for (t = 0; t <= Ys; t++)
                            AddEquation[t] = 0;
                        for (REVISION = 0; REVISION <= 143;)
                            eo[2 * REVISION + 1] = 8, REVISION++, AddEquation[8]++;
                        for (; REVISION <= 255;)
                            eo[2 * REVISION + 1] = 9, REVISION++, AddEquation[9]++;
                        for (; REVISION <= 279;)
                            eo[2 * REVISION + 1] = 7, REVISION++, AddEquation[7]++;
                        for (; REVISION <= 287;)
                            eo[2 * REVISION + 1] = 8, REVISION++, AddEquation[8]++;
                        for (Ao(eo, 287, AddEquation), REVISION = 0; REVISION < qs; REVISION++)
                            to[2 * REVISION + 1] = 5, to[2 * REVISION] = go(REVISION, 5);
                        oo = new so(eo, Ks, 257, js, Ys), lo = new so(to, Zs, 0, qs, Ys), co = new so(new Array(0), Js, 0, 19, 7);
                    })(), Mo = !0), REVISION.l_desc = new ho(REVISION.dyn_ltree, oo), REVISION.d_desc = new ho(REVISION.dyn_dtree, lo), REVISION.bl_desc = new ho(REVISION.bl_tree, co), REVISION.bi_buf = 0, REVISION.bi_valid = 0, _o(REVISION);
                },
                _tr_stored_block: To,
                _tr_flush_block: Co,
                _tr_tally: (REVISION, t, n) => (REVISION.pending_buf[REVISION.sym_buf + REVISION.sym_next++] = t, REVISION.pending_buf[REVISION.sym_buf + REVISION.sym_next++] = t >> 8, REVISION.pending_buf[REVISION.sym_buf + REVISION.sym_next++] = n, 0 === t ? REVISION.dyn_ltree[2 * n]++ : (REVISION.matches++, t--, REVISION.dyn_ltree[2 * (io[n] + Xs + 1)]++, REVISION.dyn_dtree[2 * uo(t)]++), REVISION.sym_next === REVISION.sym_end),
                _tr_align: REVISION => {
                    po(REVISION, 2, 3), mo(REVISION, 256, eo), (REVISION => {
                        16 === REVISION.bi_valid ? (fo(REVISION, REVISION.bi_buf), REVISION.bi_buf = 0, REVISION.bi_valid = 0) : REVISION.bi_valid >= 8 && (REVISION.pending_buf[REVISION.pending++] = 255 & REVISION.bi_buf, REVISION.bi_buf >>= 8, REVISION.bi_valid -= 8);
                    })(REVISION);
                }
            };
        var Ro = (REVISION, t, n, i) => {
            let r = 65535 & REVISION, AddEquation = REVISION >>> 16 & 65535, SubtractEquation = 0;
            for (; 0 !== n;) {
                SubtractEquation = n > 2000 ? 2000 : n, n -= SubtractEquation;
                do {
                    r = r + t[i++] | 0, AddEquation = AddEquation + r | 0;
                } while (--SubtractEquation);
                r %= 65521, AddEquation %= 65521;
            }
            return r | AddEquation << 16;
        };
        const Po = new Uint32Array((() => {
            let REVISION, t = [];
            for (var n = 0; n < 256; n++) {
                REVISION = n;
                for (var i = 0; i < 8; i++)
                    REVISION = 1 & REVISION ? 3988292384 ^ REVISION >>> 1 : REVISION >>> 1;
                t[n] = REVISION;
            }
            return t;
        })());
        var Bo = (REVISION, t, n, i) => {
                const r = Po, AddEquation = i + n;
                REVISION ^= -1;
                for (let n = i; n < AddEquation; n++)
                    REVISION = REVISION >>> 8 ^ r[255 & (REVISION ^ t[n])];
                return ~REVISION;
            }, Do = {
                2: 'need dictionary',
                1: 'stream end',
                0: '',
                '-1': 'file error',
                '-2': 'stream error',
                '-3': 'data error',
                '-4': 'insufficient memory',
                '-5': 'buffer error',
                '-6': 'incompatible version'
            }, Lo = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            };
        const {
                _tr_init: Uo,
                _tr_stored_block: No,
                _tr_flush_block: ko,
                _tr_tally: Fo,
                _tr_align: Oo
            } = Io, {
                Z_NO_FLUSH: zo,
                Z_PARTIAL_FLUSH: Ho,
                Z_FULL_FLUSH: Wo,
                Z_FINISH: Vo,
                Z_BLOCK: Go,
                Z_OK: Qo,
                Z_STREAM_END: Xo,
                Z_STREAM_ERROR: jo,
                Z_DATA_ERROR: qo,
                Z_BUF_ERROR: Yo,
                Z_DEFAULT_COMPRESSION: Ko,
                Z_FILTERED: Zo,
                Z_HUFFMAN_ONLY: Jo,
                Z_RLE: $o,
                Z_FIXED: el,
                Z_DEFAULT_STRATEGY: tl,
                Z_UNKNOWN: nl,
                Z_DEFLATED: il
            } = Lo, rl = 258, al = 262, sl = 42, ol = 113, ll = 666, cl = (REVISION, t) => (REVISION.msg = Do[t], t), hl = REVISION => 2 * REVISION - (REVISION > 4 ? 9 : 0), dl = REVISION => {
                let t = REVISION.length;
                for (; --t >= 0;)
                    REVISION[t] = 0;
            }, ul = REVISION => {
                let t, n, i, r = REVISION.w_size;
                t = REVISION.hash_size, i = t;
                do {
                    n = REVISION.head[--i], REVISION.head[i] = n >= r ? n - r : 0;
                } while (--t);
                t = r, i = t;
                do {
                    n = REVISION.prev[--i], REVISION.prev[i] = n >= r ? n - r : 0;
                } while (--t);
            };
        let fl = (REVISION, t, n) => (t << REVISION.hash_shift ^ n) & REVISION.hash_mask;
        const pl = REVISION => {
                const t = REVISION.state;
                let n = t.pending;
                n > REVISION.avail_out && (n = REVISION.avail_out), 0 !== n && (REVISION.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), REVISION.next_out), REVISION.next_out += n, t.pending_out += n, REVISION.total_out += n, REVISION.avail_out -= n, t.pending -= n, 0 === t.pending && (t.pending_out = 0));
            }, ml = (REVISION, t) => {
                ko(REVISION, REVISION.block_start >= 0 ? REVISION.block_start : -1, REVISION.strstart - REVISION.block_start, t), REVISION.block_start = REVISION.strstart, pl(REVISION.strm);
            }, gl = (REVISION, t) => {
                REVISION.pending_buf[REVISION.pending++] = t;
            }, Al = (REVISION, t) => {
                REVISION.pending_buf[REVISION.pending++] = t >>> 8 & 255, REVISION.pending_buf[REVISION.pending++] = 255 & t;
            }, _l = (REVISION, t, n, i) => {
                let r = REVISION.avail_in;
                return r > i && (r = i), 0 === r ? 0 : (REVISION.avail_in -= r, t.set(REVISION.input.subarray(REVISION.next_in, REVISION.next_in + r), n), 1 === REVISION.state.wrap ? REVISION.adler = Ro(REVISION.adler, t, r, n) : 2 === REVISION.state.wrap && (REVISION.adler = Bo(REVISION.adler, t, r, n)), REVISION.next_in += r, REVISION.total_in += r, r);
            }, vl = (REVISION, t) => {
                let n, i, r = REVISION.max_chain_length, AddEquation = REVISION.strstart, SubtractEquation = REVISION.prev_length, ReverseSubtractEquation = REVISION.nice_match;
                const ZeroFactor = REVISION.strstart > REVISION.w_size - al ? REVISION.strstart - (REVISION.w_size - al) : 0, OneFactor = REVISION.window, SrcColorFactor = REVISION.w_mask, OneMinusSrcColorFactor = REVISION.prev, SrcAlphaFactor = REVISION.strstart + rl;
                let OneMinusSrcAlphaFactor = OneFactor[AddEquation + SubtractEquation - 1], DstAlphaFactor = OneFactor[AddEquation + SubtractEquation];
                REVISION.prev_length >= REVISION.good_match && (r >>= 2), ReverseSubtractEquation > REVISION.lookahead && (ReverseSubtractEquation = REVISION.lookahead);
                do {
                    if (n = t, OneFactor[n + SubtractEquation] === DstAlphaFactor && OneFactor[n + SubtractEquation - 1] === OneMinusSrcAlphaFactor && OneFactor[n] === OneFactor[AddEquation] && OneFactor[++n] === OneFactor[AddEquation + 1]) {
                        AddEquation += 2, n++;
                        do {
                        } while (OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && OneFactor[++AddEquation] === OneFactor[++n] && AddEquation < SrcAlphaFactor);
                        if (i = rl - (SrcAlphaFactor - AddEquation), AddEquation = SrcAlphaFactor - rl, i > SubtractEquation) {
                            if (REVISION.match_start = t, SubtractEquation = i, i >= ReverseSubtractEquation)
                                break;
                            OneMinusSrcAlphaFactor = OneFactor[AddEquation + SubtractEquation - 1], DstAlphaFactor = OneFactor[AddEquation + SubtractEquation];
                        }
                    }
                } while ((t = OneMinusSrcColorFactor[t & SrcColorFactor]) > ZeroFactor && 0 != --r);
                return SubtractEquation <= REVISION.lookahead ? SubtractEquation : REVISION.lookahead;
            }, wl = REVISION => {
                const t = REVISION.w_size;
                let n, i, r;
                do {
                    if (i = REVISION.window_size - REVISION.lookahead - REVISION.strstart, REVISION.strstart >= t + (t - al) && (REVISION.window.set(REVISION.window.subarray(t, t + t - i), 0), REVISION.match_start -= t, REVISION.strstart -= t, REVISION.block_start -= t, REVISION.insert > REVISION.strstart && (REVISION.insert = REVISION.strstart), ul(REVISION), i += t), 0 === REVISION.strm.avail_in)
                        break;
                    if (n = _l(REVISION.strm, REVISION.window, REVISION.strstart + REVISION.lookahead, i), REVISION.lookahead += n, REVISION.lookahead + REVISION.insert >= 3)
                        for (r = REVISION.strstart - REVISION.insert, REVISION.ins_h = REVISION.window[r], REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[r + 1]); REVISION.insert && (REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[r + 3 - 1]), REVISION.prev[r & REVISION.w_mask] = REVISION.head[REVISION.ins_h], REVISION.head[REVISION.ins_h] = r, r++, REVISION.insert--, !(REVISION.lookahead + REVISION.insert < 3)););
                } while (REVISION.lookahead < al && 0 !== REVISION.strm.avail_in);
            }, yl = (REVISION, t) => {
                let n, i, r, AddEquation = REVISION.pending_buf_size - 5 > REVISION.w_size ? REVISION.w_size : REVISION.pending_buf_size - 5, SubtractEquation = 0, ReverseSubtractEquation = REVISION.strm.avail_in;
                do {
                    if (n = 65535, r = REVISION.bi_valid + 42 >> 3, REVISION.strm.avail_out < r)
                        break;
                    if (r = REVISION.strm.avail_out - r, i = REVISION.strstart - REVISION.block_start, n > i + REVISION.strm.avail_in && (n = i + REVISION.strm.avail_in), n > r && (n = r), n < AddEquation && (0 === n && t !== Vo || t === zo || n !== i + REVISION.strm.avail_in))
                        break;
                    SubtractEquation = t === Vo && n === i + REVISION.strm.avail_in ? 1 : 0, No(REVISION, 0, 0, SubtractEquation), REVISION.pending_buf[REVISION.pending - 4] = n, REVISION.pending_buf[REVISION.pending - 3] = n >> 8, REVISION.pending_buf[REVISION.pending - 2] = ~n, REVISION.pending_buf[REVISION.pending - 1] = ~n >> 8, pl(REVISION.strm), i && (i > n && (i = n), REVISION.strm.output.set(REVISION.window.subarray(REVISION.block_start, REVISION.block_start + i), REVISION.strm.next_out), REVISION.strm.next_out += i, REVISION.strm.avail_out -= i, REVISION.strm.total_out += i, REVISION.block_start += i, n -= i), n && (_l(REVISION.strm, REVISION.strm.output, REVISION.strm.next_out, n), REVISION.strm.next_out += n, REVISION.strm.avail_out -= n, REVISION.strm.total_out += n);
                } while (0 === SubtractEquation);
                return ReverseSubtractEquation -= REVISION.strm.avail_in, ReverseSubtractEquation && (ReverseSubtractEquation >= REVISION.w_size ? (REVISION.matches = 2, REVISION.window.set(REVISION.strm.input.subarray(REVISION.strm.next_in - REVISION.w_size, REVISION.strm.next_in), 0), REVISION.strstart = REVISION.w_size, REVISION.insert = REVISION.strstart) : (REVISION.window_size - REVISION.strstart <= ReverseSubtractEquation && (REVISION.strstart -= REVISION.w_size, REVISION.window.set(REVISION.window.subarray(REVISION.w_size, REVISION.w_size + REVISION.strstart), 0), REVISION.matches < 2 && REVISION.matches++, REVISION.insert > REVISION.strstart && (REVISION.insert = REVISION.strstart)), REVISION.window.set(REVISION.strm.input.subarray(REVISION.strm.next_in - ReverseSubtractEquation, REVISION.strm.next_in), REVISION.strstart), REVISION.strstart += ReverseSubtractEquation, REVISION.insert += ReverseSubtractEquation > REVISION.w_size - REVISION.insert ? REVISION.w_size - REVISION.insert : ReverseSubtractEquation), REVISION.block_start = REVISION.strstart), REVISION.high_water < REVISION.strstart && (REVISION.high_water = REVISION.strstart), SubtractEquation ? 4 : t !== zo && t !== Vo && 0 === REVISION.strm.avail_in && REVISION.strstart === REVISION.block_start ? 2 : (r = REVISION.window_size - REVISION.strstart, REVISION.strm.avail_in > r && REVISION.block_start >= REVISION.w_size && (REVISION.block_start -= REVISION.w_size, REVISION.strstart -= REVISION.w_size, REVISION.window.set(REVISION.window.subarray(REVISION.w_size, REVISION.w_size + REVISION.strstart), 0), REVISION.matches < 2 && REVISION.matches++, r += REVISION.w_size, REVISION.insert > REVISION.strstart && (REVISION.insert = REVISION.strstart)), r > REVISION.strm.avail_in && (r = REVISION.strm.avail_in), r && (_l(REVISION.strm, REVISION.window, REVISION.strstart, r), REVISION.strstart += r, REVISION.insert += r > REVISION.w_size - REVISION.insert ? REVISION.w_size - REVISION.insert : r), REVISION.high_water < REVISION.strstart && (REVISION.high_water = REVISION.strstart), r = REVISION.bi_valid + 42 >> 3, r = REVISION.pending_buf_size - r > 65535 ? 65535 : REVISION.pending_buf_size - r, AddEquation = r > REVISION.w_size ? REVISION.w_size : r, i = REVISION.strstart - REVISION.block_start, (i >= AddEquation || (i || t === Vo) && t !== zo && 0 === REVISION.strm.avail_in && i <= r) && (n = i > r ? r : i, SubtractEquation = t === Vo && 0 === REVISION.strm.avail_in && n === i ? 1 : 0, No(REVISION, REVISION.block_start, n, SubtractEquation), REVISION.block_start += n, pl(REVISION.strm)), SubtractEquation ? 3 : 1);
            }, xl = (REVISION, t) => {
                let n, i;
                for (;;) {
                    if (REVISION.lookahead < al) {
                        if (wl(REVISION), REVISION.lookahead < al && t === zo)
                            return 1;
                        if (0 === REVISION.lookahead)
                            break;
                    }
                    if (n = 0, REVISION.lookahead >= 3 && (REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[REVISION.strstart + 3 - 1]), n = REVISION.prev[REVISION.strstart & REVISION.w_mask] = REVISION.head[REVISION.ins_h], REVISION.head[REVISION.ins_h] = REVISION.strstart), 0 !== n && REVISION.strstart - n <= REVISION.w_size - al && (REVISION.match_length = vl(REVISION, n)), REVISION.match_length >= 3)
                        if (i = Fo(REVISION, REVISION.strstart - REVISION.match_start, REVISION.match_length - 3), REVISION.lookahead -= REVISION.match_length, REVISION.match_length <= REVISION.max_lazy_match && REVISION.lookahead >= 3) {
                            REVISION.match_length--;
                            do {
                                REVISION.strstart++, REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[REVISION.strstart + 3 - 1]), n = REVISION.prev[REVISION.strstart & REVISION.w_mask] = REVISION.head[REVISION.ins_h], REVISION.head[REVISION.ins_h] = REVISION.strstart;
                            } while (0 != --REVISION.match_length);
                            REVISION.strstart++;
                        } else
                            REVISION.strstart += REVISION.match_length, REVISION.match_length = 0, REVISION.ins_h = REVISION.window[REVISION.strstart], REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[REVISION.strstart + 1]);
                    else
                        i = Fo(REVISION, 0, REVISION.window[REVISION.strstart]), REVISION.lookahead--, REVISION.strstart++;
                    if (i && (ml(REVISION, !1), 0 === REVISION.strm.avail_out))
                        return 1;
                }
                return REVISION.insert = REVISION.strstart < 2 ? REVISION.strstart : 2, t === Vo ? (ml(REVISION, !0), 0 === REVISION.strm.avail_out ? 3 : 4) : REVISION.sym_next && (ml(REVISION, !1), 0 === REVISION.strm.avail_out) ? 1 : 2;
            }, bl = (REVISION, t) => {
                let n, i, r;
                for (;;) {
                    if (REVISION.lookahead < al) {
                        if (wl(REVISION), REVISION.lookahead < al && t === zo)
                            return 1;
                        if (0 === REVISION.lookahead)
                            break;
                    }
                    if (n = 0, REVISION.lookahead >= 3 && (REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[REVISION.strstart + 3 - 1]), n = REVISION.prev[REVISION.strstart & REVISION.w_mask] = REVISION.head[REVISION.ins_h], REVISION.head[REVISION.ins_h] = REVISION.strstart), REVISION.prev_length = REVISION.match_length, REVISION.prev_match = REVISION.match_start, REVISION.match_length = 2, 0 !== n && REVISION.prev_length < REVISION.max_lazy_match && REVISION.strstart - n <= REVISION.w_size - al && (REVISION.match_length = vl(REVISION, n), REVISION.match_length <= 5 && (REVISION.strategy === Zo || 3 === REVISION.match_length && REVISION.strstart - REVISION.match_start > 4096) && (REVISION.match_length = 2)), REVISION.prev_length >= 3 && REVISION.match_length <= REVISION.prev_length) {
                        r = REVISION.strstart + REVISION.lookahead - 3, i = Fo(REVISION, REVISION.strstart - 1 - REVISION.prev_match, REVISION.prev_length - 3), REVISION.lookahead -= REVISION.prev_length - 1, REVISION.prev_length -= 2;
                        do {
                            ++REVISION.strstart <= r && (REVISION.ins_h = fl(REVISION, REVISION.ins_h, REVISION.window[REVISION.strstart + 3 - 1]), n = REVISION.prev[REVISION.strstart & REVISION.w_mask] = REVISION.head[REVISION.ins_h], REVISION.head[REVISION.ins_h] = REVISION.strstart);
                        } while (0 != --REVISION.prev_length);
                        if (REVISION.match_available = 0, REVISION.match_length = 2, REVISION.strstart++, i && (ml(REVISION, !1), 0 === REVISION.strm.avail_out))
                            return 1;
                    } else if (REVISION.match_available) {
                        if (i = Fo(REVISION, 0, REVISION.window[REVISION.strstart - 1]), i && ml(REVISION, !1), REVISION.strstart++, REVISION.lookahead--, 0 === REVISION.strm.avail_out)
                            return 1;
                    } else
                        REVISION.match_available = 1, REVISION.strstart++, REVISION.lookahead--;
                }
                return REVISION.match_available && (i = Fo(REVISION, 0, REVISION.window[REVISION.strstart - 1]), REVISION.match_available = 0), REVISION.insert = REVISION.strstart < 2 ? REVISION.strstart : 2, t === Vo ? (ml(REVISION, !0), 0 === REVISION.strm.avail_out ? 3 : 4) : REVISION.sym_next && (ml(REVISION, !1), 0 === REVISION.strm.avail_out) ? 1 : 2;
            };
        function Sl(REVISION, t, n, i, r) {
            this.good_length = REVISION, this.max_lazy = t, this.nice_length = n, this.max_chain = i, this.func = r;
        }
        const El = [
            new Sl(0, 0, 0, 0, yl),
            new Sl(4, 4, 8, 4, xl),
            new Sl(4, 5, 16, 8, xl),
            new Sl(4, 6, 32, 32, xl),
            new Sl(4, 4, 16, 16, bl),
            new Sl(8, 16, 32, 32, bl),
            new Sl(8, 16, 128, 128, bl),
            new Sl(8, 32, 128, 256, bl),
            new Sl(32, 128, 258, 1024, bl),
            new Sl(32, 258, 258, 4096, bl)
        ];
        function Ml() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = il, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), dl(this.dyn_ltree), dl(this.dyn_dtree), dl(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), dl(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), dl(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        const Tl = REVISION => {
                if (!REVISION)
                    return 1;
                const t = REVISION.state;
                return !t || t.strm !== REVISION || t.status !== sl && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== ol && t.status !== ll ? 1 : 0;
            }, Cl = REVISION => {
                if (Tl(REVISION))
                    return cl(REVISION, jo);
                REVISION.total_in = REVISION.total_out = 0, REVISION.data_type = nl;
                const t = REVISION.state;
                return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = 2 === t.wrap ? 57 : t.wrap ? sl : ol, REVISION.adler = 2 === t.wrap ? 0 : 1, t.last_flush = -2, Uo(t), Qo;
            }, Il = REVISION => {
                const t = Cl(REVISION);
                var n;
                return t === Qo && ((n = REVISION.state).window_size = 2 * n.w_size, dl(n.head), n.max_lazy_match = El[n.level].max_lazy, n.good_match = El[n.level].good_length, n.nice_match = El[n.level].nice_length, n.max_chain_length = El[n.level].max_chain, n.strstart = 0, n.block_start = 0, n.lookahead = 0, n.insert = 0, n.match_length = n.prev_length = 2, n.match_available = 0, n.ins_h = 0), t;
            }, Rl = (REVISION, t, n, i, r, AddEquation) => {
                if (!REVISION)
                    return jo;
                let SubtractEquation = 1;
                if (t === Ko && (t = 6), i < 0 ? (SubtractEquation = 0, i = -i) : i > 15 && (SubtractEquation = 2, i -= 16), r < 1 || r > 9 || n !== il || i < 8 || i > 15 || t < 0 || t > 9 || AddEquation < 0 || AddEquation > el || 8 === i && 1 !== SubtractEquation)
                    return cl(REVISION, jo);
                8 === i && (i = 9);
                const ReverseSubtractEquation = new Ml();
                return REVISION.state = ReverseSubtractEquation, ReverseSubtractEquation.strm = REVISION, ReverseSubtractEquation.status = sl, ReverseSubtractEquation.wrap = SubtractEquation, ReverseSubtractEquation.gzhead = null, ReverseSubtractEquation.w_bits = i, ReverseSubtractEquation.w_size = 1 << ReverseSubtractEquation.w_bits, ReverseSubtractEquation.w_mask = ReverseSubtractEquation.w_size - 1, ReverseSubtractEquation.hash_bits = r + 7, ReverseSubtractEquation.hash_size = 1 << ReverseSubtractEquation.hash_bits, ReverseSubtractEquation.hash_mask = ReverseSubtractEquation.hash_size - 1, ReverseSubtractEquation.hash_shift = ~~((ReverseSubtractEquation.hash_bits + 3 - 1) / 3), ReverseSubtractEquation.window = new Uint8Array(2 * ReverseSubtractEquation.w_size), ReverseSubtractEquation.head = new Uint16Array(ReverseSubtractEquation.hash_size), ReverseSubtractEquation.prev = new Uint16Array(ReverseSubtractEquation.w_size), ReverseSubtractEquation.lit_bufsize = 1 << r + 6, ReverseSubtractEquation.pending_buf_size = 4 * ReverseSubtractEquation.lit_bufsize, ReverseSubtractEquation.pending_buf = new Uint8Array(ReverseSubtractEquation.pending_buf_size), ReverseSubtractEquation.sym_buf = ReverseSubtractEquation.lit_bufsize, ReverseSubtractEquation.sym_end = 3 * (ReverseSubtractEquation.lit_bufsize - 1), ReverseSubtractEquation.level = t, ReverseSubtractEquation.strategy = AddEquation, ReverseSubtractEquation.method = n, Il(REVISION);
            };
        var Pl = {
            deflateInit: (REVISION, t) => Rl(REVISION, t, il, 15, 8, tl),
            deflateInit2: Rl,
            deflateReset: Il,
            deflateResetKeep: Cl,
            deflateSetHeader: (REVISION, t) => Tl(REVISION) || 2 !== REVISION.state.wrap ? jo : (REVISION.state.gzhead = t, Qo),
            deflate: (REVISION, t) => {
                if (Tl(REVISION) || t > Go || t < 0)
                    return REVISION ? cl(REVISION, jo) : jo;
                const n = REVISION.state;
                if (!REVISION.output || 0 !== REVISION.avail_in && !REVISION.input || n.status === ll && t !== Vo)
                    return cl(REVISION, 0 === REVISION.avail_out ? Yo : jo);
                const i = n.last_flush;
                if (n.last_flush = t, 0 !== n.pending) {
                    if (pl(REVISION), 0 === REVISION.avail_out)
                        return n.last_flush = -1, Qo;
                } else if (0 === REVISION.avail_in && hl(t) <= hl(i) && t !== Vo)
                    return cl(REVISION, Yo);
                if (n.status === ll && 0 !== REVISION.avail_in)
                    return cl(REVISION, Yo);
                if (n.status === sl && 0 === n.wrap && (n.status = ol), n.status === sl) {
                    let t = il + (n.w_bits - 8 << 4) << 8, i = -1;
                    if (i = n.strategy >= Jo || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3, t |= i << 6, 0 !== n.strstart && (t |= 32), t += 31 - t % 31, Al(n, t), 0 !== n.strstart && (Al(n, REVISION.adler >>> 16), Al(n, 65535 & REVISION.adler)), REVISION.adler = 1, n.status = ol, pl(REVISION), 0 !== n.pending)
                        return n.last_flush = -1, Qo;
                }
                if (57 === n.status)
                    if (REVISION.adler = 0, gl(n, 31), gl(n, 139), gl(n, 8), n.gzhead)
                        gl(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), gl(n, 255 & n.gzhead.time), gl(n, n.gzhead.time >> 8 & 255), gl(n, n.gzhead.time >> 16 & 255), gl(n, n.gzhead.time >> 24 & 255), gl(n, 9 === n.level ? 2 : n.strategy >= Jo || n.level < 2 ? 4 : 0), gl(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (gl(n, 255 & n.gzhead.extra.length), gl(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69;
                    else if (gl(n, 0), gl(n, 0), gl(n, 0), gl(n, 0), gl(n, 0), gl(n, 9 === n.level ? 2 : n.strategy >= Jo || n.level < 2 ? 4 : 0), gl(n, 3), n.status = ol, pl(REVISION), 0 !== n.pending)
                        return n.last_flush = -1, Qo;
                if (69 === n.status) {
                    if (n.gzhead.extra) {
                        let t = n.pending, i = (65535 & n.gzhead.extra.length) - n.gzindex;
                        for (; n.pending + i > n.pending_buf_size;) {
                            let r = n.pending_buf_size - n.pending;
                            if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + r), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > t && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending - t, t)), n.gzindex += r, pl(REVISION), 0 !== n.pending)
                                return n.last_flush = -1, Qo;
                            t = 0, i -= r;
                        }
                        let r = new Uint8Array(n.gzhead.extra);
                        n.pending_buf.set(r.subarray(n.gzindex, n.gzindex + i), n.pending), n.pending += i, n.gzhead.hcrc && n.pending > t && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending - t, t)), n.gzindex = 0;
                    }
                    n.status = 73;
                }
                if (73 === n.status) {
                    if (n.gzhead.name) {
                        let t, i = n.pending;
                        do {
                            if (n.pending === n.pending_buf_size) {
                                if (n.gzhead.hcrc && n.pending > i && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending - i, i)), pl(REVISION), 0 !== n.pending)
                                    return n.last_flush = -1, Qo;
                                i = 0;
                            }
                            t = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, gl(n, t);
                        } while (0 !== t);
                        n.gzhead.hcrc && n.pending > i && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending - i, i)), n.gzindex = 0;
                    }
                    n.status = 91;
                }
                if (91 === n.status) {
                    if (n.gzhead.comment) {
                        let t, i = n.pending;
                        do {
                            if (n.pending === n.pending_buf_size) {
                                if (n.gzhead.hcrc && n.pending > i && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending - i, i)), pl(REVISION), 0 !== n.pending)
                                    return n.last_flush = -1, Qo;
                                i = 0;
                            }
                            t = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, gl(n, t);
                        } while (0 !== t);
                        n.gzhead.hcrc && n.pending > i && (REVISION.adler = Bo(REVISION.adler, n.pending_buf, n.pending - i, i));
                    }
                    n.status = 103;
                }
                if (103 === n.status) {
                    if (n.gzhead.hcrc) {
                        if (n.pending + 2 > n.pending_buf_size && (pl(REVISION), 0 !== n.pending))
                            return n.last_flush = -1, Qo;
                        gl(n, 255 & REVISION.adler), gl(n, REVISION.adler >> 8 & 255), REVISION.adler = 0;
                    }
                    if (n.status = ol, pl(REVISION), 0 !== n.pending)
                        return n.last_flush = -1, Qo;
                }
                if (0 !== REVISION.avail_in || 0 !== n.lookahead || t !== zo && n.status !== ll) {
                    let i = 0 === n.level ? yl(n, t) : n.strategy === Jo ? ((REVISION, t) => {
                        let n;
                        for (;;) {
                            if (0 === REVISION.lookahead && (wl(REVISION), 0 === REVISION.lookahead)) {
                                if (t === zo)
                                    return 1;
                                break;
                            }
                            if (REVISION.match_length = 0, n = Fo(REVISION, 0, REVISION.window[REVISION.strstart]), REVISION.lookahead--, REVISION.strstart++, n && (ml(REVISION, !1), 0 === REVISION.strm.avail_out))
                                return 1;
                        }
                        return REVISION.insert = 0, t === Vo ? (ml(REVISION, !0), 0 === REVISION.strm.avail_out ? 3 : 4) : REVISION.sym_next && (ml(REVISION, !1), 0 === REVISION.strm.avail_out) ? 1 : 2;
                    })(n, t) : n.strategy === $o ? ((REVISION, t) => {
                        let n, i, r, AddEquation;
                        const SubtractEquation = REVISION.window;
                        for (;;) {
                            if (REVISION.lookahead <= rl) {
                                if (wl(REVISION), REVISION.lookahead <= rl && t === zo)
                                    return 1;
                                if (0 === REVISION.lookahead)
                                    break;
                            }
                            if (REVISION.match_length = 0, REVISION.lookahead >= 3 && REVISION.strstart > 0 && (r = REVISION.strstart - 1, i = SubtractEquation[r], i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r])) {
                                AddEquation = REVISION.strstart + rl;
                                do {
                                } while (i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r] && i === SubtractEquation[++r] && r < AddEquation);
                                REVISION.match_length = rl - (AddEquation - r), REVISION.match_length > REVISION.lookahead && (REVISION.match_length = REVISION.lookahead);
                            }
                            if (REVISION.match_length >= 3 ? (n = Fo(REVISION, 1, REVISION.match_length - 3), REVISION.lookahead -= REVISION.match_length, REVISION.strstart += REVISION.match_length, REVISION.match_length = 0) : (n = Fo(REVISION, 0, REVISION.window[REVISION.strstart]), REVISION.lookahead--, REVISION.strstart++), n && (ml(REVISION, !1), 0 === REVISION.strm.avail_out))
                                return 1;
                        }
                        return REVISION.insert = 0, t === Vo ? (ml(REVISION, !0), 0 === REVISION.strm.avail_out ? 3 : 4) : REVISION.sym_next && (ml(REVISION, !1), 0 === REVISION.strm.avail_out) ? 1 : 2;
                    })(n, t) : El[n.level].func(n, t);
                    if (3 !== i && 4 !== i || (n.status = ll), 1 === i || 3 === i)
                        return 0 === REVISION.avail_out && (n.last_flush = -1), Qo;
                    if (2 === i && (t === Ho ? Oo(n) : t !== Go && (No(n, 0, 0, !1), t === Wo && (dl(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), pl(REVISION), 0 === REVISION.avail_out))
                        return n.last_flush = -1, Qo;
                }
                return t !== Vo ? Qo : n.wrap <= 0 ? Xo : (2 === n.wrap ? (gl(n, 255 & REVISION.adler), gl(n, REVISION.adler >> 8 & 255), gl(n, REVISION.adler >> 16 & 255), gl(n, REVISION.adler >> 24 & 255), gl(n, 255 & REVISION.total_in), gl(n, REVISION.total_in >> 8 & 255), gl(n, REVISION.total_in >> 16 & 255), gl(n, REVISION.total_in >> 24 & 255)) : (Al(n, REVISION.adler >>> 16), Al(n, 65535 & REVISION.adler)), pl(REVISION), n.wrap > 0 && (n.wrap = -n.wrap), 0 !== n.pending ? Qo : Xo);
            },
            deflateEnd: REVISION => {
                if (Tl(REVISION))
                    return jo;
                const t = REVISION.state.status;
                return REVISION.state = null, t === ol ? cl(REVISION, qo) : Qo;
            },
            deflateSetDictionary: (REVISION, t) => {
                let n = t.length;
                if (Tl(REVISION))
                    return jo;
                const i = REVISION.state, r = i.wrap;
                if (2 === r || 1 === r && i.status !== sl || i.lookahead)
                    return jo;
                if (1 === r && (REVISION.adler = Ro(REVISION.adler, t, n, 0)), i.wrap = 0, n >= i.w_size) {
                    0 === r && (dl(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
                    let REVISION = new Uint8Array(i.w_size);
                    REVISION.set(t.subarray(n - i.w_size, n), 0), t = REVISION, n = i.w_size;
                }
                const AddEquation = REVISION.avail_in, SubtractEquation = REVISION.next_in, ReverseSubtractEquation = REVISION.input;
                for (REVISION.avail_in = n, REVISION.next_in = 0, REVISION.input = t, wl(i); i.lookahead >= 3;) {
                    let REVISION = i.strstart, t = i.lookahead - 2;
                    do {
                        i.ins_h = fl(i, i.ins_h, i.window[REVISION + 3 - 1]), i.prev[REVISION & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = REVISION, REVISION++;
                    } while (--t);
                    i.strstart = REVISION, i.lookahead = 2, wl(i);
                }
                return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, REVISION.next_in = SubtractEquation, REVISION.input = ReverseSubtractEquation, REVISION.avail_in = AddEquation, i.wrap = r, Qo;
            },
            deflateInfo: 'pako deflate (from Nodeca project)'
        };
        const Bl = (REVISION, t) => Object.prototype.hasOwnProperty.call(REVISION, t);
        var Dl = function (REVISION) {
                const t = Array.prototype.slice.call(arguments, 1);
                for (; t.length;) {
                    const n = t.shift();
                    if (n) {
                        if ('object' != typeof n)
                            throw new TypeError(n + 'must be non-object');
                        for (const t in n)
                            Bl(n, t) && (REVISION[t] = n[t]);
                    }
                }
                return REVISION;
            }, Ll = REVISION => {
                let t = 0;
                for (let n = 0, i = REVISION.length; n < i; n++)
                    t += REVISION[n].length;
                const n = new Uint8Array(t);
                for (let t = 0, i = 0, r = REVISION.length; t < r; t++) {
                    let r = REVISION[t];
                    n.set(r, i), i += r.length;
                }
                return n;
            };
        let Ul = !0;
        try {
            String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (REVISION) {
            Ul = !1;
        }
        const Nl = new Uint8Array(256);
        for (let REVISION = 0; REVISION < 256; REVISION++)
            Nl[REVISION] = REVISION >= 252 ? 6 : REVISION >= 248 ? 5 : REVISION >= 240 ? 4 : REVISION >= 224 ? 3 : REVISION >= 192 ? 2 : 1;
        Nl[254] = Nl[254] = 1;
        var kl = REVISION => {
                if ('function' == typeof TextEncoder && TextEncoder.prototype.encode)
                    return new TextEncoder().encode(REVISION);
                let t, n, i, r, AddEquation, SubtractEquation = REVISION.length, ReverseSubtractEquation = 0;
                for (r = 0; r < SubtractEquation; r++)
                    n = REVISION.charCodeAt(r), 55296 == (64512 & n) && r + 1 < SubtractEquation && (i = REVISION.charCodeAt(r + 1), 56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320), r++)), ReverseSubtractEquation += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
                for (t = new Uint8Array(ReverseSubtractEquation), AddEquation = 0, r = 0; AddEquation < ReverseSubtractEquation; r++)
                    n = REVISION.charCodeAt(r), 55296 == (64512 & n) && r + 1 < SubtractEquation && (i = REVISION.charCodeAt(r + 1), 56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320), r++)), n < 128 ? t[AddEquation++] = n : n < 2048 ? (t[AddEquation++] = 192 | n >>> 6, t[AddEquation++] = 128 | 63 & n) : n < 65536 ? (t[AddEquation++] = 224 | n >>> 12, t[AddEquation++] = 128 | n >>> 6 & 63, t[AddEquation++] = 128 | 63 & n) : (t[AddEquation++] = 240 | n >>> 18, t[AddEquation++] = 128 | n >>> 12 & 63, t[AddEquation++] = 128 | n >>> 6 & 63, t[AddEquation++] = 128 | 63 & n);
                return t;
            }, Fl = (REVISION, t) => {
                const n = t || REVISION.length;
                if ('function' == typeof TextDecoder && TextDecoder.prototype.decode)
                    return new TextDecoder().decode(REVISION.subarray(0, t));
                let i, r;
                const AddEquation = new Array(2 * n);
                for (r = 0, i = 0; i < n;) {
                    let t = REVISION[i++];
                    if (t < 128) {
                        AddEquation[r++] = t;
                        continue;
                    }
                    let SubtractEquation = Nl[t];
                    if (SubtractEquation > 4)
                        AddEquation[r++] = 65533, i += SubtractEquation - 1;
                    else {
                        for (t &= 2 === SubtractEquation ? 31 : 3 === SubtractEquation ? 15 : 7; SubtractEquation > 1 && i < n;)
                            t = t << 6 | 63 & REVISION[i++], SubtractEquation--;
                        SubtractEquation > 1 ? AddEquation[r++] = 65533 : t < 65536 ? AddEquation[r++] = t : (t -= 65536, AddEquation[r++] = 55296 | t >> 10 & 1023, AddEquation[r++] = 56320 | 1023 & t);
                    }
                }
                return ((REVISION, t) => {
                    if (t < 65534 && REVISION.subarray && Ul)
                        return String.fromCharCode.apply(null, REVISION.length === t ? REVISION : REVISION.subarray(0, t));
                    let n = '';
                    for (let i = 0; i < t; i++)
                        n += String.fromCharCode(REVISION[i]);
                    return n;
                })(AddEquation, r);
            }, Ol = (REVISION, t) => {
                (t = t || REVISION.length) > REVISION.length && (t = REVISION.length);
                let n = t - 1;
                for (; n >= 0 && 128 == (192 & REVISION[n]);)
                    n--;
                return n < 0 || 0 === n ? t : n + Nl[REVISION[n]] > t ? n : t;
            };
        var zl = function () {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = '', this.state = null, this.data_type = 2, this.adler = 0;
        };
        const Hl = Object.prototype.toString, {
                Z_NO_FLUSH: Wl,
                Z_SYNC_FLUSH: Vl,
                Z_FULL_FLUSH: Gl,
                Z_FINISH: Ql,
                Z_OK: Xl,
                Z_STREAM_END: jl,
                Z_DEFAULT_COMPRESSION: ql,
                Z_DEFAULT_STRATEGY: Yl,
                Z_DEFLATED: Kl
            } = Lo;
        function Zl(REVISION) {
            this.options = Dl({
                level: ql,
                method: Kl,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Yl
            }, REVISION || {});
            let t = this.options;
            t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = '', this.ended = !1, this.chunks = [], this.strm = new zl(), this.strm.avail_out = 0;
            let n = Pl.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
            if (n !== Xl)
                throw new Error(Do[n]);
            if (t.header && Pl.deflateSetHeader(this.strm, t.header), t.dictionary) {
                let REVISION;
                if (REVISION = 'string' == typeof t.dictionary ? kl(t.dictionary) : '[object ArrayBuffer]' === Hl.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, n = Pl.deflateSetDictionary(this.strm, REVISION), n !== Xl)
                    throw new Error(Do[n]);
                this._dict_set = !0;
            }
        }
        function Jl(REVISION, t) {
            const n = new Zl(t);
            if (n.push(REVISION, !0), n.err)
                throw n.msg || Do[n.err];
            return n.result;
        }
        Zl.prototype.push = function (REVISION, t) {
            const n = this.strm, i = this.options.chunkSize;
            let r, AddEquation;
            if (this.ended)
                return !1;
            for (AddEquation = t === ~~t ? t : !0 === t ? Ql : Wl, 'string' == typeof REVISION ? n.input = kl(REVISION) : '[object ArrayBuffer]' === Hl.call(REVISION) ? n.input = new Uint8Array(REVISION) : n.input = REVISION, n.next_in = 0, n.avail_in = n.input.length;;)
                if (0 === n.avail_out && (n.output = new Uint8Array(i), n.next_out = 0, n.avail_out = i), (AddEquation === Vl || AddEquation === Gl) && n.avail_out <= 6)
                    this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
                else {
                    if (r = Pl.deflate(n, AddEquation), r === jl)
                        return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), r = Pl.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === Xl;
                    if (0 !== n.avail_out) {
                        if (AddEquation > 0 && n.next_out > 0)
                            this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
                        else if (0 === n.avail_in)
                            break;
                    } else
                        this.onData(n.output);
                }
            return !0;
        }, Zl.prototype.onData = function (REVISION) {
            this.chunks.push(REVISION);
        }, Zl.prototype.onEnd = function (REVISION) {
            REVISION === Xl && (this.result = Ll(this.chunks)), this.chunks = [], this.err = REVISION, this.msg = this.strm.msg;
        };
        var $l = {
            Deflate: Zl,
            deflate: Jl,
            deflateRaw: function (REVISION, t) {
                return (t = t || {}).raw = !0, Jl(REVISION, t);
            },
            gzip: function (REVISION, t) {
                return (t = t || {}).gzip = !0, Jl(REVISION, t);
            },
            constants: Lo
        };
        const ec = 16209;
        var tc = function (REVISION, t) {
            let n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, ConstantColorFactor, OneMinusConstantColorFactor, ConstantAlphaFactor, OneMinusConstantAlphaFactor, b, aspect, CullFaceFront;
            const LessEqualDepth = REVISION.state;
            n = REVISION.next_in, aspect = REVISION.input, i = n + (REVISION.avail_in - 5), r = REVISION.next_out, CullFaceFront = REVISION.output, AddEquation = r - (t - REVISION.avail_out), SubtractEquation = r + (REVISION.avail_out - 257), ReverseSubtractEquation = LessEqualDepth.dmax, ZeroFactor = LessEqualDepth.wsize, OneFactor = LessEqualDepth.whave, SrcColorFactor = LessEqualDepth.wnext, OneMinusSrcColorFactor = LessEqualDepth.window, SrcAlphaFactor = LessEqualDepth.hold, OneMinusSrcAlphaFactor = LessEqualDepth.bits, DstAlphaFactor = LessEqualDepth.lencode, OneMinusDstAlphaFactor = LessEqualDepth.distcode, DstColorFactor = (1 << LessEqualDepth.lenbits) - 1, OneMinusDstColorFactor = (1 << LessEqualDepth.distbits) - 1;
            REVISION:
                do {
                    OneMinusSrcAlphaFactor < 15 && (SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8, SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8), SrcAlphaSaturateFactor = DstAlphaFactor[SrcAlphaFactor & DstColorFactor];
                    t:
                        for (;;) {
                            if (ConstantColorFactor = SrcAlphaSaturateFactor >>> 24, SrcAlphaFactor >>>= ConstantColorFactor, OneMinusSrcAlphaFactor -= ConstantColorFactor, ConstantColorFactor = SrcAlphaSaturateFactor >>> 16 & 255, 0 === ConstantColorFactor)
                                CullFaceFront[r++] = 65535 & SrcAlphaSaturateFactor;
                            else {
                                if (!(16 & ConstantColorFactor)) {
                                    if (64 & ConstantColorFactor) {
                                        if (32 & ConstantColorFactor) {
                                            LessEqualDepth.mode = 16191;
                                            break REVISION;
                                        }
                                        REVISION.msg = 'invalid literal/length code', LessEqualDepth.mode = ec;
                                        break REVISION;
                                    }
                                    SrcAlphaSaturateFactor = DstAlphaFactor[(65535 & SrcAlphaSaturateFactor) + (SrcAlphaFactor & (1 << ConstantColorFactor) - 1)];
                                    continue t;
                                }
                                for (OneMinusConstantColorFactor = 65535 & SrcAlphaSaturateFactor, ConstantColorFactor &= 15, ConstantColorFactor && (OneMinusSrcAlphaFactor < ConstantColorFactor && (SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8), OneMinusConstantColorFactor += SrcAlphaFactor & (1 << ConstantColorFactor) - 1, SrcAlphaFactor >>>= ConstantColorFactor, OneMinusSrcAlphaFactor -= ConstantColorFactor), OneMinusSrcAlphaFactor < 15 && (SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8, SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8), SrcAlphaSaturateFactor = OneMinusDstAlphaFactor[SrcAlphaFactor & OneMinusDstColorFactor];;) {
                                    if (ConstantColorFactor = SrcAlphaSaturateFactor >>> 24, SrcAlphaFactor >>>= ConstantColorFactor, OneMinusSrcAlphaFactor -= ConstantColorFactor, ConstantColorFactor = SrcAlphaSaturateFactor >>> 16 & 255, 16 & ConstantColorFactor) {
                                        if (ConstantAlphaFactor = 65535 & SrcAlphaSaturateFactor, ConstantColorFactor &= 15, OneMinusSrcAlphaFactor < ConstantColorFactor && (SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8, OneMinusSrcAlphaFactor < ConstantColorFactor && (SrcAlphaFactor += aspect[n++] << OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor += 8)), ConstantAlphaFactor += SrcAlphaFactor & (1 << ConstantColorFactor) - 1, ConstantAlphaFactor > ReverseSubtractEquation) {
                                            REVISION.msg = 'invalid distance too far back', LessEqualDepth.mode = ec;
                                            break REVISION;
                                        }
                                        if (SrcAlphaFactor >>>= ConstantColorFactor, OneMinusSrcAlphaFactor -= ConstantColorFactor, ConstantColorFactor = r - AddEquation, ConstantAlphaFactor > ConstantColorFactor) {
                                            if (ConstantColorFactor = ConstantAlphaFactor - ConstantColorFactor, ConstantColorFactor > OneFactor && LessEqualDepth.sane) {
                                                REVISION.msg = 'invalid distance too far back', LessEqualDepth.mode = ec;
                                                break REVISION;
                                            }
                                            if (OneMinusConstantAlphaFactor = 0, b = OneMinusSrcColorFactor, 0 === SrcColorFactor) {
                                                if (OneMinusConstantAlphaFactor += ZeroFactor - ConstantColorFactor, ConstantColorFactor < OneMinusConstantColorFactor) {
                                                    OneMinusConstantColorFactor -= ConstantColorFactor;
                                                    do {
                                                        CullFaceFront[r++] = OneMinusSrcColorFactor[OneMinusConstantAlphaFactor++];
                                                    } while (--ConstantColorFactor);
                                                    OneMinusConstantAlphaFactor = r - ConstantAlphaFactor, b = CullFaceFront;
                                                }
                                            } else if (SrcColorFactor < ConstantColorFactor) {
                                                if (OneMinusConstantAlphaFactor += ZeroFactor + SrcColorFactor - ConstantColorFactor, ConstantColorFactor -= SrcColorFactor, ConstantColorFactor < OneMinusConstantColorFactor) {
                                                    OneMinusConstantColorFactor -= ConstantColorFactor;
                                                    do {
                                                        CullFaceFront[r++] = OneMinusSrcColorFactor[OneMinusConstantAlphaFactor++];
                                                    } while (--ConstantColorFactor);
                                                    if (OneMinusConstantAlphaFactor = 0, SrcColorFactor < OneMinusConstantColorFactor) {
                                                        ConstantColorFactor = SrcColorFactor, OneMinusConstantColorFactor -= ConstantColorFactor;
                                                        do {
                                                            CullFaceFront[r++] = OneMinusSrcColorFactor[OneMinusConstantAlphaFactor++];
                                                        } while (--ConstantColorFactor);
                                                        OneMinusConstantAlphaFactor = r - ConstantAlphaFactor, b = CullFaceFront;
                                                    }
                                                }
                                            } else if (OneMinusConstantAlphaFactor += SrcColorFactor - ConstantColorFactor, ConstantColorFactor < OneMinusConstantColorFactor) {
                                                OneMinusConstantColorFactor -= ConstantColorFactor;
                                                do {
                                                    CullFaceFront[r++] = OneMinusSrcColorFactor[OneMinusConstantAlphaFactor++];
                                                } while (--ConstantColorFactor);
                                                OneMinusConstantAlphaFactor = r - ConstantAlphaFactor, b = CullFaceFront;
                                            }
                                            for (; OneMinusConstantColorFactor > 2;)
                                                CullFaceFront[r++] = b[OneMinusConstantAlphaFactor++], CullFaceFront[r++] = b[OneMinusConstantAlphaFactor++], CullFaceFront[r++] = b[OneMinusConstantAlphaFactor++], OneMinusConstantColorFactor -= 3;
                                            OneMinusConstantColorFactor && (CullFaceFront[r++] = b[OneMinusConstantAlphaFactor++], OneMinusConstantColorFactor > 1 && (CullFaceFront[r++] = b[OneMinusConstantAlphaFactor++]));
                                        } else {
                                            OneMinusConstantAlphaFactor = r - ConstantAlphaFactor;
                                            do {
                                                CullFaceFront[r++] = CullFaceFront[OneMinusConstantAlphaFactor++], CullFaceFront[r++] = CullFaceFront[OneMinusConstantAlphaFactor++], CullFaceFront[r++] = CullFaceFront[OneMinusConstantAlphaFactor++], OneMinusConstantColorFactor -= 3;
                                            } while (OneMinusConstantColorFactor > 2);
                                            OneMinusConstantColorFactor && (CullFaceFront[r++] = CullFaceFront[OneMinusConstantAlphaFactor++], OneMinusConstantColorFactor > 1 && (CullFaceFront[r++] = CullFaceFront[OneMinusConstantAlphaFactor++]));
                                        }
                                        break;
                                    }
                                    if (64 & ConstantColorFactor) {
                                        REVISION.msg = 'invalid distance code', LessEqualDepth.mode = ec;
                                        break REVISION;
                                    }
                                    SrcAlphaSaturateFactor = OneMinusDstAlphaFactor[(65535 & SrcAlphaSaturateFactor) + (SrcAlphaFactor & (1 << ConstantColorFactor) - 1)];
                                }
                            }
                            break;
                        }
                } while (n < i && r < SubtractEquation);
            OneMinusConstantColorFactor = OneMinusSrcAlphaFactor >> 3, n -= OneMinusConstantColorFactor, OneMinusSrcAlphaFactor -= OneMinusConstantColorFactor << 3, SrcAlphaFactor &= (1 << OneMinusSrcAlphaFactor) - 1, REVISION.next_in = n, REVISION.next_out = r, REVISION.avail_in = n < i ? i - n + 5 : 5 - (n - i), REVISION.avail_out = r < SubtractEquation ? SubtractEquation - r + 257 : 257 - (r - SubtractEquation), LessEqualDepth.hold = SrcAlphaFactor, LessEqualDepth.bits = OneMinusSrcAlphaFactor;
        };
        const nc = 15, ic = new Uint16Array([
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                15,
                17,
                19,
                23,
                27,
                31,
                35,
                43,
                51,
                59,
                67,
                83,
                99,
                115,
                131,
                163,
                195,
                227,
                258,
                0,
                0
            ]), rc = new Uint8Array([
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                17,
                17,
                17,
                17,
                18,
                18,
                18,
                18,
                19,
                19,
                19,
                19,
                20,
                20,
                20,
                20,
                21,
                21,
                21,
                21,
                16,
                72,
                78
            ]), ac = new Uint16Array([
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577,
                0,
                0
            ]), sc = new Uint8Array([
                16,
                16,
                16,
                16,
                17,
                17,
                18,
                18,
                19,
                19,
                20,
                20,
                21,
                21,
                22,
                22,
                23,
                23,
                24,
                24,
                25,
                25,
                26,
                26,
                27,
                27,
                28,
                28,
                29,
                29,
                64,
                64
            ]);
        var oc = (REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) => {
            const ZeroFactor = ReverseSubtractEquation.bits;
            let OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor = 0, DstColorFactor = 0, OneMinusDstColorFactor = 0, SrcAlphaSaturateFactor = 0, ConstantColorFactor = 0, OneMinusConstantColorFactor = 0, ConstantAlphaFactor = 0, OneMinusConstantAlphaFactor = 0, b = 0, aspect = 0, CullFaceFront = null;
            const LessEqualDepth = new Uint16Array(16), MultiplyBlending = new Uint16Array(16);
            let CustomBlending, GreaterDepth, NotEqualDepth, AttachedBindMode = null;
            for (OneMinusDstAlphaFactor = 0; OneMinusDstAlphaFactor <= nc; OneMinusDstAlphaFactor++)
                LessEqualDepth[OneMinusDstAlphaFactor] = 0;
            for (DstColorFactor = 0; DstColorFactor < i; DstColorFactor++)
                LessEqualDepth[t[n + DstColorFactor]]++;
            for (ConstantColorFactor = ZeroFactor, SrcAlphaSaturateFactor = nc; SrcAlphaSaturateFactor >= 1 && 0 === LessEqualDepth[SrcAlphaSaturateFactor]; SrcAlphaSaturateFactor--);
            if (ConstantColorFactor > SrcAlphaSaturateFactor && (ConstantColorFactor = SrcAlphaSaturateFactor), 0 === SrcAlphaSaturateFactor)
                return r[AddEquation++] = 20971520, r[AddEquation++] = 20971520, ReverseSubtractEquation.bits = 1, 0;
            for (OneMinusDstColorFactor = 1; OneMinusDstColorFactor < SrcAlphaSaturateFactor && 0 === LessEqualDepth[OneMinusDstColorFactor]; OneMinusDstColorFactor++);
            for (ConstantColorFactor < OneMinusDstColorFactor && (ConstantColorFactor = OneMinusDstColorFactor), OneMinusConstantAlphaFactor = 1, OneMinusDstAlphaFactor = 1; OneMinusDstAlphaFactor <= nc; OneMinusDstAlphaFactor++)
                if (OneMinusConstantAlphaFactor <<= 1, OneMinusConstantAlphaFactor -= LessEqualDepth[OneMinusDstAlphaFactor], OneMinusConstantAlphaFactor < 0)
                    return -1;
            if (OneMinusConstantAlphaFactor > 0 && (0 === REVISION || 1 !== SrcAlphaSaturateFactor))
                return -1;
            for (MultiplyBlending[1] = 0, OneMinusDstAlphaFactor = 1; OneMinusDstAlphaFactor < nc; OneMinusDstAlphaFactor++)
                MultiplyBlending[OneMinusDstAlphaFactor + 1] = MultiplyBlending[OneMinusDstAlphaFactor] + LessEqualDepth[OneMinusDstAlphaFactor];
            for (DstColorFactor = 0; DstColorFactor < i; DstColorFactor++)
                0 !== t[n + DstColorFactor] && (SubtractEquation[MultiplyBlending[t[n + DstColorFactor]]++] = DstColorFactor);
            if (0 === REVISION ? (CullFaceFront = AttachedBindMode = SubtractEquation, DstAlphaFactor = 20) : 1 === REVISION ? (CullFaceFront = ic, AttachedBindMode = rc, DstAlphaFactor = 257) : (CullFaceFront = ac, AttachedBindMode = sc, DstAlphaFactor = 0), aspect = 0, DstColorFactor = 0, OneMinusDstAlphaFactor = OneMinusDstColorFactor, OneMinusSrcAlphaFactor = AddEquation, OneMinusConstantColorFactor = ConstantColorFactor, ConstantAlphaFactor = 0, OneMinusSrcColorFactor = -1, b = 1 << ConstantColorFactor, SrcAlphaFactor = b - 1, 1 === REVISION && b > 852 || 2 === REVISION && b > 592)
                return 1;
            for (;;) {
                CustomBlending = OneMinusDstAlphaFactor - ConstantAlphaFactor, SubtractEquation[DstColorFactor] + 1 < DstAlphaFactor ? (GreaterDepth = 0, NotEqualDepth = SubtractEquation[DstColorFactor]) : SubtractEquation[DstColorFactor] >= DstAlphaFactor ? (GreaterDepth = AttachedBindMode[SubtractEquation[DstColorFactor] - DstAlphaFactor], NotEqualDepth = CullFaceFront[SubtractEquation[DstColorFactor] - DstAlphaFactor]) : (GreaterDepth = 96, NotEqualDepth = 0), OneFactor = 1 << OneMinusDstAlphaFactor - ConstantAlphaFactor, SrcColorFactor = 1 << OneMinusConstantColorFactor, OneMinusDstColorFactor = SrcColorFactor;
                do {
                    SrcColorFactor -= OneFactor, r[OneMinusSrcAlphaFactor + (aspect >> ConstantAlphaFactor) + SrcColorFactor] = CustomBlending << 24 | GreaterDepth << 16 | NotEqualDepth;
                } while (0 !== SrcColorFactor);
                for (OneFactor = 1 << OneMinusDstAlphaFactor - 1; aspect & OneFactor;)
                    OneFactor >>= 1;
                if (0 !== OneFactor ? (aspect &= OneFactor - 1, aspect += OneFactor) : aspect = 0, DstColorFactor++, 0 == --LessEqualDepth[OneMinusDstAlphaFactor]) {
                    if (OneMinusDstAlphaFactor === SrcAlphaSaturateFactor)
                        break;
                    OneMinusDstAlphaFactor = t[n + SubtractEquation[DstColorFactor]];
                }
                if (OneMinusDstAlphaFactor > ConstantColorFactor && (aspect & SrcAlphaFactor) !== OneMinusSrcColorFactor) {
                    for (0 === ConstantAlphaFactor && (ConstantAlphaFactor = ConstantColorFactor), OneMinusSrcAlphaFactor += OneMinusDstColorFactor, OneMinusConstantColorFactor = OneMinusDstAlphaFactor - ConstantAlphaFactor, OneMinusConstantAlphaFactor = 1 << OneMinusConstantColorFactor; OneMinusConstantColorFactor + ConstantAlphaFactor < SrcAlphaSaturateFactor && (OneMinusConstantAlphaFactor -= LessEqualDepth[OneMinusConstantColorFactor + ConstantAlphaFactor], !(OneMinusConstantAlphaFactor <= 0));)
                        OneMinusConstantColorFactor++, OneMinusConstantAlphaFactor <<= 1;
                    if (b += 1 << OneMinusConstantColorFactor, 1 === REVISION && b > 852 || 2 === REVISION && b > 592)
                        return 1;
                    OneMinusSrcColorFactor = aspect & SrcAlphaFactor, r[OneMinusSrcColorFactor] = ConstantColorFactor << 24 | OneMinusConstantColorFactor << 16 | OneMinusSrcAlphaFactor - AddEquation;
                }
            }
            return 0 !== aspect && (r[OneMinusSrcAlphaFactor + aspect] = OneMinusDstAlphaFactor - ConstantAlphaFactor << 24 | 64 << 16), ReverseSubtractEquation.bits = ConstantColorFactor, 0;
        };
        const {
                Z_FINISH: lc,
                Z_BLOCK: cc,
                Z_TREES: hc,
                Z_OK: dc,
                Z_STREAM_END: uc,
                Z_NEED_DICT: fc,
                Z_STREAM_ERROR: pc,
                Z_DATA_ERROR: mc,
                Z_MEM_ERROR: gc,
                Z_BUF_ERROR: Ac,
                Z_DEFLATED: _c
            } = Lo, vc = 16180, wc = 16190, yc = 16191, xc = 16192, bc = 16194, Sc = 16199, Ec = 16200, Mc = 16206, Tc = 16209, Cc = REVISION => (REVISION >>> 24 & 255) + (REVISION >>> 8 & 65280) + ((65280 & REVISION) << 8) + ((255 & REVISION) << 24);
        function Ic() {
            this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        const Rc = REVISION => {
                if (!REVISION)
                    return 1;
                const t = REVISION.state;
                return !t || t.strm !== REVISION || t.mode < vc || t.mode > 16211 ? 1 : 0;
            }, Pc = REVISION => {
                if (Rc(REVISION))
                    return pc;
                const t = REVISION.state;
                return REVISION.total_in = REVISION.total_out = t.total = 0, REVISION.msg = '', t.wrap && (REVISION.adler = 1 & t.wrap), t.mode = vc, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, dc;
            }, Bc = REVISION => {
                if (Rc(REVISION))
                    return pc;
                const t = REVISION.state;
                return t.wsize = 0, t.whave = 0, t.wnext = 0, Pc(REVISION);
            }, Dc = (REVISION, t) => {
                let n;
                if (Rc(REVISION))
                    return pc;
                const i = REVISION.state;
                return t < 0 ? (n = 0, t = -t) : (n = 5 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? pc : (null !== i.window && i.wbits !== t && (i.window = null), i.wrap = n, i.wbits = t, Bc(REVISION));
            }, Lc = (REVISION, t) => {
                if (!REVISION)
                    return pc;
                const n = new Ic();
                REVISION.state = n, n.strm = REVISION, n.window = null, n.mode = vc;
                const i = Dc(REVISION, t);
                return i !== dc && (REVISION.state = null), i;
            };
        let Uc, Nc, kc = !0;
        const Fc = REVISION => {
                if (kc) {
                    Uc = new Int32Array(512), Nc = new Int32Array(32);
                    let t = 0;
                    for (; t < 144;)
                        REVISION.lens[t++] = 8;
                    for (; t < 256;)
                        REVISION.lens[t++] = 9;
                    for (; t < 280;)
                        REVISION.lens[t++] = 7;
                    for (; t < 288;)
                        REVISION.lens[t++] = 8;
                    for (oc(1, REVISION.lens, 0, 288, Uc, 0, REVISION.work, { bits: 9 }), t = 0; t < 32;)
                        REVISION.lens[t++] = 5;
                    oc(2, REVISION.lens, 0, 32, Nc, 0, REVISION.work, { bits: 5 }), kc = !1;
                }
                REVISION.lencode = Uc, REVISION.lenbits = 9, REVISION.distcode = Nc, REVISION.distbits = 5;
            }, Oc = (REVISION, t, n, i) => {
                let r;
                const AddEquation = REVISION.state;
                return null === AddEquation.window && (AddEquation.wsize = 1 << AddEquation.wbits, AddEquation.wnext = 0, AddEquation.whave = 0, AddEquation.window = new Uint8Array(AddEquation.wsize)), i >= AddEquation.wsize ? (AddEquation.window.set(t.subarray(n - AddEquation.wsize, n), 0), AddEquation.wnext = 0, AddEquation.whave = AddEquation.wsize) : (r = AddEquation.wsize - AddEquation.wnext, r > i && (r = i), AddEquation.window.set(t.subarray(n - i, n - i + r), AddEquation.wnext), (i -= r) ? (AddEquation.window.set(t.subarray(n - i, n), 0), AddEquation.wnext = i, AddEquation.whave = AddEquation.wsize) : (AddEquation.wnext += r, AddEquation.wnext === AddEquation.wsize && (AddEquation.wnext = 0), AddEquation.whave < AddEquation.wsize && (AddEquation.whave += r))), 0;
            };
        var zc = {
            inflateReset: Bc,
            inflateReset2: Dc,
            inflateResetKeep: Pc,
            inflateInit: REVISION => Lc(REVISION, 15),
            inflateInit2: Lc,
            inflate: (REVISION, t) => {
                let n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, ConstantColorFactor, OneMinusConstantColorFactor, ConstantAlphaFactor, OneMinusConstantAlphaFactor, b, aspect = 0;
                const CullFaceFront = new Uint8Array(4);
                let LessEqualDepth, MultiplyBlending;
                const CustomBlending = new Uint8Array([
                    16,
                    17,
                    18,
                    0,
                    8,
                    7,
                    9,
                    6,
                    10,
                    5,
                    11,
                    4,
                    12,
                    3,
                    13,
                    2,
                    14,
                    1,
                    15
                ]);
                if (Rc(REVISION) || !REVISION.output || !REVISION.input && 0 !== REVISION.avail_in)
                    return pc;
                n = REVISION.state, n.mode === yc && (n.mode = xc), SubtractEquation = REVISION.next_out, r = REVISION.output, ZeroFactor = REVISION.avail_out, AddEquation = REVISION.next_in, i = REVISION.input, ReverseSubtractEquation = REVISION.avail_in, OneFactor = n.hold, SrcColorFactor = n.bits, OneMinusSrcColorFactor = ReverseSubtractEquation, SrcAlphaFactor = ZeroFactor, b = dc;
                REVISION:
                    for (;;)
                        switch (n.mode) {
                        case vc:
                            if (0 === n.wrap) {
                                n.mode = xc;
                                break;
                            }
                            for (; SrcColorFactor < 16;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            if (2 & n.wrap && 35615 === OneFactor) {
                                0 === n.wbits && (n.wbits = 15), n.check = 0, CullFaceFront[0] = 255 & OneFactor, CullFaceFront[1] = OneFactor >>> 8 & 255, n.check = Bo(n.check, CullFaceFront, 2, 0), OneFactor = 0, SrcColorFactor = 0, n.mode = 16181;
                                break;
                            }
                            if (n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & OneFactor) << 8) + (OneFactor >> 8)) % 31) {
                                REVISION.msg = 'incorrect header check', n.mode = Tc;
                                break;
                            }
                            if ((15 & OneFactor) !== _c) {
                                REVISION.msg = 'unknown compression method', n.mode = Tc;
                                break;
                            }
                            if (OneFactor >>>= 4, SrcColorFactor -= 4, OneMinusConstantAlphaFactor = 8 + (15 & OneFactor), 0 === n.wbits && (n.wbits = OneMinusConstantAlphaFactor), OneMinusConstantAlphaFactor > 15 || OneMinusConstantAlphaFactor > n.wbits) {
                                REVISION.msg = 'invalid window size', n.mode = Tc;
                                break;
                            }
                            n.dmax = 1 << n.wbits, n.flags = 0, REVISION.adler = n.check = 1, n.mode = 512 & OneFactor ? 16189 : yc, OneFactor = 0, SrcColorFactor = 0;
                            break;
                        case 16181:
                            for (; SrcColorFactor < 16;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            if (n.flags = OneFactor, (255 & n.flags) !== _c) {
                                REVISION.msg = 'unknown compression method', n.mode = Tc;
                                break;
                            }
                            if (57344 & n.flags) {
                                REVISION.msg = 'unknown header flags set', n.mode = Tc;
                                break;
                            }
                            n.head && (n.head.text = OneFactor >> 8 & 1), 512 & n.flags && 4 & n.wrap && (CullFaceFront[0] = 255 & OneFactor, CullFaceFront[1] = OneFactor >>> 8 & 255, n.check = Bo(n.check, CullFaceFront, 2, 0)), OneFactor = 0, SrcColorFactor = 0, n.mode = 16182;
                        case 16182:
                            for (; SrcColorFactor < 32;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            n.head && (n.head.time = OneFactor), 512 & n.flags && 4 & n.wrap && (CullFaceFront[0] = 255 & OneFactor, CullFaceFront[1] = OneFactor >>> 8 & 255, CullFaceFront[2] = OneFactor >>> 16 & 255, CullFaceFront[3] = OneFactor >>> 24 & 255, n.check = Bo(n.check, CullFaceFront, 4, 0)), OneFactor = 0, SrcColorFactor = 0, n.mode = 16183;
                        case 16183:
                            for (; SrcColorFactor < 16;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            n.head && (n.head.xflags = 255 & OneFactor, n.head.os = OneFactor >> 8), 512 & n.flags && 4 & n.wrap && (CullFaceFront[0] = 255 & OneFactor, CullFaceFront[1] = OneFactor >>> 8 & 255, n.check = Bo(n.check, CullFaceFront, 2, 0)), OneFactor = 0, SrcColorFactor = 0, n.mode = 16184;
                        case 16184:
                            if (1024 & n.flags) {
                                for (; SrcColorFactor < 16;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                n.length = OneFactor, n.head && (n.head.extra_len = OneFactor), 512 & n.flags && 4 & n.wrap && (CullFaceFront[0] = 255 & OneFactor, CullFaceFront[1] = OneFactor >>> 8 & 255, n.check = Bo(n.check, CullFaceFront, 2, 0)), OneFactor = 0, SrcColorFactor = 0;
                            } else
                                n.head && (n.head.extra = null);
                            n.mode = 16185;
                        case 16185:
                            if (1024 & n.flags && (OneMinusSrcAlphaFactor = n.length, OneMinusSrcAlphaFactor > ReverseSubtractEquation && (OneMinusSrcAlphaFactor = ReverseSubtractEquation), OneMinusSrcAlphaFactor && (n.head && (OneMinusConstantAlphaFactor = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(i.subarray(AddEquation, AddEquation + OneMinusSrcAlphaFactor), OneMinusConstantAlphaFactor)), 512 & n.flags && 4 & n.wrap && (n.check = Bo(n.check, i, OneMinusSrcAlphaFactor, AddEquation)), ReverseSubtractEquation -= OneMinusSrcAlphaFactor, AddEquation += OneMinusSrcAlphaFactor, n.length -= OneMinusSrcAlphaFactor), n.length))
                                break REVISION;
                            n.length = 0, n.mode = 16186;
                        case 16186:
                            if (2048 & n.flags) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                OneMinusSrcAlphaFactor = 0;
                                do {
                                    OneMinusConstantAlphaFactor = i[AddEquation + OneMinusSrcAlphaFactor++], n.head && OneMinusConstantAlphaFactor && n.length < 65536 && (n.head.name += String.fromCharCode(OneMinusConstantAlphaFactor));
                                } while (OneMinusConstantAlphaFactor && OneMinusSrcAlphaFactor < ReverseSubtractEquation);
                                if (512 & n.flags && 4 & n.wrap && (n.check = Bo(n.check, i, OneMinusSrcAlphaFactor, AddEquation)), ReverseSubtractEquation -= OneMinusSrcAlphaFactor, AddEquation += OneMinusSrcAlphaFactor, OneMinusConstantAlphaFactor)
                                    break REVISION;
                            } else
                                n.head && (n.head.name = null);
                            n.length = 0, n.mode = 16187;
                        case 16187:
                            if (4096 & n.flags) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                OneMinusSrcAlphaFactor = 0;
                                do {
                                    OneMinusConstantAlphaFactor = i[AddEquation + OneMinusSrcAlphaFactor++], n.head && OneMinusConstantAlphaFactor && n.length < 65536 && (n.head.comment += String.fromCharCode(OneMinusConstantAlphaFactor));
                                } while (OneMinusConstantAlphaFactor && OneMinusSrcAlphaFactor < ReverseSubtractEquation);
                                if (512 & n.flags && 4 & n.wrap && (n.check = Bo(n.check, i, OneMinusSrcAlphaFactor, AddEquation)), ReverseSubtractEquation -= OneMinusSrcAlphaFactor, AddEquation += OneMinusSrcAlphaFactor, OneMinusConstantAlphaFactor)
                                    break REVISION;
                            } else
                                n.head && (n.head.comment = null);
                            n.mode = 16188;
                        case 16188:
                            if (512 & n.flags) {
                                for (; SrcColorFactor < 16;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                if (4 & n.wrap && OneFactor !== (65535 & n.check)) {
                                    REVISION.msg = 'header crc mismatch', n.mode = Tc;
                                    break;
                                }
                                OneFactor = 0, SrcColorFactor = 0;
                            }
                            n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), REVISION.adler = n.check = 0, n.mode = yc;
                            break;
                        case 16189:
                            for (; SrcColorFactor < 32;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            REVISION.adler = n.check = Cc(OneFactor), OneFactor = 0, SrcColorFactor = 0, n.mode = wc;
                        case wc:
                            if (0 === n.havedict)
                                return REVISION.next_out = SubtractEquation, REVISION.avail_out = ZeroFactor, REVISION.next_in = AddEquation, REVISION.avail_in = ReverseSubtractEquation, n.hold = OneFactor, n.bits = SrcColorFactor, fc;
                            REVISION.adler = n.check = 1, n.mode = yc;
                        case yc:
                            if (t === cc || t === hc)
                                break REVISION;
                        case xc:
                            if (n.last) {
                                OneFactor >>>= 7 & SrcColorFactor, SrcColorFactor -= 7 & SrcColorFactor, n.mode = Mc;
                                break;
                            }
                            for (; SrcColorFactor < 3;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            switch (n.last = 1 & OneFactor, OneFactor >>>= 1, SrcColorFactor -= 1, 3 & OneFactor) {
                            case 0:
                                n.mode = 16193;
                                break;
                            case 1:
                                if (Fc(n), n.mode = Sc, t === hc) {
                                    OneFactor >>>= 2, SrcColorFactor -= 2;
                                    break REVISION;
                                }
                                break;
                            case 2:
                                n.mode = 16196;
                                break;
                            case 3:
                                REVISION.msg = 'invalid block type', n.mode = Tc;
                            }
                            OneFactor >>>= 2, SrcColorFactor -= 2;
                            break;
                        case 16193:
                            for (OneFactor >>>= 7 & SrcColorFactor, SrcColorFactor -= 7 & SrcColorFactor; SrcColorFactor < 32;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            if ((65535 & OneFactor) != (OneFactor >>> 16 ^ 65535)) {
                                REVISION.msg = 'invalid stored block lengths', n.mode = Tc;
                                break;
                            }
                            if (n.length = 65535 & OneFactor, OneFactor = 0, SrcColorFactor = 0, n.mode = bc, t === hc)
                                break REVISION;
                        case bc:
                            n.mode = 16195;
                        case 16195:
                            if (OneMinusSrcAlphaFactor = n.length, OneMinusSrcAlphaFactor) {
                                if (OneMinusSrcAlphaFactor > ReverseSubtractEquation && (OneMinusSrcAlphaFactor = ReverseSubtractEquation), OneMinusSrcAlphaFactor > ZeroFactor && (OneMinusSrcAlphaFactor = ZeroFactor), 0 === OneMinusSrcAlphaFactor)
                                    break REVISION;
                                r.set(i.subarray(AddEquation, AddEquation + OneMinusSrcAlphaFactor), SubtractEquation), ReverseSubtractEquation -= OneMinusSrcAlphaFactor, AddEquation += OneMinusSrcAlphaFactor, ZeroFactor -= OneMinusSrcAlphaFactor, SubtractEquation += OneMinusSrcAlphaFactor, n.length -= OneMinusSrcAlphaFactor;
                                break;
                            }
                            n.mode = yc;
                            break;
                        case 16196:
                            for (; SrcColorFactor < 14;) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            if (n.nlen = 257 + (31 & OneFactor), OneFactor >>>= 5, SrcColorFactor -= 5, n.ndist = 1 + (31 & OneFactor), OneFactor >>>= 5, SrcColorFactor -= 5, n.ncode = 4 + (15 & OneFactor), OneFactor >>>= 4, SrcColorFactor -= 4, n.nlen > 286 || n.ndist > 30) {
                                REVISION.msg = 'too many length or distance symbols', n.mode = Tc;
                                break;
                            }
                            n.have = 0, n.mode = 16197;
                        case 16197:
                            for (; n.have < n.ncode;) {
                                for (; SrcColorFactor < 3;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                n.lens[CustomBlending[n.have++]] = 7 & OneFactor, OneFactor >>>= 3, SrcColorFactor -= 3;
                            }
                            for (; n.have < 19;)
                                n.lens[CustomBlending[n.have++]] = 0;
                            if (n.lencode = n.lendyn, n.lenbits = 7, LessEqualDepth = { bits: n.lenbits }, b = oc(0, n.lens, 0, 19, n.lencode, 0, n.work, LessEqualDepth), n.lenbits = LessEqualDepth.bits, b) {
                                REVISION.msg = 'invalid code lengths set', n.mode = Tc;
                                break;
                            }
                            n.have = 0, n.mode = 16198;
                        case 16198:
                            for (; n.have < n.nlen + n.ndist;) {
                                for (; aspect = n.lencode[OneFactor & (1 << n.lenbits) - 1], DstColorFactor = aspect >>> 24, OneMinusDstColorFactor = aspect >>> 16 & 255, SrcAlphaSaturateFactor = 65535 & aspect, !(DstColorFactor <= SrcColorFactor);) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                if (SrcAlphaSaturateFactor < 16)
                                    OneFactor >>>= DstColorFactor, SrcColorFactor -= DstColorFactor, n.lens[n.have++] = SrcAlphaSaturateFactor;
                                else {
                                    if (16 === SrcAlphaSaturateFactor) {
                                        for (MultiplyBlending = DstColorFactor + 2; SrcColorFactor < MultiplyBlending;) {
                                            if (0 === ReverseSubtractEquation)
                                                break REVISION;
                                            ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                        }
                                        if (OneFactor >>>= DstColorFactor, SrcColorFactor -= DstColorFactor, 0 === n.have) {
                                            REVISION.msg = 'invalid bit length repeat', n.mode = Tc;
                                            break;
                                        }
                                        OneMinusConstantAlphaFactor = n.lens[n.have - 1], OneMinusSrcAlphaFactor = 3 + (3 & OneFactor), OneFactor >>>= 2, SrcColorFactor -= 2;
                                    } else if (17 === SrcAlphaSaturateFactor) {
                                        for (MultiplyBlending = DstColorFactor + 3; SrcColorFactor < MultiplyBlending;) {
                                            if (0 === ReverseSubtractEquation)
                                                break REVISION;
                                            ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                        }
                                        OneFactor >>>= DstColorFactor, SrcColorFactor -= DstColorFactor, OneMinusConstantAlphaFactor = 0, OneMinusSrcAlphaFactor = 3 + (7 & OneFactor), OneFactor >>>= 3, SrcColorFactor -= 3;
                                    } else {
                                        for (MultiplyBlending = DstColorFactor + 7; SrcColorFactor < MultiplyBlending;) {
                                            if (0 === ReverseSubtractEquation)
                                                break REVISION;
                                            ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                        }
                                        OneFactor >>>= DstColorFactor, SrcColorFactor -= DstColorFactor, OneMinusConstantAlphaFactor = 0, OneMinusSrcAlphaFactor = 11 + (127 & OneFactor), OneFactor >>>= 7, SrcColorFactor -= 7;
                                    }
                                    if (n.have + OneMinusSrcAlphaFactor > n.nlen + n.ndist) {
                                        REVISION.msg = 'invalid bit length repeat', n.mode = Tc;
                                        break;
                                    }
                                    for (; OneMinusSrcAlphaFactor--;)
                                        n.lens[n.have++] = OneMinusConstantAlphaFactor;
                                }
                            }
                            if (n.mode === Tc)
                                break;
                            if (0 === n.lens[256]) {
                                REVISION.msg = 'invalid code -- missing end-of-block', n.mode = Tc;
                                break;
                            }
                            if (n.lenbits = 9, LessEqualDepth = { bits: n.lenbits }, b = oc(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, LessEqualDepth), n.lenbits = LessEqualDepth.bits, b) {
                                REVISION.msg = 'invalid literal/lengths set', n.mode = Tc;
                                break;
                            }
                            if (n.distbits = 6, n.distcode = n.distdyn, LessEqualDepth = { bits: n.distbits }, b = oc(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, LessEqualDepth), n.distbits = LessEqualDepth.bits, b) {
                                REVISION.msg = 'invalid distances set', n.mode = Tc;
                                break;
                            }
                            if (n.mode = Sc, t === hc)
                                break REVISION;
                        case Sc:
                            n.mode = Ec;
                        case Ec:
                            if (ReverseSubtractEquation >= 6 && ZeroFactor >= 258) {
                                REVISION.next_out = SubtractEquation, REVISION.avail_out = ZeroFactor, REVISION.next_in = AddEquation, REVISION.avail_in = ReverseSubtractEquation, n.hold = OneFactor, n.bits = SrcColorFactor, tc(REVISION, SrcAlphaFactor), SubtractEquation = REVISION.next_out, r = REVISION.output, ZeroFactor = REVISION.avail_out, AddEquation = REVISION.next_in, i = REVISION.input, ReverseSubtractEquation = REVISION.avail_in, OneFactor = n.hold, SrcColorFactor = n.bits, n.mode === yc && (n.back = -1);
                                break;
                            }
                            for (n.back = 0; aspect = n.lencode[OneFactor & (1 << n.lenbits) - 1], DstColorFactor = aspect >>> 24, OneMinusDstColorFactor = aspect >>> 16 & 255, SrcAlphaSaturateFactor = 65535 & aspect, !(DstColorFactor <= SrcColorFactor);) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            if (OneMinusDstColorFactor && !(240 & OneMinusDstColorFactor)) {
                                for (ConstantColorFactor = DstColorFactor, OneMinusConstantColorFactor = OneMinusDstColorFactor, ConstantAlphaFactor = SrcAlphaSaturateFactor; aspect = n.lencode[ConstantAlphaFactor + ((OneFactor & (1 << ConstantColorFactor + OneMinusConstantColorFactor) - 1) >> ConstantColorFactor)], DstColorFactor = aspect >>> 24, OneMinusDstColorFactor = aspect >>> 16 & 255, SrcAlphaSaturateFactor = 65535 & aspect, !(ConstantColorFactor + DstColorFactor <= SrcColorFactor);) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                OneFactor >>>= ConstantColorFactor, SrcColorFactor -= ConstantColorFactor, n.back += ConstantColorFactor;
                            }
                            if (OneFactor >>>= DstColorFactor, SrcColorFactor -= DstColorFactor, n.back += DstColorFactor, n.length = SrcAlphaSaturateFactor, 0 === OneMinusDstColorFactor) {
                                n.mode = 16205;
                                break;
                            }
                            if (32 & OneMinusDstColorFactor) {
                                n.back = -1, n.mode = yc;
                                break;
                            }
                            if (64 & OneMinusDstColorFactor) {
                                REVISION.msg = 'invalid literal/length code', n.mode = Tc;
                                break;
                            }
                            n.extra = 15 & OneMinusDstColorFactor, n.mode = 16201;
                        case 16201:
                            if (n.extra) {
                                for (MultiplyBlending = n.extra; SrcColorFactor < MultiplyBlending;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                n.length += OneFactor & (1 << n.extra) - 1, OneFactor >>>= n.extra, SrcColorFactor -= n.extra, n.back += n.extra;
                            }
                            n.was = n.length, n.mode = 16202;
                        case 16202:
                            for (; aspect = n.distcode[OneFactor & (1 << n.distbits) - 1], DstColorFactor = aspect >>> 24, OneMinusDstColorFactor = aspect >>> 16 & 255, SrcAlphaSaturateFactor = 65535 & aspect, !(DstColorFactor <= SrcColorFactor);) {
                                if (0 === ReverseSubtractEquation)
                                    break REVISION;
                                ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                            }
                            if (!(240 & OneMinusDstColorFactor)) {
                                for (ConstantColorFactor = DstColorFactor, OneMinusConstantColorFactor = OneMinusDstColorFactor, ConstantAlphaFactor = SrcAlphaSaturateFactor; aspect = n.distcode[ConstantAlphaFactor + ((OneFactor & (1 << ConstantColorFactor + OneMinusConstantColorFactor) - 1) >> ConstantColorFactor)], DstColorFactor = aspect >>> 24, OneMinusDstColorFactor = aspect >>> 16 & 255, SrcAlphaSaturateFactor = 65535 & aspect, !(ConstantColorFactor + DstColorFactor <= SrcColorFactor);) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                OneFactor >>>= ConstantColorFactor, SrcColorFactor -= ConstantColorFactor, n.back += ConstantColorFactor;
                            }
                            if (OneFactor >>>= DstColorFactor, SrcColorFactor -= DstColorFactor, n.back += DstColorFactor, 64 & OneMinusDstColorFactor) {
                                REVISION.msg = 'invalid distance code', n.mode = Tc;
                                break;
                            }
                            n.offset = SrcAlphaSaturateFactor, n.extra = 15 & OneMinusDstColorFactor, n.mode = 16203;
                        case 16203:
                            if (n.extra) {
                                for (MultiplyBlending = n.extra; SrcColorFactor < MultiplyBlending;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                n.offset += OneFactor & (1 << n.extra) - 1, OneFactor >>>= n.extra, SrcColorFactor -= n.extra, n.back += n.extra;
                            }
                            if (n.offset > n.dmax) {
                                REVISION.msg = 'invalid distance too far back', n.mode = Tc;
                                break;
                            }
                            n.mode = 16204;
                        case 16204:
                            if (0 === ZeroFactor)
                                break REVISION;
                            if (OneMinusSrcAlphaFactor = SrcAlphaFactor - ZeroFactor, n.offset > OneMinusSrcAlphaFactor) {
                                if (OneMinusSrcAlphaFactor = n.offset - OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor > n.whave && n.sane) {
                                    REVISION.msg = 'invalid distance too far back', n.mode = Tc;
                                    break;
                                }
                                OneMinusSrcAlphaFactor > n.wnext ? (OneMinusSrcAlphaFactor -= n.wnext, DstAlphaFactor = n.wsize - OneMinusSrcAlphaFactor) : DstAlphaFactor = n.wnext - OneMinusSrcAlphaFactor, OneMinusSrcAlphaFactor > n.length && (OneMinusSrcAlphaFactor = n.length), OneMinusDstAlphaFactor = n.window;
                            } else
                                OneMinusDstAlphaFactor = r, DstAlphaFactor = SubtractEquation - n.offset, OneMinusSrcAlphaFactor = n.length;
                            OneMinusSrcAlphaFactor > ZeroFactor && (OneMinusSrcAlphaFactor = ZeroFactor), ZeroFactor -= OneMinusSrcAlphaFactor, n.length -= OneMinusSrcAlphaFactor;
                            do {
                                r[SubtractEquation++] = OneMinusDstAlphaFactor[DstAlphaFactor++];
                            } while (--OneMinusSrcAlphaFactor);
                            0 === n.length && (n.mode = Ec);
                            break;
                        case 16205:
                            if (0 === ZeroFactor)
                                break REVISION;
                            r[SubtractEquation++] = n.length, ZeroFactor--, n.mode = Ec;
                            break;
                        case Mc:
                            if (n.wrap) {
                                for (; SrcColorFactor < 32;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor |= i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                if (SrcAlphaFactor -= ZeroFactor, REVISION.total_out += SrcAlphaFactor, n.total += SrcAlphaFactor, 4 & n.wrap && SrcAlphaFactor && (REVISION.adler = n.check = n.flags ? Bo(n.check, r, SrcAlphaFactor, SubtractEquation - SrcAlphaFactor) : Ro(n.check, r, SrcAlphaFactor, SubtractEquation - SrcAlphaFactor)), SrcAlphaFactor = ZeroFactor, 4 & n.wrap && (n.flags ? OneFactor : Cc(OneFactor)) !== n.check) {
                                    REVISION.msg = 'incorrect data check', n.mode = Tc;
                                    break;
                                }
                                OneFactor = 0, SrcColorFactor = 0;
                            }
                            n.mode = 16207;
                        case 16207:
                            if (n.wrap && n.flags) {
                                for (; SrcColorFactor < 32;) {
                                    if (0 === ReverseSubtractEquation)
                                        break REVISION;
                                    ReverseSubtractEquation--, OneFactor += i[AddEquation++] << SrcColorFactor, SrcColorFactor += 8;
                                }
                                if (4 & n.wrap && OneFactor !== (4294967295 & n.total)) {
                                    REVISION.msg = 'incorrect length check', n.mode = Tc;
                                    break;
                                }
                                OneFactor = 0, SrcColorFactor = 0;
                            }
                            n.mode = 16208;
                        case 16208:
                            b = uc;
                            break REVISION;
                        case Tc:
                            b = mc;
                            break REVISION;
                        case 16210:
                            return gc;
                        default:
                            return pc;
                        }
                return REVISION.next_out = SubtractEquation, REVISION.avail_out = ZeroFactor, REVISION.next_in = AddEquation, REVISION.avail_in = ReverseSubtractEquation, n.hold = OneFactor, n.bits = SrcColorFactor, (n.wsize || SrcAlphaFactor !== REVISION.avail_out && n.mode < Tc && (n.mode < Mc || t !== lc)) && Oc(REVISION, REVISION.output, REVISION.next_out, SrcAlphaFactor - REVISION.avail_out), OneMinusSrcColorFactor -= REVISION.avail_in, SrcAlphaFactor -= REVISION.avail_out, REVISION.total_in += OneMinusSrcColorFactor, REVISION.total_out += SrcAlphaFactor, n.total += SrcAlphaFactor, 4 & n.wrap && SrcAlphaFactor && (REVISION.adler = n.check = n.flags ? Bo(n.check, r, SrcAlphaFactor, REVISION.next_out - SrcAlphaFactor) : Ro(n.check, r, SrcAlphaFactor, REVISION.next_out - SrcAlphaFactor)), REVISION.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === yc ? 128 : 0) + (n.mode === Sc || n.mode === bc ? 256 : 0), (0 === OneMinusSrcColorFactor && 0 === SrcAlphaFactor || t === lc) && b === dc && (b = Ac), b;
            },
            inflateEnd: REVISION => {
                if (Rc(REVISION))
                    return pc;
                let t = REVISION.state;
                return t.window && (t.window = null), REVISION.state = null, dc;
            },
            inflateGetHeader: (REVISION, t) => {
                if (Rc(REVISION))
                    return pc;
                const n = REVISION.state;
                return 2 & n.wrap ? (n.head = t, t.done = !1, dc) : pc;
            },
            inflateSetDictionary: (REVISION, t) => {
                const n = t.length;
                let i, r, AddEquation;
                return Rc(REVISION) ? pc : (i = REVISION.state, 0 !== i.wrap && i.mode !== wc ? pc : i.mode === wc && (r = 1, r = Ro(r, t, n, 0), r !== i.check) ? mc : (AddEquation = Oc(REVISION, t, n, n), AddEquation ? (i.mode = 16210, gc) : (i.havedict = 1, dc)));
            },
            inflateInfo: 'pako inflate (from Nodeca project)'
        };
        var Hc = function () {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = '', this.comment = '', this.hcrc = 0, this.done = !1;
        };
        const Wc = Object.prototype.toString, {
                Z_NO_FLUSH: Vc,
                Z_FINISH: Gc,
                Z_OK: Qc,
                Z_STREAM_END: Xc,
                Z_NEED_DICT: jc,
                Z_STREAM_ERROR: qc,
                Z_DATA_ERROR: Yc,
                Z_MEM_ERROR: Kc
            } = Lo;
        function Zc(REVISION) {
            this.options = Dl({
                chunkSize: 65536,
                windowBits: 15,
                to: ''
            }, REVISION || {});
            const t = this.options;
            t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || REVISION && REVISION.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (15 & t.windowBits || (t.windowBits |= 15)), this.err = 0, this.msg = '', this.ended = !1, this.chunks = [], this.strm = new zl(), this.strm.avail_out = 0;
            let n = zc.inflateInit2(this.strm, t.windowBits);
            if (n !== Qc)
                throw new Error(Do[n]);
            if (this.header = new Hc(), zc.inflateGetHeader(this.strm, this.header), t.dictionary && ('string' == typeof t.dictionary ? t.dictionary = kl(t.dictionary) : '[object ArrayBuffer]' === Wc.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (n = zc.inflateSetDictionary(this.strm, t.dictionary), n !== Qc)))
                throw new Error(Do[n]);
        }
        function Jc(REVISION, t) {
            const n = new Zc(t);
            if (n.push(REVISION), n.err)
                throw n.msg || Do[n.err];
            return n.result;
        }
        Zc.prototype.push = function (REVISION, t) {
            const n = this.strm, i = this.options.chunkSize, r = this.options.dictionary;
            let AddEquation, SubtractEquation, ReverseSubtractEquation;
            if (this.ended)
                return !1;
            for (SubtractEquation = t === ~~t ? t : !0 === t ? Gc : Vc, '[object ArrayBuffer]' === Wc.call(REVISION) ? n.input = new Uint8Array(REVISION) : n.input = REVISION, n.next_in = 0, n.avail_in = n.input.length;;) {
                for (0 === n.avail_out && (n.output = new Uint8Array(i), n.next_out = 0, n.avail_out = i), AddEquation = zc.inflate(n, SubtractEquation), AddEquation === jc && r && (AddEquation = zc.inflateSetDictionary(n, r), AddEquation === Qc ? AddEquation = zc.inflate(n, SubtractEquation) : AddEquation === Yc && (AddEquation = jc)); n.avail_in > 0 && AddEquation === Xc && n.state.wrap > 0 && 0 !== REVISION[n.next_in];)
                    zc.inflateReset(n), AddEquation = zc.inflate(n, SubtractEquation);
                switch (AddEquation) {
                case qc:
                case Yc:
                case jc:
                case Kc:
                    return this.onEnd(AddEquation), this.ended = !0, !1;
                }
                if (ReverseSubtractEquation = n.avail_out, n.next_out && (0 === n.avail_out || AddEquation === Xc))
                    if ('string' === this.options.to) {
                        let REVISION = Ol(n.output, n.next_out), t = n.next_out - REVISION, r = Fl(n.output, REVISION);
                        n.next_out = t, n.avail_out = i - t, t && n.output.set(n.output.subarray(REVISION, REVISION + t), 0), this.onData(r);
                    } else
                        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
                if (AddEquation !== Qc || 0 !== ReverseSubtractEquation) {
                    if (AddEquation === Xc)
                        return AddEquation = zc.inflateEnd(this.strm), this.onEnd(AddEquation), this.ended = !0, !0;
                    if (0 === n.avail_in)
                        break;
                }
            }
            return !0;
        }, Zc.prototype.onData = function (REVISION) {
            this.chunks.push(REVISION);
        }, Zc.prototype.onEnd = function (REVISION) {
            REVISION === Qc && ('string' === this.options.to ? this.result = this.chunks.join('') : this.result = Ll(this.chunks)), this.chunks = [], this.err = REVISION, this.msg = this.strm.msg;
        };
        var $c = {
            Inflate: Zc,
            inflate: Jc,
            inflateRaw: function (REVISION, t) {
                return (t = t || {}).raw = !0, Jc(REVISION, t);
            },
            ungzip: Jc,
            constants: Lo
        };
        const {
                Deflate: eh,
                deflate: th,
                deflateRaw: nh,
                gzip: ih
            } = $l, {
                Inflate: rh,
                inflate: ah,
                inflateRaw: sh,
                ungzip: oh
            } = $c;
        var TYPED_ARRAYS = {
            Deflate: eh,
            deflate: th,
            deflateRaw: nh,
            gzip: ih,
            Inflate: rh,
            inflate: ah,
            inflateRaw: sh,
            ungzip: oh,
            constants: Lo
        };
        function ch(REVISION) {
            let t;
            REVISION = (REVISION = REVISION.replace(/-/g, '+')).replace(/_/g, '/');
            try {
                t = atob(REVISION);
            } catch (REVISION) {
                return null;
            }
            const n = new Uint8Array(t.length);
            for (let REVISION = 0; REVISION < t.length; ++REVISION) {
                const i = t.charCodeAt(REVISION);
                if (i > 255)
                    return null;
                n[REVISION] = i;
            }
            return n;
        }
        var hh, dh, uh, fh, ph, mh, gh, Ah, _h, vh, wh, yh = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, xh = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class bh {
            constructor(REVISION) {
                hh.add(this), uh.set(this, []), fh.set(this, []), ph.set(this, []), mh.set(this, []), gh.set(this, []), Ah.set(this, null), null != REVISION && (yh(this, uh, REVISION.up, 'f'), yh(this, fh, REVISION.right, 'f'), yh(this, ph, REVISION.down, 'f'), yh(this, mh, REVISION.left, 'f'), yh(this, gh, REVISION.reset, 'f'));
            }
            recordFrame(REVISION, t) {
                if (REVISION > dh.maxFrames)
                    throw new Error('Frame number exceeds maximum frame count.');
                if (null != xh(this, Ah, 'f') && REVISION <= xh(this, Ah, 'f'))
                    throw new Error('Frame number must be greater than the previous recorded frame.');
                yh(this, Ah, REVISION, 'f');
                const n = xh(this, uh, 'f').length % 2 != 0, i = xh(this, fh, 'f').length % 2 != 0, r = xh(this, ph, 'f').length % 2 != 0, AddEquation = xh(this, mh, 'f').length % 2 != 0, SubtractEquation = xh(this, gh, 'f').length % 2 != 0;
                t.up != n && xh(this, uh, 'f').push(REVISION), t.right != i && xh(this, fh, 'f').push(REVISION), t.down != r && xh(this, ph, 'f').push(REVISION), t.left != AddEquation && xh(this, mh, 'f').push(REVISION), t.reset != SubtractEquation && xh(this, gh, 'f').push(REVISION);
            }
            getFrame(REVISION) {
                return {
                    up: (xh(this, hh, 'm', _h).call(this, REVISION, xh(this, uh, 'f')) + 1) % 2 != 0,
                    right: (xh(this, hh, 'm', _h).call(this, REVISION, xh(this, fh, 'f')) + 1) % 2 != 0,
                    down: (xh(this, hh, 'm', _h).call(this, REVISION, xh(this, ph, 'f')) + 1) % 2 != 0,
                    left: (xh(this, hh, 'm', _h).call(this, REVISION, xh(this, mh, 'f')) + 1) % 2 != 0,
                    reset: (xh(this, hh, 'm', _h).call(this, REVISION, xh(this, gh, 'f')) + 1) % 2 != 0
                };
            }
            serialize() {
                const REVISION = new Uint8Array(3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length + 3 + 3 * xh(this, ph, 'f').length + 3 + 3 * xh(this, mh, 'f').length + 3 + 3 * xh(this, gh, 'f').length);
                xh(this, hh, 'm', vh).call(this, xh(this, uh, 'f'), REVISION.subarray(0, 3 + 3 * xh(this, uh, 'f').length)), xh(this, hh, 'm', vh).call(this, xh(this, fh, 'f'), REVISION.subarray(3 + 3 * xh(this, uh, 'f').length, 3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length)), xh(this, hh, 'm', vh).call(this, xh(this, ph, 'f'), REVISION.subarray(3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length, 3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length + 3 + 3 * xh(this, ph, 'f').length)), xh(this, hh, 'm', vh).call(this, xh(this, mh, 'f'), REVISION.subarray(3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length + 3 + 3 * xh(this, ph, 'f').length, 3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length + 3 + 3 * xh(this, ph, 'f').length + 3 + 3 * xh(this, mh, 'f').length)), xh(this, hh, 'm', vh).call(this, xh(this, gh, 'f'), REVISION.subarray(3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length + 3 + 3 * xh(this, ph, 'f').length + 3 + 3 * xh(this, mh, 'f').length, 3 + 3 * xh(this, uh, 'f').length + 3 + 3 * xh(this, fh, 'f').length + 3 + 3 * xh(this, ph, 'f').length + 3 + 3 * xh(this, mh, 'f').length + 3 + 3 * xh(this, gh, 'f').length));
                const t = new TYPED_ARRAYS.Deflate({ level: 9 });
                return t.push(new Uint8Array(REVISION), !0), function (REVISION) {
                    let t = '';
                    for (const n of REVISION)
                        t += String.fromCharCode(n);
                    let n = btoa(t);
                    return n = n.replace(/\+/g, '-'), n = n.replace(/\//g, '_'), n = n.replace(/=/g, ''), n;
                }(t.result);
            }
            static deserialize(REVISION) {
                const t = ch(REVISION);
                if (null == t)
                    return null;
                const n = new TYPED_ARRAYS.Inflate();
                if (n.push(t, !0), n.err)
                    return null;
                const i = n.result;
                if (!(i instanceof Uint8Array))
                    return null;
                const r = xh(dh, dh, 'm', wh).call(dh, i);
                if (null == r)
                    return null;
                const AddEquation = xh(dh, dh, 'm', wh).call(dh, i.subarray(3 + 3 * r.length));
                if (null == AddEquation)
                    return null;
                const SubtractEquation = xh(dh, dh, 'm', wh).call(dh, i.subarray(3 + 3 * r.length + 3 + 3 * AddEquation.length));
                if (null == SubtractEquation)
                    return null;
                const ReverseSubtractEquation = xh(dh, dh, 'm', wh).call(dh, i.subarray(3 + 3 * r.length + 3 + 3 * AddEquation.length + 3 + 3 * SubtractEquation.length));
                if (null == ReverseSubtractEquation)
                    return null;
                const ZeroFactor = xh(dh, dh, 'm', wh).call(dh, i.subarray(3 + 3 * r.length + 3 + 3 * AddEquation.length + 3 + 3 * SubtractEquation.length + 3 + 3 * ReverseSubtractEquation.length));
                return null == ZeroFactor ? null : new dh({
                    up: r,
                    right: AddEquation,
                    down: SubtractEquation,
                    left: ReverseSubtractEquation,
                    reset: ZeroFactor
                });
            }
        }
        dh = bh, uh = new WeakMap(), fh = new WeakMap(), ph = new WeakMap(), mh = new WeakMap(), gh = new WeakMap(), Ah = new WeakMap(), hh = new WeakSet(), _h = function (REVISION, t) {
            let n = -1;
            for (let i = 0; i < t.length; ++i) {
                const r = t[i];
                if (r == REVISION) {
                    n = i;
                    break;
                }
                if (r > REVISION)
                    break;
                n = i;
            }
            return n;
        }, vh = function (REVISION, t) {
            t[0] = 255 & REVISION.length, t[1] = REVISION.length >>> 8 & 255, t[2] = REVISION.length >>> 16 & 255;
            for (let n = 0; n < REVISION.length; ++n) {
                let i;
                i = 0 == n ? REVISION[n] : REVISION[n] - REVISION[n - 1], t[3 + 3 * n] = 255 & i, t[3 + 3 * n + 1] = i >>> 8 & 255, t[3 + 3 * n + 2] = i >>> 16 & 255;
            }
        }, wh = function (REVISION) {
            if (REVISION.length < 3)
                return null;
            const t = REVISION[0] | REVISION[1] << 8 | REVISION[2] << 16;
            if (REVISION.length < 3 + 3 * t)
                return null;
            const n = [];
            for (let i = 0; i < t; ++i) {
                const t = REVISION[3 + 3 * i] | REVISION[3 + 3 * i + 1] << 8 | REVISION[3 + 3 * i + 2] << 16;
                0 == i ? n.push(t) : n.push(n[i - 1] + t);
            }
            return n;
        }, bh.maxFrames = 5999999;
        const Sh = bh;
        var Eh, Mh, Th, Ch, Ih, Rh, Ph, Bh, Dh, Lh, Uh, Nh, kh, Fh = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, Oh = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class zh {
            constructor() {
                Mh.set(this, void 0), Th.set(this, void 0), Ch.set(this, void 0), Ih.set(this, void 0), Rh.set(this, void 0), Ph.set(this, []), Bh.set(this, new Map()), Lh.set(this, []), Uh.set(this, new Map()), Nh.set(this, null), kh.set(this, null), Fh(this, Mh, new Ammo.btDefaultCollisionConfiguration(), 'f'), Fh(this, Th, new Ammo.btCollisionDispatcher(Oh(this, Mh, 'f')), 'f'), Fh(this, Ch, new Ammo.btDbvtBroadphase(), 'f'), Fh(this, Ih, new Ammo.btSequentialImpulseConstraintSolver(), 'f'), Fh(this, Rh, new Ammo.btDiscreteDynamicsWorld(Oh(this, Th, 'f'), Oh(this, Ch, 'f'), Oh(this, Ih, 'f'), Oh(this, Mh, 'f')), 'f');
                const REVISION = new Ammo.btVector3(0, -9.82, 0);
                Oh(this, Rh, 'f').setGravity(REVISION), Ammo.destroy(REVISION);
            }
            dispose() {
                for (const {body: REVISION} of Oh(this, Lh, 'f'))
                    null != REVISION && Oh(this, Rh, 'f').removeRigidBody(REVISION);
                Oh(this, Lh, 'f').length = 0;
                for (const {body: REVISION} of Oh(this, Ph, 'f'))
                    null != REVISION && (Ammo.destroy(REVISION.getMotionState()), Ammo.destroy(REVISION));
                Oh(this, Ph, 'f').length = 0, Oh(this, Bh, 'f').clear();
                for (const REVISION of Oh(this, Uh, 'f').values())
                    for (const t of REVISION)
                        Ammo.destroy(t.getMotionState()), Ammo.destroy(t);
                Oh(this, Uh, 'f').clear(), null != Oh(this, Nh, 'f') && (Oh(this, Nh, 'f').isActive && Oh(this, Rh, 'f').removeRigidBody(Oh(this, Nh, 'f').body), Ammo.destroy(Oh(this, Nh, 'f').body.getMotionState()), Ammo.destroy(Oh(this, Nh, 'f').body), Ammo.destroy(Oh(this, Nh, 'f').shape)), null != Oh(this, kh, 'f') && (Oh(this, kh, 'f').isActive && Oh(this, Rh, 'f').removeRigidBody(Oh(this, kh, 'f').body), Ammo.destroy(Oh(this, kh, 'f').body.getMotionState()), Ammo.destroy(Oh(this, kh, 'f').body), Ammo.destroy(Oh(this, kh, 'f').shape), Ammo.destroy(Oh(this, kh, 'f').triangleMesh)), Ammo.destroy(Oh(this, Rh, 'f')), Ammo.destroy(Oh(this, Ih, 'f')), Ammo.destroy(Oh(this, Ch, 'f')), Ammo.destroy(Oh(this, Th, 'f')), Ammo.destroy(Oh(this, Mh, 'f'));
            }
            createGroundPlane() {
                if (null != Oh(this, Nh, 'f'))
                    throw new Error('Ground is already initialized');
                const REVISION = new Ammo.btVector3(0, 1, 0), t = new Ammo.btStaticPlaneShape(REVISION, 0);
                t.setMargin(0.01), Ammo.destroy(REVISION);
                const n = new Ammo.btTransform();
                n.setIdentity();
                const i = new Ammo.btDefaultMotionState(n);
                Ammo.destroy(n);
                const r = new Ammo.btVector3();
                t.calculateLocalInertia(0, r);
                const AddEquation = new Ammo.btRigidBodyConstructionInfo(0, i, t, r), SubtractEquation = new Ammo.btRigidBody(AddEquation);
                SubtractEquation.setFriction(1), Ammo.destroy(r), Ammo.destroy(AddEquation), Fh(this, Nh, {
                    body: SubtractEquation,
                    shape: t,
                    isActive: !1
                }, 'f');
            }
            createMountains(REVISION, t) {
                if (REVISION.length % 9 != 0)
                    throw new Error('Number of mountain vertices is not dividable by 9');
                if (REVISION.length > 0) {
                    if (null != Oh(this, kh, 'f'))
                        throw new Error('Mountains are already initialized');
                    let n = 1 / 0;
                    const i = new Ammo.btTriangleMesh();
                    for (let t = 0; t < REVISION.length; t += 9) {
                        const r = REVISION[t + 0], AddEquation = REVISION[t + 1], SubtractEquation = REVISION[t + 2], ReverseSubtractEquation = REVISION[t + 3], ZeroFactor = REVISION[t + 4], OneFactor = REVISION[t + 5], SrcColorFactor = REVISION[t + 6], OneMinusSrcColorFactor = REVISION[t + 7], SrcAlphaFactor = REVISION[t + 8], OneMinusSrcAlphaFactor = new Ammo.btVector3(r, AddEquation, SubtractEquation), DstAlphaFactor = new Ammo.btVector3(ReverseSubtractEquation, ZeroFactor, OneFactor), OneMinusDstAlphaFactor = new Ammo.btVector3(SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor);
                        i.addTriangle(OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor), Ammo.destroy(OneMinusSrcAlphaFactor), Ammo.destroy(DstAlphaFactor), Ammo.destroy(OneMinusDstAlphaFactor), n = Math.min(n, new Vector3(r, AddEquation, SubtractEquation).lengthSq(), new Vector3(ReverseSubtractEquation, ZeroFactor, OneFactor).lengthSq(), new Vector3(SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor).lengthSq());
                    }
                    const r = new Ammo.btBvhTriangleMeshShape(i);
                    r.setMargin(0.02);
                    const AddEquation = new Ammo.btVector3(t.x, t.y, t.z), SubtractEquation = new Ammo.btTransform();
                    SubtractEquation.setIdentity(), SubtractEquation.setOrigin(AddEquation), Ammo.destroy(AddEquation);
                    const ReverseSubtractEquation = new Ammo.btVector3();
                    r.calculateLocalInertia(0, ReverseSubtractEquation);
                    const ZeroFactor = new Ammo.btDefaultMotionState(SubtractEquation);
                    Ammo.destroy(SubtractEquation);
                    const OneFactor = new Ammo.btRigidBodyConstructionInfo(0, ZeroFactor, r, ReverseSubtractEquation), SrcColorFactor = new Ammo.btRigidBody(OneFactor);
                    SrcColorFactor.setFriction(1), Ammo.destroy(ReverseSubtractEquation), Ammo.destroy(OneFactor);
                    const OneMinusSrcColorFactor = Math.sqrt(n);
                    Fh(this, kh, {
                        body: SrcColorFactor,
                        shape: r,
                        triangleMesh: i,
                        offset: t,
                        minimumRadius: OneMinusSrcColorFactor,
                        isActive: !1
                    }, 'f');
                }
            }
            addStaticBody(REVISION, t, n) {
                const i = Oh(Eh, Eh, 'f', Dh);
                (t = t.clone()).applyMatrix4(REVISION);
                const r = {
                    active: !1,
                    matrix: REVISION,
                    shape: n,
                    body: null,
                    min: t.min.clone(),
                    max: t.max.clone()
                };
                Oh(this, Ph, 'f').push(r);
                for (let REVISION = Math.floor((t.min.x - 3) / i); REVISION <= Math.ceil((t.max.x + 3) / i); ++REVISION)
                    for (let n = Math.floor((t.min.y - 3) / i); n <= Math.ceil((t.max.y + 3) / i); ++n)
                        for (let AddEquation = Math.floor((t.min.z - 3) / i); AddEquation <= Math.ceil((t.max.z + 3) / i); ++AddEquation) {
                            const t = Oh(this, Bh, 'f').get(REVISION);
                            if (null == t)
                                Oh(this, Bh, 'f').set(REVISION, new Map([[
                                        n,
                                        new Map([[
                                                AddEquation,
                                                [r]
                                            ]])
                                    ]]));
                            else {
                                const REVISION = t.get(n);
                                if (null == REVISION)
                                    t.set(n, new Map([[
                                            AddEquation,
                                            [r]
                                        ]]));
                                else {
                                    const t = REVISION.get(AddEquation);
                                    null == t ? REVISION.set(AddEquation, [r]) : t.push(r);
                                }
                            }
                        }
            }
            activePhysicsAt(REVISION) {
                if (null != Oh(this, Nh, 'f') && (REVISION.y < 4 ? Oh(this, Nh, 'f').isActive || (Oh(this, Rh, 'f').addRigidBody(Oh(this, Nh, 'f').body), Oh(this, Nh, 'f').isActive = !0) : REVISION.y > 5 && Oh(this, Nh, 'f').isActive && (Oh(this, Rh, 'f').removeRigidBody(Oh(this, Nh, 'f').body), Oh(this, Nh, 'f').isActive = !1)), null != Oh(this, kh, 'f')) {
                    const t = REVISION.distanceTo(Oh(this, kh, 'f').offset);
                    t > Oh(this, kh, 'f').minimumRadius - 10 ? Oh(this, kh, 'f').isActive || (Oh(this, Rh, 'f').addRigidBody(Oh(this, kh, 'f').body), Oh(this, kh, 'f').isActive = !0) : t < Oh(this, kh, 'f').minimumRadius - 20 && Oh(this, kh, 'f').isActive && (Oh(this, Rh, 'f').removeRigidBody(Oh(this, kh, 'f').body), Oh(this, kh, 'f').isActive = !1);
                }
                const t = new Ammo.btVector3(), n = new Ammo.btVector3();
                Fh(this, Lh, Oh(this, Lh, 'f').filter(t => {
                    if (t.active && (REVISION.x < t.min.x - 3 || REVISION.x > t.max.x + 3 || REVISION.y < t.min.y - 3 || REVISION.y > t.max.y + 3 || REVISION.z < t.min.z - 3 || REVISION.z > t.max.z + 3)) {
                        const REVISION = Oh(this, Uh, 'f').get(t.shape);
                        return null == REVISION ? Oh(this, Uh, 'f').set(t.shape, [t.body]) : REVISION.push(t.body), Oh(this, Rh, 'f').removeRigidBody(t.body), t.body = null, t.active = !1, !1;
                    }
                    return !0;
                }), 'f');
                const i = REVISION.clone().divideScalar(Oh(Eh, Eh, 'f', Dh)).floor(), r = Oh(this, Bh, 'f').get(i.x);
                if (null != r) {
                    const t = r.get(i.y);
                    if (null != t) {
                        const n = t.get(i.z);
                        if (null != n)
                            for (const t of n)
                                if (!t.active && REVISION.x >= t.min.x - 3 && REVISION.x <= t.max.x + 3 && REVISION.y >= t.min.y - 3 && REVISION.y <= t.max.y + 3 && REVISION.z >= t.min.z - 3 && REVISION.z <= t.max.z + 3) {
                                    let REVISION = Oh(this, Uh, 'f').get(t.shape);
                                    null == REVISION && (REVISION = [], Oh(this, Uh, 'f').set(t.shape, REVISION));
                                    const n = new Ammo.btTransform();
                                    let i;
                                    if (n.setFromOpenGLMatrix(t.matrix.elements), REVISION.length > 0)
                                        i = REVISION.pop(), i.setWorldTransform(n), Ammo.destroy(n), Oh(this, Rh, 'f').addRigidBody(i);
                                    else {
                                        const REVISION = new Ammo.btDefaultMotionState(n);
                                        Ammo.destroy(n);
                                        const r = new Ammo.btVector3();
                                        t.shape.calculateLocalInertia(0, r);
                                        const AddEquation = new Ammo.btRigidBodyConstructionInfo(0, REVISION, t.shape, r);
                                        i = new Ammo.btRigidBody(AddEquation), i.setFriction(1), Ammo.destroy(r), Ammo.destroy(AddEquation), Oh(this, Rh, 'f').addRigidBody(i);
                                    }
                                    if (null != t.body)
                                        throw new Error('Activating already active rigid body');
                                    t.body = i, t.active = !0, Oh(this, Lh, 'f').push(t);
                                }
                    }
                }
                Ammo.destroy(t), Ammo.destroy(n);
            }
            step() {
                Oh(this, Rh, 'f').stepSimulation(1 / Eh.stepsPerSecond, 0, 1 / Eh.stepsPerSecond);
            }
            get world() {
                return Oh(this, Rh, 'f');
            }
            get dispatcher() {
                return Oh(this, Th, 'f');
            }
        }
        Eh = zh, Mh = new WeakMap(), Th = new WeakMap(), Ch = new WeakMap(), Ih = new WeakMap(), Rh = new WeakMap(), Ph = new WeakMap(), Bh = new WeakMap(), Lh = new WeakMap(), Uh = new WeakMap(), Nh = new WeakMap(), kh = new WeakMap(), Dh = { value: 20 }, zh.stepsPerSecond = 1000;
        const Hh = zh;
        var Wh, Vh = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, Gh = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class Qh {
            constructor(REVISION) {
                if (Wh.set(this, 0), null != REVISION) {
                    if (!Number.isSafeInteger(REVISION))
                        throw new Error('Frames is not a safe integer');
                    Vh(this, Wh, REVISION, 'f');
                }
            }
            get numberOfFrames() {
                return Gh(this, Wh, 'f');
            }
            get time() {
                return Gh(this, Wh, 'f') / 1000;
            }
            increment() {
                var REVISION;
                Vh(this, Wh, (REVISION = Gh(this, Wh, 'f'), ++REVISION), 'f');
            }
            difference(REVISION) {
                return new Qh(Gh(this, Wh, 'f') - Gh(REVISION, Wh, 'f'));
            }
            lessThan(REVISION) {
                return Gh(this, Wh, 'f') < Gh(REVISION, Wh, 'f');
            }
            greaterThan(REVISION) {
                return Gh(this, Wh, 'f') > Gh(REVISION, Wh, 'f');
            }
            lessOrEqual(REVISION) {
                return Gh(this, Wh, 'f') <= Gh(REVISION, Wh, 'f');
            }
            greaterOrEqual(REVISION) {
                return Gh(this, Wh, 'f') >= Gh(REVISION, Wh, 'f');
            }
            equals(REVISION) {
                return Gh(this, Wh, 'f') == Gh(REVISION, Wh, 'f');
            }
            isNegative() {
                return Gh(this, Wh, 'f') < 0;
            }
            clone() {
                const REVISION = new Qh();
                return Vh(REVISION, Wh, Gh(this, Wh, 'f'), 'f'), REVISION;
            }
        }
        Wh = new WeakMap();
        const Xh = Qh;
        var jh;
        !function (REVISION) {
            REVISION[REVISION.Checkpoint = 0] = 'Checkpoint', REVISION[REVISION.Finish = 1] = 'Finish';
        }(jh || (jh = {}));
        const qh = jh, Yh = [
                [
                    new Quaternion(0, 0, 0, 1),
                    new Quaternion(0, 0.7071067811865475, 0, 0.7071067811865476),
                    new Quaternion(0, 1, 0, 0),
                    new Quaternion(0, 0.7071067811865476, 0, -0.7071067811865475)
                ],
                [
                    new Quaternion(0, 0, 1, 0),
                    new Quaternion(0.7071067811865475, 0, 0.7071067811865476, 0),
                    new Quaternion(1, 0, 0, 0),
                    new Quaternion(0.7071067811865476, 0, -0.7071067811865475, 0)
                ],
                [
                    new Quaternion(0, 0, -0.7071067811865477, 0.7071067811865475),
                    new Quaternion(0.5, 0.5, -0.5, 0.5),
                    new Quaternion(0.7071067811865475, 0.7071067811865477, 0, 0),
                    new Quaternion(0.5, 0.5, 0.5, -0.5)
                ],
                [
                    new Quaternion(0, 0, 0.7071067811865475, 0.7071067811865476),
                    new Quaternion(0.5, -0.5, 0.5, 0.5),
                    new Quaternion(0.7071067811865476, -0.7071067811865475, 0, 0),
                    new Quaternion(0.5, -0.5, -0.5, -0.5)
                ],
                [
                    new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865476),
                    new Quaternion(0.5, 0.5, 0.5, 0.5),
                    new Quaternion(0, 0.7071067811865476, 0.7071067811865475, 0),
                    new Quaternion(-0.5, 0.5, 0.5, -0.5)
                ],
                [
                    new Quaternion(-0.7071067811865477, 0, 0, 0.7071067811865475),
                    new Quaternion(-0.5, -0.5, 0.5, 0.5),
                    new Quaternion(0, -0.7071067811865475, 0.7071067811865477, 0),
                    new Quaternion(0.5, -0.5, 0.5, -0.5)
                ]
            ];
        function Kh(REVISION, t) {
            return Yh[t][REVISION].clone();
        }
        var Zh, Jh, $h, ed, td, nd, id, rd, ad, sd = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, od = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class ld {
            constructor(REVISION, t, n) {
                Zh.add(this), $h.set(this, void 0), ed.set(this, new Map()), td.set(this, []), nd.set(this, []), id.set(this, []), sd(this, $h, t, 'f'), n.forEachPart((n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) => {
                    od(this, Zh, 'm', rd).call(this, n, i, r, SubtractEquation, ReverseSubtractEquation, AddEquation, REVISION, t);
                    const SrcColorFactor = od(this, ed, 'f').get(AddEquation);
                    null == SrcColorFactor ? od(this, ed, 'f').set(AddEquation, [{
                            x: n,
                            y: i,
                            z: r,
                            rotation: SubtractEquation,
                            rotationAxis: ReverseSubtractEquation,
                            type: AddEquation,
                            checkpointOrder: OneFactor
                        }]) : SrcColorFactor.push({
                        x: n,
                        y: i,
                        z: r,
                        rotation: SubtractEquation,
                        rotationAxis: ReverseSubtractEquation,
                        type: AddEquation,
                        checkpointOrder: OneFactor
                    });
                });
                const i = od(this, $h, 'f').getPartTypesWithDetector(qh.Finish);
                for (const REVISION of i) {
                    const t = od(this, $h, 'f').getDetector(REVISION);
                    if (null == t)
                        throw new Error('Part detector is missing');
                    const n = od(this, ed, 'f').get(REVISION);
                    null != n && sd(this, td, od(this, td, 'f').concat(n.map(({
                        x: REVISION,
                        y: n,
                        z: i,
                        rotation: r,
                        rotationAxis: AddEquation,
                        type: SubtractEquation,
                        checkpointOrder: ReverseSubtractEquation
                    }) => ({
                        x: REVISION,
                        y: n,
                        z: i,
                        rotation: r,
                        rotationAxis: AddEquation,
                        type: SubtractEquation,
                        checkpointOrder: ReverseSubtractEquation,
                        detector: t
                    }))), 'f');
                }
                const r = od(this, $h, 'f').getPartTypesWithDetector(qh.Checkpoint);
                for (const REVISION of r) {
                    const t = od(this, $h, 'f').getDetector(REVISION);
                    if (null == t)
                        throw new Error('Part detector is missing');
                    const n = od(this, ed, 'f').get(REVISION);
                    null != n && sd(this, nd, od(this, nd, 'f').concat(n.map(({
                        x: REVISION,
                        y: n,
                        z: i,
                        rotation: r,
                        rotationAxis: AddEquation,
                        type: SubtractEquation,
                        checkpointOrder: ReverseSubtractEquation
                    }) => {
                        if (null == ReverseSubtractEquation)
                            throw new Error('Checkpoint has no checkpoint order');
                        return {
                            x: REVISION,
                            y: n,
                            z: i,
                            rotation: r,
                            rotationAxis: AddEquation,
                            type: SubtractEquation,
                            checkpointOrder: ReverseSubtractEquation,
                            detector: t
                        };
                    })), 'f');
                }
                sd(this, id, od(this, nd, 'f').map(REVISION => REVISION.checkpointOrder).filter((REVISION, t, n) => n.indexOf(REVISION) == t).sort((REVISION, t) => REVISION - t), 'f');
            }
            checkCheckpoint(REVISION, t) {
                return od(this, Zh, 'm', ad).call(this, REVISION, t);
            }
            checkFinish(REVISION) {
                return od(this, Zh, 'm', ad).call(this, REVISION);
            }
            getTotalNumberOfCheckpointIndices() {
                return od(this, id, 'f').length;
            }
        }
        Jh = ld, $h = new WeakMap(), ed = new WeakMap(), td = new WeakMap(), nd = new WeakMap(), id = new WeakMap(), Zh = new WeakSet(), rd = function (REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
            const ZeroFactor = Kh(i, r), OneFactor = new Vector3(REVISION * Jh.partSize, t * Jh.partSize, n * Jh.partSize), SrcColorFactor = new Matrix4().compose(OneFactor, ZeroFactor, new Vector3(1, 1, 1)), {
                    boundingBox: OneMinusSrcColorFactor,
                    shape: SrcAlphaFactor
                } = ReverseSubtractEquation.getPhysicsShape(AddEquation);
            SubtractEquation.addStaticBody(SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor);
        }, ad = function (REVISION, t) {
            let n = [], i = null;
            null == t ? n = od(this, td, 'f') : (n = od(this, nd, 'f'), t < od(this, id, 'f').length && (i = od(this, id, 'f')[t]));
            for (const {
                        x: t,
                        y: r,
                        z: AddEquation,
                        rotation: SubtractEquation,
                        rotationAxis: ReverseSubtractEquation,
                        type: ZeroFactor,
                        checkpointOrder: OneFactor,
                        detector: SrcColorFactor
                    } of n)
                if (OneFactor == i) {
                    const n = Kh(SubtractEquation, ReverseSubtractEquation), i = SrcColorFactor.center.clone().applyQuaternion(n).add(new Vector3(t * Jh.partSize, r * Jh.partSize, AddEquation * Jh.partSize)), OneFactor = SrcColorFactor.size.clone().applyQuaternion(n);
                    OneFactor.x = Math.abs(OneFactor.x), OneFactor.y = Math.abs(OneFactor.y), OneFactor.z = Math.abs(OneFactor.z);
                    const OneMinusSrcColorFactor = new Box3().setFromCenterAndSize(i, OneFactor);
                    if (REVISION.intersectsBox3(OneMinusSrcColorFactor))
                        return {
                            x: t,
                            y: r,
                            z: AddEquation,
                            rotation: SubtractEquation,
                            rotationAxis: ReverseSubtractEquation,
                            type: ZeroFactor
                        };
                }
            return null;
        }, ld.partSize = 5;
        const cd = ld;
        var hd;
        !function (REVISION) {
            REVISION[REVISION.Straight = 0] = 'Straight', REVISION[REVISION.TurnSharp = 1] = 'TurnSharp', REVISION[REVISION.SlopeUp = 2] = 'SlopeUp', REVISION[REVISION.SlopeDown = 3] = 'SlopeDown', REVISION[REVISION.Slope = 4] = 'Slope', REVISION[REVISION.Start = 5] = 'Start', REVISION[REVISION.Finish = 6] = 'Finish', REVISION[REVISION.ToWideMiddle = 7] = 'ToWideMiddle', REVISION[REVISION.ToWideLeft = 8] = 'ToWideLeft', REVISION[REVISION.ToWideRight = 9] = 'ToWideRight', REVISION[REVISION.StraightWide = 10] = 'StraightWide', REVISION[REVISION.InnerCornerWide = 11] = 'InnerCornerWide', REVISION[REVISION.OuterCornerWide = 12] = 'OuterCornerWide', REVISION[REVISION.SlopeUpLeftWide = 13] = 'SlopeUpLeftWide', REVISION[REVISION.SlopeUpRightWide = 14] = 'SlopeUpRightWide', REVISION[REVISION.SlopeDownLeftWide = 15] = 'SlopeDownLeftWide', REVISION[REVISION.SlopeDownRightWide = 16] = 'SlopeDownRightWide', REVISION[REVISION.SlopeLeftWide = 17] = 'SlopeLeftWide', REVISION[REVISION.SlopeRightWide = 18] = 'SlopeRightWide', REVISION[REVISION.PillarTop = 19] = 'PillarTop', REVISION[REVISION.PillarMiddle = 20] = 'PillarMiddle', REVISION[REVISION.PillarBottom = 21] = 'PillarBottom', REVISION[REVISION.PillarShort = 22] = 'PillarShort', REVISION[REVISION.PlanePillarBottom = 23] = 'PlanePillarBottom', REVISION[REVISION.PlanePillarShort = 24] = 'PlanePillarShort', REVISION[REVISION.Plane = 25] = 'Plane', REVISION[REVISION.PlaneWall = 26] = 'PlaneWall', REVISION[REVISION.PlaneWallCorner = 27] = 'PlaneWallCorner', REVISION[REVISION.PlaneWallInnerCorner = 28] = 'PlaneWallInnerCorner', REVISION[REVISION.Block = 29] = 'Block', REVISION[REVISION.WallTrackTop = 30] = 'WallTrackTop', REVISION[REVISION.WallTrackMiddle = 31] = 'WallTrackMiddle', REVISION[REVISION.WallTrackBottom = 32] = 'WallTrackBottom', REVISION[REVISION.PlaneSlopeUp = 33] = 'PlaneSlopeUp', REVISION[REVISION.PlaneSlopeDown = 34] = 'PlaneSlopeDown', REVISION[REVISION.PlaneSlope = 35] = 'PlaneSlope', REVISION[REVISION.TurnShort = 36] = 'TurnShort', REVISION[REVISION.TurnLong = 37] = 'TurnLong', REVISION[REVISION.SlopeUpLong = 38] = 'SlopeUpLong', REVISION[REVISION.SlopeDownLong = 39] = 'SlopeDownLong', REVISION[REVISION.SlopePillar = 40] = 'SlopePillar', REVISION[REVISION.TurnSLeft = 41] = 'TurnSLeft', REVISION[REVISION.TurnSRight = 42] = 'TurnSRight', REVISION[REVISION.IntersectionT = 43] = 'IntersectionT', REVISION[REVISION.IntersectionCross = 44] = 'IntersectionCross', REVISION[REVISION.PillarBranch1 = 45] = 'PillarBranch1', REVISION[REVISION.PillarBranch2 = 46] = 'PillarBranch2', REVISION[REVISION.PillarBranch3 = 47] = 'PillarBranch3', REVISION[REVISION.PillarBranch4 = 48] = 'PillarBranch4', REVISION[REVISION.WallTrackBottomCorner = 49] = 'WallTrackBottomCorner', REVISION[REVISION.WallTrackMiddleCorner = 50] = 'WallTrackMiddleCorner', REVISION[REVISION.WallTrackTopCorner = 51] = 'WallTrackTopCorner', REVISION[REVISION.Checkpoint = 52] = 'Checkpoint', REVISION[REVISION.HalfBlock = 53] = 'HalfBlock', REVISION[REVISION.QuarterBlock = 54] = 'QuarterBlock', REVISION[REVISION.HalfPlane = 55] = 'HalfPlane', REVISION[REVISION.QuarterPlane = 56] = 'QuarterPlane', REVISION[REVISION.PlaneBridge = 57] = 'PlaneBridge', REVISION[REVISION.SignArrowLeft = 58] = 'SignArrowLeft', REVISION[REVISION.SignArrowRight = 59] = 'SignArrowRight', REVISION[REVISION.SignArrowUp = 61] = 'SignArrowUp', REVISION[REVISION.SignArrowDown = 62] = 'SignArrowDown', REVISION[REVISION.SignWarning = 63] = 'SignWarning', REVISION[REVISION.SignWrongWay = 64] = 'SignWrongWay', REVISION[REVISION.CheckpointWide = 65] = 'CheckpointWide', REVISION[REVISION.WallTrackCeiling = 66] = 'WallTrackCeiling', REVISION[REVISION.WallTrackFloor = 67] = 'WallTrackFloor', REVISION[REVISION.BlockSlopedDown = 68] = 'BlockSlopedDown', REVISION[REVISION.BlockSlopedDownInnerCorner = 69] = 'BlockSlopedDownInnerCorner', REVISION[REVISION.BlockSlopedDownOuterCorner = 70] = 'BlockSlopedDownOuterCorner', REVISION[REVISION.BlockSlopedUp = 71] = 'BlockSlopedUp', REVISION[REVISION.BlockSlopedUpInnerCorner = 72] = 'BlockSlopedUpInnerCorner', REVISION[REVISION.BlockSlopedUpOuterCorner = 73] = 'BlockSlopedUpOuterCorner', REVISION[REVISION.FinishWide = 74] = 'FinishWide', REVISION[REVISION.PlaneCheckpoint = 75] = 'PlaneCheckpoint', REVISION[REVISION.PlaneFinish = 76] = 'PlaneFinish', REVISION[REVISION.PlaneCheckpointWide = 77] = 'PlaneCheckpointWide', REVISION[REVISION.PlaneFinishWide = 78] = 'PlaneFinishWide', REVISION[REVISION.WallTrackBottomInnerCorner = 79] = 'WallTrackBottomInnerCorner', REVISION[REVISION.WallTrackInnerCorner = 80] = 'WallTrackInnerCorner', REVISION[REVISION.WallTrackTopInnerCorner = 81] = 'WallTrackTopInnerCorner', REVISION[REVISION.TurnLong2 = 82] = 'TurnLong2', REVISION[REVISION.TurnLong3 = 83] = 'TurnLong3', REVISION[REVISION.SlopePillarShort = 84] = 'SlopePillarShort', REVISION[REVISION.BlockSlopeUp = 85] = 'BlockSlopeUp', REVISION[REVISION.BlockSlopeDown = 86] = 'BlockSlopeDown', REVISION[REVISION.BlockSlopeVerticalTop = 87] = 'BlockSlopeVerticalTop', REVISION[REVISION.BlockSlopeVerticalBottom = 88] = 'BlockSlopeVerticalBottom', REVISION[REVISION.PlaneSlopeVerticalBottom = 90] = 'PlaneSlopeVerticalBottom', REVISION[REVISION.StartWide = 91] = 'StartWide', REVISION[REVISION.PlaneStart = 92] = 'PlaneStart', REVISION[REVISION.PlaneStartWide = 93] = 'PlaneStartWide', REVISION[REVISION.TurnShortLeftWide = 94] = 'TurnShortLeftWide', REVISION[REVISION.TurnShortRightWide = 95] = 'TurnShortRightWide', REVISION[REVISION.TurnLongLeftWide = 96] = 'TurnLongLeftWide', REVISION[REVISION.TurnLongRightWide = 97] = 'TurnLongRightWide', REVISION[REVISION.SlopeUpVertical = 98] = 'SlopeUpVertical', REVISION[REVISION.PlaneSlopePillar = 99] = 'PlaneSlopePillar', REVISION[REVISION.PlaneSlopePillarShort = 100] = 'PlaneSlopePillarShort', REVISION[REVISION.PillarBranch1Top = 101] = 'PillarBranch1Top', REVISION[REVISION.PillarBranch1Bottom = 102] = 'PillarBranch1Bottom', REVISION[REVISION.PillarBranch1Middle = 103] = 'PillarBranch1Middle', REVISION[REVISION.PillarBranch2Top = 104] = 'PillarBranch2Top', REVISION[REVISION.PillarBranch2Middle = 105] = 'PillarBranch2Middle', REVISION[REVISION.PillarBranch2Bottom = 106] = 'PillarBranch2Bottom', REVISION[REVISION.PillarBranch3Top = 107] = 'PillarBranch3Top', REVISION[REVISION.PillarBranch3Middle = 108] = 'PillarBranch3Middle', REVISION[REVISION.PillarBranch3Bottom = 109] = 'PillarBranch3Bottom', REVISION[REVISION.PillarBranch4Top = 110] = 'PillarBranch4Top', REVISION[REVISION.PillarBranch4Middle = 111] = 'PillarBranch4Middle', REVISION[REVISION.PillarBranch4Bottom = 112] = 'PillarBranch4Bottom', REVISION[REVISION.PillarBranch5 = 113] = 'PillarBranch5', REVISION[REVISION.PillarBranch5Top = 114] = 'PillarBranch5Top', REVISION[REVISION.PillarBranch5Middle = 115] = 'PillarBranch5Middle', REVISION[REVISION.PillarBranch5Bottom = 116] = 'PillarBranch5Bottom', REVISION[REVISION.ToWideDouble = 117] = 'ToWideDouble', REVISION[REVISION.ToWideDiagonal = 118] = 'ToWideDiagonal', REVISION[REVISION.StraightPillarBottom = 119] = 'StraightPillarBottom', REVISION[REVISION.StraightPillarShort = 120] = 'StraightPillarShort', REVISION[REVISION.TurnSharpPillarBottom = 121] = 'TurnSharpPillarBottom', REVISION[REVISION.TurnSharpPillarShort = 122] = 'TurnSharpPillarShort', REVISION[REVISION.IntersectionTPillarBottom = 123] = 'IntersectionTPillarBottom', REVISION[REVISION.IntersectionTPillarShort = 124] = 'IntersectionTPillarShort', REVISION[REVISION.IntersectionCrossPillarBottom = 125] = 'IntersectionCrossPillarBottom', REVISION[REVISION.IntersectionCrossPillarShort = 126] = 'IntersectionCrossPillarShort', REVISION[REVISION.PlaneBridgeCorner = 127] = 'PlaneBridgeCorner', REVISION[REVISION.PlaneBridgeIntersectionT = 128] = 'PlaneBridgeIntersectionT', REVISION[REVISION.PlaneBridgeIntersectionCross = 129] = 'PlaneBridgeIntersectionCross', REVISION[REVISION.BlockBridge = 130] = 'BlockBridge', REVISION[REVISION.BlockBridgeCorner = 131] = 'BlockBridgeCorner', REVISION[REVISION.BlockBridgeIntersectionT = 132] = 'BlockBridgeIntersectionT', REVISION[REVISION.BlockBridgeIntersectionCross = 133] = 'BlockBridgeIntersectionCross', REVISION[REVISION.WallTrackCeilingCorner = 134] = 'WallTrackCeilingCorner', REVISION[REVISION.WallTrackCeilingPlaneCorner = 135] = 'WallTrackCeilingPlaneCorner', REVISION[REVISION.WallTrackFloorCorner = 136] = 'WallTrackFloorCorner', REVISION[REVISION.WallTrackFloorPlaneCorner = 137] = 'WallTrackFloorPlaneCorner', REVISION[REVISION.SlopeUpVerticalLeftWide = 138] = 'SlopeUpVerticalLeftWide', REVISION[REVISION.SlopeUpVerticalRightWide = 139] = 'SlopeUpVerticalRightWide', REVISION[REVISION.BlockSlopeVerticalCornerTop = 140] = 'BlockSlopeVerticalCornerTop', REVISION[REVISION.BlockSlopeVerticalCornerBottom = 141] = 'BlockSlopeVerticalCornerBottom', REVISION[REVISION.WallTrackSlopeToVertical = 142] = 'WallTrackSlopeToVertical', REVISION[REVISION.PlaneSlopeToVertical = 143] = 'PlaneSlopeToVertical', REVISION[REVISION.BlockSlopeToVertical = 144] = 'BlockSlopeToVertical', REVISION[REVISION.PlaneSlopeUpLong = 145] = 'PlaneSlopeUpLong', REVISION[REVISION.PlaneSlopeDownLong = 146] = 'PlaneSlopeDownLong', REVISION[REVISION.SlopeUpLongLeftWide = 147] = 'SlopeUpLongLeftWide', REVISION[REVISION.SlopeUpLongRightWide = 148] = 'SlopeUpLongRightWide', REVISION[REVISION.SlopeDownLongLeftWide = 149] = 'SlopeDownLongLeftWide', REVISION[REVISION.SlopeDownLongRightWide = 150] = 'SlopeDownLongRightWide', REVISION[REVISION.BlockSlopeUpLong = 151] = 'BlockSlopeUpLong', REVISION[REVISION.BlockSlopeDownLong = 152] = 'BlockSlopeDownLong', REVISION[REVISION.BlockSlopeVerticalInnerCornerBottom = 153] = 'BlockSlopeVerticalInnerCornerBottom', REVISION[REVISION.BlockSlopeVerticalInnerCornerTop = 154] = 'BlockSlopeVerticalInnerCornerTop', REVISION[REVISION.BlockInnerCorner = 155] = 'BlockInnerCorner';
        }(hd || (hd = {}));
        const dd = hd;
        var ud;
        !function (REVISION) {
            REVISION[REVISION.YPositive = 0] = 'YPositive', REVISION[REVISION.YNegative = 1] = 'YNegative', REVISION[REVISION.XPositive = 2] = 'XPositive', REVISION[REVISION.XNegative = 3] = 'XNegative', REVISION[REVISION.ZPositive = 4] = 'ZPositive', REVISION[REVISION.ZNegative = 5] = 'ZNegative';
        }(ud || (ud = {}));
        const fd = ud;
        function pd(REVISION) {
            let t, n, i, r = -1, AddEquation = 0;
            for (let SubtractEquation = 0; SubtractEquation < REVISION.length; ++SubtractEquation) {
                const ReverseSubtractEquation = REVISION[SubtractEquation];
                if (void 0 === t && (t = ReverseSubtractEquation.array.constructor), t !== ReverseSubtractEquation.array.constructor)
                    return console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.'), null;
                if (void 0 === n && (n = ReverseSubtractEquation.itemSize), n !== ReverseSubtractEquation.itemSize)
                    return console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.'), null;
                if (void 0 === i && (i = ReverseSubtractEquation.normalized), i !== ReverseSubtractEquation.normalized)
                    return console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.'), null;
                if (-1 === r && (r = ReverseSubtractEquation.gpuType), r !== ReverseSubtractEquation.gpuType)
                    return console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.'), null;
                AddEquation += ReverseSubtractEquation.count * n;
            }
            const SubtractEquation = new t(AddEquation), ReverseSubtractEquation = new BufferAttribute(SubtractEquation, n, i);
            let ZeroFactor = 0;
            for (let t = 0; t < REVISION.length; ++t) {
                const i = REVISION[t];
                if (i.isInterleavedBufferAttribute) {
                    const REVISION = ZeroFactor / n;
                    for (let t = 0, r = i.count; t < r; t++)
                        for (let r = 0; r < n; r++) {
                            const n = i.getComponent(t, r);
                            ReverseSubtractEquation.setComponent(t + REVISION, r, n);
                        }
                } else
                    SubtractEquation.set(i.array, ZeroFactor);
                ZeroFactor += i.count * n;
            }
            return void 0 !== r && (ReverseSubtractEquation.gpuType = r), ReverseSubtractEquation;
        }
        function md(REVISION, t) {
            if (0 === t)
                return console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.'), REVISION;
            if (2 === t || 1 === t) {
                let n = REVISION.getIndex();
                if (null === n) {
                    const t = [], i = REVISION.getAttribute('position');
                    if (void 0 === i)
                        return console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'), REVISION;
                    for (let REVISION = 0; REVISION < i.count; REVISION++)
                        t.push(REVISION);
                    REVISION.setIndex(t), n = REVISION.getIndex();
                }
                const i = n.count - 2, r = [];
                if (2 === t)
                    for (let REVISION = 1; REVISION <= i; REVISION++)
                        r.push(n.getX(0)), r.push(n.getX(REVISION)), r.push(n.getX(REVISION + 1));
                else
                    for (let REVISION = 0; REVISION < i; REVISION++)
                        REVISION % 2 == 0 ? (r.push(n.getX(REVISION)), r.push(n.getX(REVISION + 1)), r.push(n.getX(REVISION + 2))) : (r.push(n.getX(REVISION + 2)), r.push(n.getX(REVISION + 1)), r.push(n.getX(REVISION)));
                r.length / 3 !== i && console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
                const AddEquation = REVISION.clone();
                return AddEquation.setIndex(r), AddEquation.clearGroups(), AddEquation;
            }
            return console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', t), REVISION;
        }
        class gd extends Loader {
            constructor(REVISION) {
                super(REVISION), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (REVISION) {
                    return new xd(REVISION);
                }), this.register(function (REVISION) {
                    return new bd(REVISION);
                }), this.register(function (REVISION) {
                    return new Bd(REVISION);
                }), this.register(function (REVISION) {
                    return new Dd(REVISION);
                }), this.register(function (REVISION) {
                    return new Ld(REVISION);
                }), this.register(function (REVISION) {
                    return new Ed(REVISION);
                }), this.register(function (REVISION) {
                    return new Md(REVISION);
                }), this.register(function (REVISION) {
                    return new Td(REVISION);
                }), this.register(function (REVISION) {
                    return new Cd(REVISION);
                }), this.register(function (REVISION) {
                    return new yd(REVISION);
                }), this.register(function (REVISION) {
                    return new Id(REVISION);
                }), this.register(function (REVISION) {
                    return new Sd(REVISION);
                }), this.register(function (REVISION) {
                    return new Pd(REVISION);
                }), this.register(function (REVISION) {
                    return new Rd(REVISION);
                }), this.register(function (REVISION) {
                    return new vd(REVISION);
                }), this.register(function (REVISION) {
                    return new Ud(REVISION);
                }), this.register(function (REVISION) {
                    return new Nd(REVISION);
                });
            }
            load(REVISION, t, n, i) {
                const r = this;
                let AddEquation;
                if ('' !== this.resourcePath)
                    AddEquation = this.resourcePath;
                else if ('' !== this.path) {
                    const t = LoaderUtils.extractUrlBase(REVISION);
                    AddEquation = LoaderUtils.resolveURL(t, this.path);
                } else
                    AddEquation = LoaderUtils.extractUrlBase(REVISION);
                this.manager.itemStart(REVISION);
                const SubtractEquation = function (t) {
                        i ? i(t) : console.error(t), r.manager.itemError(REVISION), r.manager.itemEnd(REVISION);
                    }, ReverseSubtractEquation = new FileLoader(this.manager);
                ReverseSubtractEquation.setPath(this.path), ReverseSubtractEquation.setResponseType('arraybuffer'), ReverseSubtractEquation.setRequestHeader(this.requestHeader), ReverseSubtractEquation.setWithCredentials(this.withCredentials), ReverseSubtractEquation.load(REVISION, function (n) {
                    try {
                        r.parse(n, AddEquation, function (n) {
                            t(n), r.manager.itemEnd(REVISION);
                        }, SubtractEquation);
                    } catch (REVISION) {
                        SubtractEquation(REVISION);
                    }
                }, n, SubtractEquation);
            }
            setDRACOLoader(REVISION) {
                return this.dracoLoader = REVISION, this;
            }
            setKTX2Loader(REVISION) {
                return this.ktx2Loader = REVISION, this;
            }
            setMeshoptDecoder(REVISION) {
                return this.meshoptDecoder = REVISION, this;
            }
            register(REVISION) {
                return -1 === this.pluginCallbacks.indexOf(REVISION) && this.pluginCallbacks.push(REVISION), this;
            }
            unregister(REVISION) {
                return -1 !== this.pluginCallbacks.indexOf(REVISION) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(REVISION), 1), this;
            }
            parse(REVISION, t, n, i) {
                let r;
                const AddEquation = {}, SubtractEquation = {}, ReverseSubtractEquation = new TextDecoder();
                if ('string' == typeof REVISION)
                    r = JSON.parse(REVISION);
                else if (REVISION instanceof ArrayBuffer) {
                    if (ReverseSubtractEquation.decode(new Uint8Array(REVISION, 0, 4)) === kd) {
                        try {
                            AddEquation[_d.KHR_BINARY_GLTF] = new zd(REVISION);
                        } catch (REVISION) {
                            return void (i && i(REVISION));
                        }
                        r = JSON.parse(AddEquation[_d.KHR_BINARY_GLTF].content);
                    } else
                        r = JSON.parse(ReverseSubtractEquation.decode(REVISION));
                } else
                    r = REVISION;
                if (void 0 === r.asset || r.asset.version[0] < 2)
                    return void (i && i(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.')));
                const ZeroFactor = new du(r, {
                    path: t || this.resourcePath || '',
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                ZeroFactor.fileLoader.setRequestHeader(this.requestHeader);
                for (let REVISION = 0; REVISION < this.pluginCallbacks.length; REVISION++) {
                    const t = this.pluginCallbacks[REVISION](ZeroFactor);
                    t.name || console.error('THREE.GLTFLoader: Invalid plugin found: missing name'), SubtractEquation[t.name] = t, AddEquation[t.name] = !0;
                }
                if (r.extensionsUsed)
                    for (let REVISION = 0; REVISION < r.extensionsUsed.length; ++REVISION) {
                        const t = r.extensionsUsed[REVISION], n = r.extensionsRequired || [];
                        switch (t) {
                        case _d.KHR_MATERIALS_UNLIT:
                            AddEquation[t] = new wd();
                            break;
                        case _d.KHR_DRACO_MESH_COMPRESSION:
                            AddEquation[t] = new Hd(r, this.dracoLoader);
                            break;
                        case _d.KHR_TEXTURE_TRANSFORM:
                            AddEquation[t] = new Wd();
                            break;
                        case _d.KHR_MESH_QUANTIZATION:
                            AddEquation[t] = new Vd();
                            break;
                        default:
                            n.indexOf(t) >= 0 && void 0 === SubtractEquation[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".');
                        }
                    }
                ZeroFactor.setExtensions(AddEquation), ZeroFactor.setPlugins(SubtractEquation), ZeroFactor.parse(n, i);
            }
            parseAsync(REVISION, t) {
                const n = this;
                return new Promise(function (i, r) {
                    n.parse(REVISION, t, i, r);
                });
            }
        }
        function Ad() {
            let REVISION = {};
            return {
                get: function (t) {
                    return REVISION[t];
                },
                add: function (t, n) {
                    REVISION[t] = n;
                },
                remove: function (t) {
                    delete REVISION[t];
                },
                removeAll: function () {
                    REVISION = {};
                }
            };
        }
        const _d = {
            KHR_BINARY_GLTF: 'KHR_binary_glTF',
            KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
            KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
            KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
            KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
            KHR_MATERIALS_IOR: 'KHR_materials_ior',
            KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
            KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
            KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
            KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
            KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
            KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
            KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
            KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
            KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
            KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
            KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
            EXT_MATERIALS_BUMP: 'EXT_materials_bump',
            EXT_TEXTURE_WEBP: 'EXT_texture_webp',
            EXT_TEXTURE_AVIF: 'EXT_texture_avif',
            EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
            EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
        };
        class vd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                };
            }
            _markDefs() {
                const REVISION = this.parser, t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && REVISION._addNodeRef(this.cache, i.extensions[this.name].light);
                }
            }
            _loadLight(REVISION) {
                const t = this.parser, n = 'light:' + REVISION;
                let i = t.cache.get(n);
                if (i)
                    return i;
                const r = t.json, AddEquation = ((r.extensions && r.extensions[this.name] || {}).lights || [])[REVISION];
                let SubtractEquation;
                const ReverseSubtractEquation = new Color(16777215);
                void 0 !== AddEquation.color && ReverseSubtractEquation.setRGB(AddEquation.color[0], AddEquation.color[1], AddEquation.color[2], LinearSRGBColorSpace);
                const ZeroFactor = void 0 !== AddEquation.range ? AddEquation.range : 0;
                switch (AddEquation.type) {
                case 'directional':
                    SubtractEquation = new DirectionalLight(ReverseSubtractEquation), SubtractEquation.target.position.set(0, 0, -1), SubtractEquation.add(SubtractEquation.target);
                    break;
                case 'point':
                    SubtractEquation = new PointLight(ReverseSubtractEquation), SubtractEquation.distance = ZeroFactor;
                    break;
                case 'spot':
                    SubtractEquation = new os(ReverseSubtractEquation), SubtractEquation.distance = ZeroFactor, AddEquation.spot = AddEquation.spot || {}, AddEquation.spot.innerConeAngle = void 0 !== AddEquation.spot.innerConeAngle ? AddEquation.spot.innerConeAngle : 0, AddEquation.spot.outerConeAngle = void 0 !== AddEquation.spot.outerConeAngle ? AddEquation.spot.outerConeAngle : Math.PI / 4, SubtractEquation.angle = AddEquation.spot.outerConeAngle, SubtractEquation.penumbra = 1 - AddEquation.spot.innerConeAngle / AddEquation.spot.outerConeAngle, SubtractEquation.target.position.set(0, 0, -1), SubtractEquation.add(SubtractEquation.target);
                    break;
                default:
                    throw new Error('THREE.GLTFLoader: Unexpected light type: ' + AddEquation.type);
                }
                return SubtractEquation.position.set(0, 0, 0), au(SubtractEquation, AddEquation), void 0 !== AddEquation.intensity && (SubtractEquation.intensity = AddEquation.intensity), SubtractEquation.name = t.createUniqueName(AddEquation.name || 'light_' + REVISION), i = Promise.resolve(SubtractEquation), t.cache.add(n, i), i;
            }
            getDependency(REVISION, t) {
                if ('light' === REVISION)
                    return this._loadLight(t);
            }
            createNodeAttachment(REVISION) {
                const t = this, n = this.parser, i = n.json.nodes[REVISION], r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then(function (REVISION) {
                    return n._getNodeRef(t.cache, r, REVISION);
                });
            }
        }
        class wd {
            constructor() {
                this.name = _d.KHR_MATERIALS_UNLIT;
            }
            getMaterialType() {
                return Si;
            }
            extendParams(REVISION, t, n) {
                const i = [];
                REVISION.color = new Color(1, 1, 1), REVISION.opacity = 1;
                const r = t.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const t = r.baseColorFactor;
                        REVISION.color.setRGB(t[0], t[1], t[2], LinearSRGBColorSpace), REVISION.opacity = t[3];
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(REVISION, 'map', r.baseColorTexture, Ye));
                }
                return Promise.all(i);
            }
        }
        class yd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_EMISSIVE_STRENGTH;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser.json.materials[REVISION];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve();
            }
        }
        class xd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_CLEARCOAT;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                if (void 0 !== AddEquation.clearcoatFactor && (t.clearcoat = AddEquation.clearcoatFactor), void 0 !== AddEquation.clearcoatTexture && r.push(n.assignTexture(t, 'clearcoatMap', AddEquation.clearcoatTexture)), void 0 !== AddEquation.clearcoatRoughnessFactor && (t.clearcoatRoughness = AddEquation.clearcoatRoughnessFactor), void 0 !== AddEquation.clearcoatRoughnessTexture && r.push(n.assignTexture(t, 'clearcoatRoughnessMap', AddEquation.clearcoatRoughnessTexture)), void 0 !== AddEquation.clearcoatNormalTexture && (r.push(n.assignTexture(t, 'clearcoatNormalMap', AddEquation.clearcoatNormalTexture)), void 0 !== AddEquation.clearcoatNormalTexture.scale)) {
                    const REVISION = AddEquation.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new Vector2(REVISION, REVISION);
                }
                return Promise.all(r);
            }
        }
        class bd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_DISPERSION;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser.json.materials[REVISION];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0, Promise.resolve();
            }
        }
        class Sd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_IRIDESCENCE;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                return void 0 !== AddEquation.iridescenceFactor && (t.iridescence = AddEquation.iridescenceFactor), void 0 !== AddEquation.iridescenceTexture && r.push(n.assignTexture(t, 'iridescenceMap', AddEquation.iridescenceTexture)), void 0 !== AddEquation.iridescenceIor && (t.iridescenceIOR = AddEquation.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [
                    100,
                    400
                ]), void 0 !== AddEquation.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = AddEquation.iridescenceThicknessMinimum), void 0 !== AddEquation.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = AddEquation.iridescenceThicknessMaximum), void 0 !== AddEquation.iridescenceThicknessTexture && r.push(n.assignTexture(t, 'iridescenceThicknessMap', AddEquation.iridescenceThicknessTexture)), Promise.all(r);
            }
        }
        class Ed {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_SHEEN;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [];
                t.sheenColor = new Color(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                const AddEquation = i.extensions[this.name];
                if (void 0 !== AddEquation.sheenColorFactor) {
                    const REVISION = AddEquation.sheenColorFactor;
                    t.sheenColor.setRGB(REVISION[0], REVISION[1], REVISION[2], LinearSRGBColorSpace);
                }
                return void 0 !== AddEquation.sheenRoughnessFactor && (t.sheenRoughness = AddEquation.sheenRoughnessFactor), void 0 !== AddEquation.sheenColorTexture && r.push(n.assignTexture(t, 'sheenColorMap', AddEquation.sheenColorTexture, Ye)), void 0 !== AddEquation.sheenRoughnessTexture && r.push(n.assignTexture(t, 'sheenRoughnessMap', AddEquation.sheenRoughnessTexture)), Promise.all(r);
            }
        }
        class Md {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_TRANSMISSION;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                return void 0 !== AddEquation.transmissionFactor && (t.transmission = AddEquation.transmissionFactor), void 0 !== AddEquation.transmissionTexture && r.push(n.assignTexture(t, 'transmissionMap', AddEquation.transmissionTexture)), Promise.all(r);
            }
        }
        class Td {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_VOLUME;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                t.thickness = void 0 !== AddEquation.thicknessFactor ? AddEquation.thicknessFactor : 0, void 0 !== AddEquation.thicknessTexture && r.push(n.assignTexture(t, 'thicknessMap', AddEquation.thicknessTexture)), t.attenuationDistance = AddEquation.attenuationDistance || 1 / 0;
                const SubtractEquation = AddEquation.attenuationColor || [
                    1,
                    1,
                    1
                ];
                return t.attenuationColor = new Color().setRGB(SubtractEquation[0], SubtractEquation[1], SubtractEquation[2], LinearSRGBColorSpace), Promise.all(r);
            }
        }
        class Cd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_IOR;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser.json.materials[REVISION];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve();
            }
        }
        class Id {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_SPECULAR;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                t.specularIntensity = void 0 !== AddEquation.specularFactor ? AddEquation.specularFactor : 1, void 0 !== AddEquation.specularTexture && r.push(n.assignTexture(t, 'specularIntensityMap', AddEquation.specularTexture));
                const SubtractEquation = AddEquation.specularColorFactor || [
                    1,
                    1,
                    1
                ];
                return t.specularColor = new Color().setRGB(SubtractEquation[0], SubtractEquation[1], SubtractEquation[2], LinearSRGBColorSpace), void 0 !== AddEquation.specularColorTexture && r.push(n.assignTexture(t, 'specularColorMap', AddEquation.specularColorTexture, Ye)), Promise.all(r);
            }
        }
        class Rd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.EXT_MATERIALS_BUMP;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                return t.bumpScale = void 0 !== AddEquation.bumpFactor ? AddEquation.bumpFactor : 1, void 0 !== AddEquation.bumpTexture && r.push(n.assignTexture(t, 'bumpMap', AddEquation.bumpTexture)), Promise.all(r);
            }
        }
        class Pd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_MATERIALS_ANISOTROPY;
            }
            getMaterialType(REVISION) {
                const t = this.parser.json.materials[REVISION];
                return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null;
            }
            extendMaterialParams(REVISION, t) {
                const n = this.parser, i = n.json.materials[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [], AddEquation = i.extensions[this.name];
                return void 0 !== AddEquation.anisotropyStrength && (t.anisotropy = AddEquation.anisotropyStrength), void 0 !== AddEquation.anisotropyRotation && (t.anisotropyRotation = AddEquation.anisotropyRotation), void 0 !== AddEquation.anisotropyTexture && r.push(n.assignTexture(t, 'anisotropyMap', AddEquation.anisotropyTexture)), Promise.all(r);
            }
        }
        class Bd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.KHR_TEXTURE_BASISU;
            }
            loadTexture(REVISION) {
                const t = this.parser, n = t.json, i = n.textures[REVISION];
                if (!i.extensions || !i.extensions[this.name])
                    return null;
                const r = i.extensions[this.name], AddEquation = t.options.ktx2Loader;
                if (!AddEquation) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
                    return null;
                }
                return t.loadTextureImage(REVISION, r.source, AddEquation);
            }
        }
        class Dd {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.EXT_TEXTURE_WEBP, this.isSupported = null;
            }
            loadTexture(REVISION) {
                const t = this.name, n = this.parser, i = n.json, r = i.textures[REVISION];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const AddEquation = r.extensions[t], SubtractEquation = i.images[AddEquation.source];
                let ReverseSubtractEquation = n.textureLoader;
                if (SubtractEquation.uri) {
                    const REVISION = n.options.manager.getHandler(SubtractEquation.uri);
                    null !== REVISION && (ReverseSubtractEquation = REVISION);
                }
                return this.detectSupport().then(function (r) {
                    if (r)
                        return n.loadTextureImage(REVISION, AddEquation.source, ReverseSubtractEquation);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
                    return n.loadTexture(REVISION);
                });
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise(function (REVISION) {
                    const t = new Image();
                    t.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA', t.onload = t.onerror = function () {
                        REVISION(1 === t.height);
                    };
                })), this.isSupported;
            }
        }
        class Ld {
            constructor(REVISION) {
                this.parser = REVISION, this.name = _d.EXT_TEXTURE_AVIF, this.isSupported = null;
            }
            loadTexture(REVISION) {
                const t = this.name, n = this.parser, i = n.json, r = i.textures[REVISION];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const AddEquation = r.extensions[t], SubtractEquation = i.images[AddEquation.source];
                let ReverseSubtractEquation = n.textureLoader;
                if (SubtractEquation.uri) {
                    const REVISION = n.options.manager.getHandler(SubtractEquation.uri);
                    null !== REVISION && (ReverseSubtractEquation = REVISION);
                }
                return this.detectSupport().then(function (r) {
                    if (r)
                        return n.loadTextureImage(REVISION, AddEquation.source, ReverseSubtractEquation);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.');
                    return n.loadTexture(REVISION);
                });
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise(function (REVISION) {
                    const t = new Image();
                    t.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=', t.onload = t.onerror = function () {
                        REVISION(1 === t.height);
                    };
                })), this.isSupported;
            }
        }
        class Ud {
            constructor(REVISION) {
                this.name = _d.EXT_MESHOPT_COMPRESSION, this.parser = REVISION;
            }
            loadBufferView(REVISION) {
                const t = this.parser.json, n = t.bufferViews[REVISION];
                if (n.extensions && n.extensions[this.name]) {
                    const REVISION = n.extensions[this.name], i = this.parser.getDependency('buffer', REVISION.buffer), r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
                        return null;
                    }
                    return i.then(function (t) {
                        const n = REVISION.byteOffset || 0, i = REVISION.byteLength || 0, AddEquation = REVISION.count, SubtractEquation = REVISION.byteStride, ReverseSubtractEquation = new Uint8Array(t, n, i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(AddEquation, SubtractEquation, ReverseSubtractEquation, REVISION.mode, REVISION.filter).then(function (REVISION) {
                            return REVISION.buffer;
                        }) : r.ready.then(function () {
                            const t = new ArrayBuffer(AddEquation * SubtractEquation);
                            return r.decodeGltfBuffer(new Uint8Array(t), AddEquation, SubtractEquation, ReverseSubtractEquation, REVISION.mode, REVISION.filter), t;
                        });
                    });
                }
                return null;
            }
        }
        class Nd {
            constructor(REVISION) {
                this.name = _d.EXT_MESH_GPU_INSTANCING, this.parser = REVISION;
            }
            createNodeMesh(REVISION) {
                const t = this.parser.json, n = t.nodes[REVISION];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const i = t.meshes[n.mesh];
                for (const REVISION of i.primitives)
                    if (REVISION.mode !== jd.TRIANGLES && REVISION.mode !== jd.TRIANGLE_STRIP && REVISION.mode !== jd.TRIANGLE_FAN && void 0 !== REVISION.mode)
                        return null;
                const r = n.extensions[this.name].attributes, AddEquation = [], SubtractEquation = {};
                for (const REVISION in r)
                    AddEquation.push(this.parser.getDependency('accessor', r[REVISION]).then(t => (SubtractEquation[REVISION] = t, SubtractEquation[REVISION])));
                return AddEquation.length < 1 ? null : (AddEquation.push(this.parser.createNodeMesh(REVISION)), Promise.all(AddEquation).then(REVISION => {
                    const t = REVISION.pop(), n = t.isGroup ? t.children : [t], i = REVISION[0].count, r = [];
                    for (const REVISION of n) {
                        const t = new Matrix4(), n = new Vector3(), AddEquation = new Quaternion(), ReverseSubtractEquation = new Vector3(1, 1, 1), ZeroFactor = new InstancedMesh(REVISION.geometry, REVISION.material, i);
                        for (let REVISION = 0; REVISION < i; REVISION++)
                            SubtractEquation.TRANSLATION && n.fromBufferAttribute(SubtractEquation.TRANSLATION, REVISION), SubtractEquation.ROTATION && AddEquation.fromBufferAttribute(SubtractEquation.ROTATION, REVISION), SubtractEquation.SCALE && ReverseSubtractEquation.fromBufferAttribute(SubtractEquation.SCALE, REVISION), ZeroFactor.setMatrixAt(REVISION, t.compose(n, AddEquation, ReverseSubtractEquation));
                        for (const t in SubtractEquation)
                            if ('_COLOR_0' === t) {
                                const REVISION = SubtractEquation[t];
                                ZeroFactor.instanceColor = new kr(REVISION.array, REVISION.itemSize, REVISION.normalized);
                            } else
                                'TRANSLATION' !== t && 'ROTATION' !== t && 'SCALE' !== t && REVISION.geometry.setAttribute(t, SubtractEquation[t]);
                        Object3D.prototype.copy.call(ZeroFactor, REVISION), this.parser.assignFinalMaterial(ZeroFactor), r.push(ZeroFactor);
                    }
                    return t.isGroup ? (t.clear(), t.add(...r), t) : r[0];
                }));
            }
        }
        const kd = 'glTF', Fd = 1313821514, Od = 5130562;
        class zd {
            constructor(REVISION) {
                this.name = _d.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const t = new DataView(REVISION, 0, 12), n = new TextDecoder();
                if (this.header = {
                        magic: n.decode(new Uint8Array(REVISION.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== kd)
                    throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
                if (this.header.version < 2)
                    throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
                const i = this.header.length - 12, r = new DataView(REVISION, 12);
                let AddEquation = 0;
                for (; AddEquation < i;) {
                    const t = r.getUint32(AddEquation, !0);
                    AddEquation += 4;
                    const i = r.getUint32(AddEquation, !0);
                    if (AddEquation += 4, i === Fd) {
                        const i = new Uint8Array(REVISION, 12 + AddEquation, t);
                        this.content = n.decode(i);
                    } else if (i === Od) {
                        const n = 12 + AddEquation;
                        this.body = REVISION.slice(n, n + t);
                    }
                    AddEquation += t;
                }
                if (null === this.content)
                    throw new Error('THREE.GLTFLoader: JSON content not found.');
            }
        }
        class Hd {
            constructor(REVISION, t) {
                if (!t)
                    throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
                this.name = _d.KHR_DRACO_MESH_COMPRESSION, this.json = REVISION, this.dracoLoader = t, this.dracoLoader.preload();
            }
            decodePrimitive(REVISION, t) {
                const n = this.json, i = this.dracoLoader, r = REVISION.extensions[this.name].bufferView, AddEquation = REVISION.extensions[this.name].attributes, SubtractEquation = {}, ReverseSubtractEquation = {}, ZeroFactor = {};
                for (const REVISION in AddEquation) {
                    const t = Jd[REVISION] || REVISION.toLowerCase();
                    SubtractEquation[t] = AddEquation[REVISION];
                }
                for (const t in REVISION.attributes) {
                    const i = Jd[t] || t.toLowerCase();
                    if (void 0 !== AddEquation[t]) {
                        const r = n.accessors[REVISION.attributes[t]], AddEquation = qd[r.componentType];
                        ZeroFactor[i] = AddEquation.name, ReverseSubtractEquation[i] = !0 === r.normalized;
                    }
                }
                return t.getDependency('bufferView', r).then(function (REVISION) {
                    return new Promise(function (t, n) {
                        i.decodeDracoFile(REVISION, function (REVISION) {
                            for (const t in REVISION.attributes) {
                                const n = REVISION.attributes[t], i = ReverseSubtractEquation[t];
                                void 0 !== i && (n.normalized = i);
                            }
                            t(REVISION);
                        }, SubtractEquation, ZeroFactor, LinearSRGBColorSpace, n);
                    });
                });
            }
        }
        class Wd {
            constructor() {
                this.name = _d.KHR_TEXTURE_TRANSFORM;
            }
            extendTexture(REVISION, t) {
                return void 0 !== t.texCoord && t.texCoord !== REVISION.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (REVISION = REVISION.clone(), void 0 !== t.texCoord && (REVISION.channel = t.texCoord), void 0 !== t.offset && REVISION.offset.fromArray(t.offset), void 0 !== t.rotation && (REVISION.rotation = t.rotation), void 0 !== t.scale && REVISION.repeat.fromArray(t.scale), REVISION.needsUpdate = !0, REVISION) : REVISION;
            }
        }
        class Vd {
            constructor() {
                this.name = _d.KHR_MESH_QUANTIZATION;
            }
        }
        class Gd extends Interpolant {
            constructor(REVISION, t, n, i) {
                super(REVISION, t, n, i);
            }
            copySampleValue_(REVISION) {
                const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = REVISION * i * 3 + i;
                for (let REVISION = 0; REVISION !== i; REVISION++)
                    t[REVISION] = n[r + REVISION];
                return t;
            }
            interpolate_(REVISION, t, n, i) {
                const r = this.resultBuffer, AddEquation = this.sampleValues, SubtractEquation = this.valueSize, ReverseSubtractEquation = 2 * SubtractEquation, ZeroFactor = 3 * SubtractEquation, OneFactor = i - t, SrcColorFactor = (n - t) / OneFactor, OneMinusSrcColorFactor = SrcColorFactor * SrcColorFactor, SrcAlphaFactor = OneMinusSrcColorFactor * SrcColorFactor, OneMinusSrcAlphaFactor = REVISION * ZeroFactor, DstAlphaFactor = OneMinusSrcAlphaFactor - ZeroFactor, OneMinusDstAlphaFactor = -2 * SrcAlphaFactor + 3 * OneMinusSrcColorFactor, DstColorFactor = SrcAlphaFactor - OneMinusSrcColorFactor, OneMinusDstColorFactor = 1 - OneMinusDstAlphaFactor, SrcAlphaSaturateFactor = DstColorFactor - OneMinusSrcColorFactor + SrcColorFactor;
                for (let REVISION = 0; REVISION !== SubtractEquation; REVISION++) {
                    const t = AddEquation[DstAlphaFactor + REVISION + SubtractEquation], n = AddEquation[DstAlphaFactor + REVISION + ReverseSubtractEquation] * OneFactor, i = AddEquation[OneMinusSrcAlphaFactor + REVISION + SubtractEquation], ZeroFactor = AddEquation[OneMinusSrcAlphaFactor + REVISION] * OneFactor;
                    r[REVISION] = OneMinusDstColorFactor * t + SrcAlphaSaturateFactor * n + OneMinusDstAlphaFactor * i + DstColorFactor * ZeroFactor;
                }
                return r;
            }
        }
        const Qd = new Quaternion();
        class Xd extends Gd {
            interpolate_(REVISION, t, n, i) {
                const r = super.interpolate_(REVISION, t, n, i);
                return Qd.fromArray(r).normalize().toArray(r), r;
            }
        }
        const jd = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            }, qd = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            }, Yd = {
                9728: NearestFilter,
                9729: LinearFilter,
                9984: NearestMipMapNearestFilter,
                9985: LinearMipMapNearestFilter,
                9986: NearestMipMapLinearFilter,
                9987: LinearMipMapLinearFilter
            }, Kd = {
                33071: ClampToEdgeWrapping,
                33648: MirroredRepeatWrapping,
                10497: RepeatWrapping
            }, Zd = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            }, Jd = {
                POSITION: 'position',
                NORMAL: 'normal',
                TANGENT: 'tangent',
                TEXCOORD_0: 'uv',
                TEXCOORD_1: 'uv1',
                TEXCOORD_2: 'uv2',
                TEXCOORD_3: 'uv3',
                COLOR_0: 'color',
                WEIGHTS_0: 'skinWeight',
                JOINTS_0: 'skinIndex'
            }, $d = {
                scale: 'scale',
                translation: 'position',
                rotation: 'quaternion',
                weights: 'morphTargetInfluences'
            }, eu = {
                CUBICSPLINE: void 0,
                LINEAR: InterpolateLinear,
                STEP: InterpolateDiscrete
            }, tu = 'OPAQUE', nu = 'MASK', iu = 'BLEND';
        function ru(REVISION, t, n) {
            for (const i in n.extensions)
                void 0 === REVISION[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i]);
        }
        function au(REVISION, t) {
            void 0 !== t.extras && ('object' == typeof t.extras ? Object.assign(REVISION.userData, t.extras) : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + t.extras));
        }
        function su(REVISION, t) {
            if (REVISION.updateMorphTargets(), void 0 !== t.weights)
                for (let n = 0, i = t.weights.length; n < i; n++)
                    REVISION.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (REVISION.morphTargetInfluences.length === n.length) {
                    REVISION.morphTargetDictionary = {};
                    for (let t = 0, i = n.length; t < i; t++)
                        REVISION.morphTargetDictionary[n[t]] = t;
                } else
                    console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
            }
        }
        function ou(REVISION) {
            let t;
            const n = REVISION.extensions && REVISION.extensions[_d.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? 'draco:' + n.bufferView + ':' + n.indices + ':' + lu(n.attributes) : REVISION.indices + ':' + lu(REVISION.attributes) + ':' + REVISION.mode, void 0 !== REVISION.targets)
                for (let n = 0, i = REVISION.targets.length; n < i; n++)
                    t += ':' + lu(REVISION.targets[n]);
            return t;
        }
        function lu(REVISION) {
            let t = '';
            const n = Object.keys(REVISION).sort();
            for (let i = 0, r = n.length; i < r; i++)
                t += n[i] + ':' + REVISION[n[i]] + ';';
            return t;
        }
        function cu(REVISION) {
            switch (REVISION) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
            }
        }
        const _scale$1 = new Matrix4();
        class du {
            constructor(REVISION = {}, t = {}) {
                this.json = REVISION, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Ad(), this.associations = new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                let n = !1, i = -1, r = !1, AddEquation = -1;
                if ('undefined' != typeof navigator) {
                    const REVISION = navigator.userAgent;
                    n = !0 === /^((?!chrome|android).)*safari/i.test(REVISION);
                    const t = REVISION.match(/Version\/(\d+)/);
                    i = n && t ? parseInt(t[1], 10) : -1, r = REVISION.indexOf('Firefox') > -1, AddEquation = r ? REVISION.match(/Firefox\/([0-9]+)\./)[1] : -1;
                }
                'undefined' == typeof createImageBitmap || n && i < 17 || r && AddEquation < 98 ? this.textureLoader = new AudioLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType('arraybuffer'), 'use-credentials' === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
            }
            setExtensions(REVISION) {
                this.extensions = REVISION;
            }
            setPlugins(REVISION) {
                this.plugins = REVISION;
            }
            parse(REVISION, t) {
                const n = this, i = this.json, r = this.extensions;
                this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (REVISION) {
                    return REVISION._markDefs && REVISION._markDefs();
                }), Promise.all(this._invokeAll(function (REVISION) {
                    return REVISION.beforeRoot && REVISION.beforeRoot();
                })).then(function () {
                    return Promise.all([
                        n.getDependencies('scene'),
                        n.getDependencies('animation'),
                        n.getDependencies('camera')
                    ]);
                }).then(function (t) {
                    const AddEquation = {
                        scene: t[0][i.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return ru(r, AddEquation, i), au(AddEquation, i), Promise.all(n._invokeAll(function (REVISION) {
                        return REVISION.afterRoot && REVISION.afterRoot(AddEquation);
                    })).then(function () {
                        for (const REVISION of AddEquation.scenes)
                            REVISION.updateMatrixWorld();
                        REVISION(AddEquation);
                    });
                }).catch(t);
            }
            _markDefs() {
                const REVISION = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n].joints;
                    for (let t = 0, n = i.length; t < n; t++)
                        REVISION[i[t]].isBone = !0;
                }
                for (let t = 0, i = REVISION.length; t < i; t++) {
                    const i = REVISION[t];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera);
                }
            }
            _addNodeRef(REVISION, t) {
                void 0 !== t && (void 0 === REVISION.refs[t] && (REVISION.refs[t] = REVISION.uses[t] = 0), REVISION.refs[t]++);
            }
            _getNodeRef(REVISION, t, n) {
                if (REVISION.refs[t] <= 1)
                    return n;
                const i = n.clone(), r = (REVISION, t) => {
                        const n = this.associations.get(REVISION);
                        null != n && this.associations.set(t, n);
                        for (const [n, i] of REVISION.children.entries())
                            r(i, t.children[n]);
                    };
                return r(n, i), i.name += '_instance_' + REVISION.uses[t]++, i;
            }
            _invokeOne(REVISION) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = REVISION(t[n]);
                    if (i)
                        return i;
                }
                return null;
            }
            _invokeAll(REVISION) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = REVISION(t[i]);
                    r && n.push(r);
                }
                return n;
            }
            getDependency(REVISION, t) {
                const n = REVISION + ':' + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (REVISION) {
                    case 'scene':
                        i = this.loadScene(t);
                        break;
                    case 'node':
                        i = this._invokeOne(function (REVISION) {
                            return REVISION.loadNode && REVISION.loadNode(t);
                        });
                        break;
                    case 'mesh':
                        i = this._invokeOne(function (REVISION) {
                            return REVISION.loadMesh && REVISION.loadMesh(t);
                        });
                        break;
                    case 'accessor':
                        i = this.loadAccessor(t);
                        break;
                    case 'bufferView':
                        i = this._invokeOne(function (REVISION) {
                            return REVISION.loadBufferView && REVISION.loadBufferView(t);
                        });
                        break;
                    case 'buffer':
                        i = this.loadBuffer(t);
                        break;
                    case 'material':
                        i = this._invokeOne(function (REVISION) {
                            return REVISION.loadMaterial && REVISION.loadMaterial(t);
                        });
                        break;
                    case 'texture':
                        i = this._invokeOne(function (REVISION) {
                            return REVISION.loadTexture && REVISION.loadTexture(t);
                        });
                        break;
                    case 'skin':
                        i = this.loadSkin(t);
                        break;
                    case 'animation':
                        i = this._invokeOne(function (REVISION) {
                            return REVISION.loadAnimation && REVISION.loadAnimation(t);
                        });
                        break;
                    case 'camera':
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne(function (n) {
                                return n != this && n.getDependency && n.getDependency(REVISION, t);
                            }), !i)
                            throw new Error('Unknown type: ' + REVISION);
                    }
                    this.cache.add(n, i);
                }
                return i;
            }
            getDependencies(REVISION) {
                let t = this.cache.get(REVISION);
                if (!t) {
                    const n = this, i = this.json[REVISION + ('mesh' === REVISION ? 'es' : 's')] || [];
                    t = Promise.all(i.map(function (t, i) {
                        return n.getDependency(REVISION, i);
                    })), this.cache.add(REVISION, t);
                }
                return t;
            }
            loadBuffer(REVISION) {
                const t = this.json.buffers[REVISION], n = this.fileLoader;
                if (t.type && 'arraybuffer' !== t.type)
                    throw new Error('THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.');
                if (void 0 === t.uri && 0 === REVISION)
                    return Promise.resolve(this.extensions[_d.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise(function (REVISION, r) {
                    n.load(LoaderUtils.resolveURL(t.uri, i.path), REVISION, void 0, function () {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
                    });
                });
            }
            loadBufferView(REVISION) {
                const t = this.json.bufferViews[REVISION];
                return this.getDependency('buffer', t.buffer).then(function (REVISION) {
                    const n = t.byteLength || 0, i = t.byteOffset || 0;
                    return REVISION.slice(i, i + n);
                });
            }
            loadAccessor(REVISION) {
                const t = this, n = this.json, i = this.json.accessors[REVISION];
                if (void 0 === i.bufferView && void 0 === i.sparse) {
                    const REVISION = Zd[i.type], t = qd[i.componentType], n = !0 === i.normalized, r = new t(i.count * REVISION);
                    return Promise.resolve(new BufferAttribute(r, REVISION, n));
                }
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency('bufferView', i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency('bufferView', i.sparse.indices.bufferView)), r.push(this.getDependency('bufferView', i.sparse.values.bufferView))), Promise.all(r).then(function (REVISION) {
                    const r = REVISION[0], AddEquation = Zd[i.type], SubtractEquation = qd[i.componentType], ReverseSubtractEquation = SubtractEquation.BYTES_PER_ELEMENT, ZeroFactor = ReverseSubtractEquation * AddEquation, OneFactor = i.byteOffset || 0, SrcColorFactor = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, OneMinusSrcColorFactor = !0 === i.normalized;
                    let SrcAlphaFactor, OneMinusSrcAlphaFactor;
                    if (SrcColorFactor && SrcColorFactor !== ZeroFactor) {
                        const REVISION = Math.floor(OneFactor / SrcColorFactor), n = 'InterleavedBuffer:' + i.bufferView + ':' + i.componentType + ':' + REVISION + ':' + i.count;
                        let ZeroFactor = t.cache.get(n);
                        ZeroFactor || (SrcAlphaFactor = new SubtractEquation(r, REVISION * SrcColorFactor, i.count * SrcColorFactor / ReverseSubtractEquation), ZeroFactor = new InterleavedBuffer(SrcAlphaFactor, SrcColorFactor / ReverseSubtractEquation), t.cache.add(n, ZeroFactor)), OneMinusSrcAlphaFactor = new InterleavedBufferAttribute(ZeroFactor, AddEquation, OneFactor % SrcColorFactor / ReverseSubtractEquation, OneMinusSrcColorFactor);
                    } else
                        SrcAlphaFactor = null === r ? new SubtractEquation(i.count * AddEquation) : new SubtractEquation(r, OneFactor, i.count * AddEquation), OneMinusSrcAlphaFactor = new BufferAttribute(SrcAlphaFactor, AddEquation, OneMinusSrcColorFactor);
                    if (void 0 !== i.sparse) {
                        const t = Zd.SCALAR, n = qd[i.sparse.indices.componentType], ReverseSubtractEquation = i.sparse.indices.byteOffset || 0, ZeroFactor = i.sparse.values.byteOffset || 0, OneFactor = new n(REVISION[1], ReverseSubtractEquation, i.sparse.count * t), SrcColorFactor = new SubtractEquation(REVISION[2], ZeroFactor, i.sparse.count * AddEquation);
                        null !== r && (OneMinusSrcAlphaFactor = new BufferAttribute(OneMinusSrcAlphaFactor.array.slice(), OneMinusSrcAlphaFactor.itemSize, OneMinusSrcAlphaFactor.normalized)), OneMinusSrcAlphaFactor.normalized = !1;
                        for (let REVISION = 0, t = OneFactor.length; REVISION < t; REVISION++) {
                            const t = OneFactor[REVISION];
                            if (OneMinusSrcAlphaFactor.setX(t, SrcColorFactor[REVISION * AddEquation]), AddEquation >= 2 && OneMinusSrcAlphaFactor.setY(t, SrcColorFactor[REVISION * AddEquation + 1]), AddEquation >= 3 && OneMinusSrcAlphaFactor.setZ(t, SrcColorFactor[REVISION * AddEquation + 2]), AddEquation >= 4 && OneMinusSrcAlphaFactor.setW(t, SrcColorFactor[REVISION * AddEquation + 3]), AddEquation >= 5)
                                throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
                        }
                        OneMinusSrcAlphaFactor.normalized = OneMinusSrcColorFactor;
                    }
                    return OneMinusSrcAlphaFactor;
                });
            }
            loadTexture(REVISION) {
                const t = this.json, n = this.options, i = t.textures[REVISION].source, r = t.images[i];
                let AddEquation = this.textureLoader;
                if (r.uri) {
                    const REVISION = n.manager.getHandler(r.uri);
                    null !== REVISION && (AddEquation = REVISION);
                }
                return this.loadTextureImage(REVISION, i, AddEquation);
            }
            loadTextureImage(REVISION, t, n) {
                const i = this, r = this.json, AddEquation = r.textures[REVISION], SubtractEquation = r.images[t], ReverseSubtractEquation = (SubtractEquation.uri || SubtractEquation.bufferView) + ':' + AddEquation.sampler;
                if (this.textureCache[ReverseSubtractEquation])
                    return this.textureCache[ReverseSubtractEquation];
                const ZeroFactor = this.loadImageSource(t, n).then(function (t) {
                    t.flipY = !1, t.name = AddEquation.name || SubtractEquation.name || '', '' === t.name && 'string' == typeof SubtractEquation.uri && !1 === SubtractEquation.uri.startsWith('data:image/') && (t.name = SubtractEquation.uri);
                    const n = (r.samplers || {})[AddEquation.sampler] || {};
                    return t.magFilter = Yd[n.magFilter] || LinearFilter, t.minFilter = Yd[n.minFilter] || LinearMipMapLinearFilter, t.wrapS = Kd[n.wrapS] || RepeatWrapping, t.wrapT = Kd[n.wrapT] || RepeatWrapping, t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== NearestFilter && t.minFilter !== LinearFilter, i.associations.set(t, { textures: REVISION }), t;
                }).catch(function () {
                    return null;
                });
                return this.textureCache[ReverseSubtractEquation] = ZeroFactor, ZeroFactor;
            }
            loadImageSource(REVISION, t) {
                const n = this, i = this.json, r = this.options;
                if (void 0 !== this.sourceCache[REVISION])
                    return this.sourceCache[REVISION].then(REVISION => REVISION.clone());
                const AddEquation = i.images[REVISION], SubtractEquation = self.URL || self.webkitURL;
                let ReverseSubtractEquation = AddEquation.uri || '', ZeroFactor = !1;
                if (void 0 !== AddEquation.bufferView)
                    ReverseSubtractEquation = n.getDependency('bufferView', AddEquation.bufferView).then(function (REVISION) {
                        ZeroFactor = !0;
                        const t = new Blob([REVISION], { type: AddEquation.mimeType });
                        return ReverseSubtractEquation = SubtractEquation.createObjectURL(t), ReverseSubtractEquation;
                    });
                else if (void 0 === AddEquation.uri)
                    throw new Error('THREE.GLTFLoader: Image ' + REVISION + ' is missing URI and bufferView');
                const OneFactor = Promise.resolve(ReverseSubtractEquation).then(function (REVISION) {
                    return new Promise(function (n, i) {
                        let AddEquation = n;
                        !0 === t.isImageBitmapLoader && (AddEquation = function (REVISION) {
                            const t = new Texture(REVISION);
                            t.needsUpdate = !0, n(t);
                        }), t.load(LoaderUtils.resolveURL(REVISION, r.path), AddEquation, void 0, i);
                    });
                }).then(function (REVISION) {
                    var t;
                    return !0 === ZeroFactor && SubtractEquation.revokeObjectURL(ReverseSubtractEquation), au(REVISION, AddEquation), REVISION.userData.mimeType = AddEquation.mimeType || ((t = AddEquation.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? 'image/jpeg' : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? 'image/webp' : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? 'image/ktx2' : 'image/png'), REVISION;
                }).catch(function (REVISION) {
                    throw console.error('THREE.GLTFLoader: Couldn\'t load texture', ReverseSubtractEquation), REVISION;
                });
                return this.sourceCache[REVISION] = OneFactor, OneFactor;
            }
            assignTexture(REVISION, t, n, i) {
                const r = this;
                return this.getDependency('texture', n.index).then(function (AddEquation) {
                    if (!AddEquation)
                        return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((AddEquation = AddEquation.clone()).channel = n.texCoord), r.extensions[_d.KHR_TEXTURE_TRANSFORM]) {
                        const REVISION = void 0 !== n.extensions ? n.extensions[_d.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (REVISION) {
                            const t = r.associations.get(AddEquation);
                            AddEquation = r.extensions[_d.KHR_TEXTURE_TRANSFORM].extendTexture(AddEquation, REVISION), r.associations.set(AddEquation, t);
                        }
                    }
                    return void 0 !== i && (AddEquation.colorSpace = i), REVISION[t] = AddEquation, AddEquation;
                });
            }
            assignFinalMaterial(REVISION) {
                const t = REVISION.geometry;
                let n = REVISION.material;
                const i = void 0 === t.attributes.tangent, r = void 0 !== t.attributes.color, AddEquation = void 0 === t.attributes.normal;
                if (REVISION.isPoints) {
                    const REVISION = 'PointsMaterial:' + n.uuid;
                    let t = this.cache.get(REVISION);
                    t || (t = new fa(), Material.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(REVISION, t)), n = t;
                } else if (REVISION.isLine) {
                    const REVISION = 'LineBasicMaterial:' + n.uuid;
                    let t = this.cache.get(REVISION);
                    t || (t = new $r(), Material.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(REVISION, t)), n = t;
                }
                if (i || r || AddEquation) {
                    let REVISION = 'ClonedMaterial:' + n.uuid + ':';
                    i && (REVISION += 'derivative-tangents:'), r && (REVISION += 'vertex-colors:'), AddEquation && (REVISION += 'flat-shading:');
                    let t = this.cache.get(REVISION);
                    t || (t = n.clone(), r && (t.vertexColors = !0), AddEquation && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(REVISION, t), this.associations.set(t, this.associations.get(n))), n = t;
                }
                REVISION.material = n;
            }
            getMaterialType() {
                return xa;
            }
            loadMaterial(REVISION) {
                const t = this, n = this.json, i = this.extensions, r = n.materials[REVISION];
                let AddEquation;
                const SubtractEquation = {}, ReverseSubtractEquation = [];
                if ((r.extensions || {})[_d.KHR_MATERIALS_UNLIT]) {
                    const REVISION = i[_d.KHR_MATERIALS_UNLIT];
                    AddEquation = REVISION.getMaterialType(), ReverseSubtractEquation.push(REVISION.extendParams(SubtractEquation, r, t));
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (SubtractEquation.color = new Color(1, 1, 1), SubtractEquation.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const REVISION = n.baseColorFactor;
                        SubtractEquation.color.setRGB(REVISION[0], REVISION[1], REVISION[2], LinearSRGBColorSpace), SubtractEquation.opacity = REVISION[3];
                    }
                    void 0 !== n.baseColorTexture && ReverseSubtractEquation.push(t.assignTexture(SubtractEquation, 'map', n.baseColorTexture, Ye)), SubtractEquation.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, SubtractEquation.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (ReverseSubtractEquation.push(t.assignTexture(SubtractEquation, 'metalnessMap', n.metallicRoughnessTexture)), ReverseSubtractEquation.push(t.assignTexture(SubtractEquation, 'roughnessMap', n.metallicRoughnessTexture))), AddEquation = this._invokeOne(function (t) {
                        return t.getMaterialType && t.getMaterialType(REVISION);
                    }), ReverseSubtractEquation.push(Promise.all(this._invokeAll(function (t) {
                        return t.extendMaterialParams && t.extendMaterialParams(REVISION, SubtractEquation);
                    })));
                }
                !0 === r.doubleSided && (SubtractEquation.side = 2);
                const ZeroFactor = r.alphaMode || tu;
                if (ZeroFactor === iu ? (SubtractEquation.transparent = !0, SubtractEquation.depthWrite = !1) : (SubtractEquation.transparent = !1, ZeroFactor === nu && (SubtractEquation.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)), void 0 !== r.normalTexture && AddEquation !== Si && (ReverseSubtractEquation.push(t.assignTexture(SubtractEquation, 'normalMap', r.normalTexture)), SubtractEquation.normalScale = new Vector2(1, 1), void 0 !== r.normalTexture.scale)) {
                    const REVISION = r.normalTexture.scale;
                    SubtractEquation.normalScale.set(REVISION, REVISION);
                }
                if (void 0 !== r.occlusionTexture && AddEquation !== Si && (ReverseSubtractEquation.push(t.assignTexture(SubtractEquation, 'aoMap', r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (SubtractEquation.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && AddEquation !== Si) {
                    const REVISION = r.emissiveFactor;
                    SubtractEquation.emissive = new Color().setRGB(REVISION[0], REVISION[1], REVISION[2], LinearSRGBColorSpace);
                }
                return void 0 !== r.emissiveTexture && AddEquation !== Si && ReverseSubtractEquation.push(t.assignTexture(SubtractEquation, 'emissiveMap', r.emissiveTexture, Ye)), Promise.all(ReverseSubtractEquation).then(function () {
                    const n = new AddEquation(SubtractEquation);
                    return r.name && (n.name = r.name), au(n, r), t.associations.set(n, { materials: REVISION }), r.extensions && ru(i, n, r), n;
                });
            }
            createUniqueName(REVISION) {
                const t = PropertyBinding.sanitizeNodeName(REVISION || '');
                return t in this.nodeNamesUsed ? t + '_' + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
            }
            loadGeometries(REVISION) {
                const t = this, n = this.extensions, i = this.primitiveCache;
                function r(REVISION) {
                    return n[_d.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(REVISION, t).then(function (n) {
                        return uu(n, REVISION, t);
                    });
                }
                const AddEquation = [];
                for (let n = 0, SubtractEquation = REVISION.length; n < SubtractEquation; n++) {
                    const SubtractEquation = REVISION[n], ReverseSubtractEquation = ou(SubtractEquation), ZeroFactor = i[ReverseSubtractEquation];
                    if (ZeroFactor)
                        AddEquation.push(ZeroFactor.promise);
                    else {
                        let REVISION;
                        REVISION = SubtractEquation.extensions && SubtractEquation.extensions[_d.KHR_DRACO_MESH_COMPRESSION] ? r(SubtractEquation) : uu(new BufferGeometry(), SubtractEquation, t), i[ReverseSubtractEquation] = {
                            primitive: SubtractEquation,
                            promise: REVISION
                        }, AddEquation.push(REVISION);
                    }
                }
                return Promise.all(AddEquation);
            }
            loadMesh(REVISION) {
                const t = this, n = this.json, i = this.extensions, r = n.meshes[REVISION], AddEquation = r.primitives, SubtractEquation = [];
                for (let REVISION = 0, t = AddEquation.length; REVISION < t; REVISION++) {
                    const t = void 0 === AddEquation[REVISION].material ? (void 0 === (ReverseSubtractEquation = this.cache).DefaultMaterial && (ReverseSubtractEquation.DefaultMaterial = new xa({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0
                    })), ReverseSubtractEquation.DefaultMaterial) : this.getDependency('material', AddEquation[REVISION].material);
                    SubtractEquation.push(t);
                }
                var ReverseSubtractEquation;
                return SubtractEquation.push(t.loadGeometries(AddEquation)), Promise.all(SubtractEquation).then(function (n) {
                    const SubtractEquation = n.slice(0, n.length - 1), ReverseSubtractEquation = n[n.length - 1], ZeroFactor = [];
                    for (let n = 0, OneFactor = ReverseSubtractEquation.length; n < OneFactor; n++) {
                        const OneFactor = ReverseSubtractEquation[n], SrcColorFactor = AddEquation[n];
                        let OneMinusSrcColorFactor;
                        const SrcAlphaFactor = SubtractEquation[n];
                        if (SrcColorFactor.mode === jd.TRIANGLES || SrcColorFactor.mode === jd.TRIANGLE_STRIP || SrcColorFactor.mode === jd.TRIANGLE_FAN || void 0 === SrcColorFactor.mode)
                            OneMinusSrcColorFactor = !0 === r.isSkinnedMesh ? new SkinnedMesh(OneFactor, SrcAlphaFactor) : new Mesh(OneFactor, SrcAlphaFactor), !0 === OneMinusSrcColorFactor.isSkinnedMesh && OneMinusSrcColorFactor.normalizeSkinWeights(), SrcColorFactor.mode === jd.TRIANGLE_STRIP ? OneMinusSrcColorFactor.geometry = md(OneMinusSrcColorFactor.geometry, 1) : SrcColorFactor.mode === jd.TRIANGLE_FAN && (OneMinusSrcColorFactor.geometry = md(OneMinusSrcColorFactor.geometry, 2));
                        else if (SrcColorFactor.mode === jd.LINES)
                            OneMinusSrcColorFactor = new LineSegments(OneFactor, SrcAlphaFactor);
                        else if (SrcColorFactor.mode === jd.LINE_STRIP)
                            OneMinusSrcColorFactor = new Line(OneFactor, SrcAlphaFactor);
                        else if (SrcColorFactor.mode === jd.LINE_LOOP)
                            OneMinusSrcColorFactor = new ua(OneFactor, SrcAlphaFactor);
                        else {
                            if (SrcColorFactor.mode !== jd.POINTS)
                                throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + SrcColorFactor.mode);
                            OneMinusSrcColorFactor = new Points(OneFactor, SrcAlphaFactor);
                        }
                        Object.keys(OneMinusSrcColorFactor.geometry.morphAttributes).length > 0 && su(OneMinusSrcColorFactor, r), OneMinusSrcColorFactor.name = t.createUniqueName(r.name || 'mesh_' + REVISION), au(OneMinusSrcColorFactor, r), SrcColorFactor.extensions && ru(i, OneMinusSrcColorFactor, SrcColorFactor), t.assignFinalMaterial(OneMinusSrcColorFactor), ZeroFactor.push(OneMinusSrcColorFactor);
                    }
                    for (let n = 0, i = ZeroFactor.length; n < i; n++)
                        t.associations.set(ZeroFactor[n], {
                            meshes: REVISION,
                            primitives: n
                        });
                    if (1 === ZeroFactor.length)
                        return r.extensions && ru(i, ZeroFactor[0], r), ZeroFactor[0];
                    const OneFactor = new pr();
                    r.extensions && ru(i, OneFactor, r), t.associations.set(OneFactor, { meshes: REVISION });
                    for (let REVISION = 0, t = ZeroFactor.length; REVISION < t; REVISION++)
                        OneFactor.add(ZeroFactor[REVISION]);
                    return OneFactor;
                });
            }
            loadCamera(REVISION) {
                let t;
                const n = this.json.cameras[REVISION], i = n[n.type];
                if (i)
                    return 'perspective' === n.type ? t = new PerspectiveCamera(bt.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2000000) : 'orthographic' === n.type && (t = new OrthographicCamera(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), au(t, n), Promise.resolve(t);
                console.warn('THREE.GLTFLoader: Missing camera parameters.');
            }
            loadSkin(REVISION) {
                const t = this.json.skins[REVISION], n = [];
                for (let REVISION = 0, i = t.joints.length; REVISION < i; REVISION++)
                    n.push(this._loadNodeShallow(t.joints[REVISION]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency('accessor', t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function (REVISION) {
                    const n = REVISION.pop(), i = REVISION, r = [], AddEquation = [];
                    for (let REVISION = 0, SubtractEquation = i.length; REVISION < SubtractEquation; REVISION++) {
                        const SubtractEquation = i[REVISION];
                        if (SubtractEquation) {
                            r.push(SubtractEquation);
                            const t = new Matrix4();
                            null !== n && t.fromArray(n.array, 16 * REVISION), AddEquation.push(t);
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[REVISION]);
                    }
                    return new Skeleton(r, AddEquation);
                });
            }
            loadAnimation(REVISION) {
                const t = this.json, n = this, i = t.animations[REVISION], r = i.name ? i.name : 'animation_' + REVISION, AddEquation = [], SubtractEquation = [], ReverseSubtractEquation = [], ZeroFactor = [], OneFactor = [];
                for (let REVISION = 0, t = i.channels.length; REVISION < t; REVISION++) {
                    const t = i.channels[REVISION], n = i.samplers[t.sampler], r = t.target, SrcColorFactor = r.node, OneMinusSrcColorFactor = void 0 !== i.parameters ? i.parameters[n.input] : n.input, SrcAlphaFactor = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                    void 0 !== r.node && (AddEquation.push(this.getDependency('node', SrcColorFactor)), SubtractEquation.push(this.getDependency('accessor', OneMinusSrcColorFactor)), ReverseSubtractEquation.push(this.getDependency('accessor', SrcAlphaFactor)), ZeroFactor.push(n), OneFactor.push(r));
                }
                return Promise.all([
                    Promise.all(AddEquation),
                    Promise.all(SubtractEquation),
                    Promise.all(ReverseSubtractEquation),
                    Promise.all(ZeroFactor),
                    Promise.all(OneFactor)
                ]).then(function (REVISION) {
                    const t = REVISION[0], i = REVISION[1], AddEquation = REVISION[2], SubtractEquation = REVISION[3], ReverseSubtractEquation = REVISION[4], ZeroFactor = [];
                    for (let REVISION = 0, r = t.length; REVISION < r; REVISION++) {
                        const r = t[REVISION], OneFactor = i[REVISION], SrcColorFactor = AddEquation[REVISION], OneMinusSrcColorFactor = SubtractEquation[REVISION], SrcAlphaFactor = ReverseSubtractEquation[REVISION];
                        if (void 0 === r)
                            continue;
                        r.updateMatrix && r.updateMatrix();
                        const OneMinusSrcAlphaFactor = n._createAnimationTracks(r, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor);
                        if (OneMinusSrcAlphaFactor)
                            for (let REVISION = 0; REVISION < OneMinusSrcAlphaFactor.length; REVISION++)
                                ZeroFactor.push(OneMinusSrcAlphaFactor[REVISION]);
                    }
                    return new AnimationClip(r, void 0, ZeroFactor);
                });
            }
            createNodeMesh(REVISION) {
                const t = this.json, n = this, i = t.nodes[REVISION];
                return void 0 === i.mesh ? null : n.getDependency('mesh', i.mesh).then(function (REVISION) {
                    const t = n._getNodeRef(n.meshCache, i.mesh, REVISION);
                    return void 0 !== i.weights && t.traverse(function (REVISION) {
                        if (REVISION.isMesh)
                            for (let t = 0, n = i.weights.length; t < n; t++)
                                REVISION.morphTargetInfluences[t] = i.weights[t];
                    }), t;
                });
            }
            loadNode(REVISION) {
                const t = this, n = this.json.nodes[REVISION], i = t._loadNodeShallow(REVISION), r = [], AddEquation = n.children || [];
                for (let REVISION = 0, n = AddEquation.length; REVISION < n; REVISION++)
                    r.push(t.getDependency('node', AddEquation[REVISION]));
                const SubtractEquation = void 0 === n.skin ? Promise.resolve(null) : t.getDependency('skin', n.skin);
                return Promise.all([
                    i,
                    Promise.all(r),
                    SubtractEquation
                ]).then(function (REVISION) {
                    const t = REVISION[0], n = REVISION[1], i = REVISION[2];
                    null !== i && t.traverse(function (REVISION) {
                        REVISION.isSkinnedMesh && REVISION.bind(i, _scale$1);
                    });
                    for (let REVISION = 0, i = n.length; REVISION < i; REVISION++)
                        t.add(n[REVISION]);
                    return t;
                });
            }
            _loadNodeShallow(REVISION) {
                const t = this.json, n = this.extensions, i = this;
                if (void 0 !== this.nodeCache[REVISION])
                    return this.nodeCache[REVISION];
                const r = t.nodes[REVISION], AddEquation = r.name ? i.createUniqueName(r.name) : '', SubtractEquation = [], ReverseSubtractEquation = i._invokeOne(function (t) {
                        return t.createNodeMesh && t.createNodeMesh(REVISION);
                    });
                return ReverseSubtractEquation && SubtractEquation.push(ReverseSubtractEquation), void 0 !== r.camera && SubtractEquation.push(i.getDependency('camera', r.camera).then(function (REVISION) {
                    return i._getNodeRef(i.cameraCache, r.camera, REVISION);
                })), i._invokeAll(function (t) {
                    return t.createNodeAttachment && t.createNodeAttachment(REVISION);
                }).forEach(function (REVISION) {
                    SubtractEquation.push(REVISION);
                }), this.nodeCache[REVISION] = Promise.all(SubtractEquation).then(function (t) {
                    let SubtractEquation;
                    if (SubtractEquation = !0 === r.isBone ? new Br() : t.length > 1 ? new pr() : 1 === t.length ? t[0] : new Object3D(), SubtractEquation !== t[0])
                        for (let REVISION = 0, n = t.length; REVISION < n; REVISION++)
                            SubtractEquation.add(t[REVISION]);
                    if (r.name && (SubtractEquation.userData.name = r.name, SubtractEquation.name = AddEquation), au(SubtractEquation, r), r.extensions && ru(n, SubtractEquation, r), void 0 !== r.matrix) {
                        const REVISION = new Matrix4();
                        REVISION.fromArray(r.matrix), SubtractEquation.applyMatrix4(REVISION);
                    } else
                        void 0 !== r.translation && SubtractEquation.position.fromArray(r.translation), void 0 !== r.rotation && SubtractEquation.quaternion.fromArray(r.rotation), void 0 !== r.scale && SubtractEquation.scale.fromArray(r.scale);
                    return i.associations.has(SubtractEquation) || i.associations.set(SubtractEquation, {}), i.associations.get(SubtractEquation).nodes = REVISION, SubtractEquation;
                }), this.nodeCache[REVISION];
            }
            loadScene(REVISION) {
                const t = this.extensions, n = this.json.scenes[REVISION], i = this, r = new pr();
                n.name && (r.name = i.createUniqueName(n.name)), au(r, n), n.extensions && ru(t, r, n);
                const AddEquation = n.nodes || [], SubtractEquation = [];
                for (let REVISION = 0, t = AddEquation.length; REVISION < t; REVISION++)
                    SubtractEquation.push(i.getDependency('node', AddEquation[REVISION]));
                return Promise.all(SubtractEquation).then(function (REVISION) {
                    for (let t = 0, n = REVISION.length; t < n; t++)
                        r.add(REVISION[t]);
                    return i.associations = (REVISION => {
                        const t = new Map();
                        for (const [REVISION, n] of i.associations)
                            (REVISION instanceof Material || REVISION instanceof Texture) && t.set(REVISION, n);
                        return REVISION.traverse(REVISION => {
                            const n = i.associations.get(REVISION);
                            null != n && t.set(REVISION, n);
                        }), t;
                    })(r), r;
                });
            }
            _createAnimationTracks(REVISION, t, n, i, r) {
                const AddEquation = [], SubtractEquation = REVISION.name ? REVISION.name : REVISION.uuid, ReverseSubtractEquation = [];
                let ZeroFactor;
                switch ($d[r.path] === $d.weights ? REVISION.traverse(function (REVISION) {
                        REVISION.morphTargetInfluences && ReverseSubtractEquation.push(REVISION.name ? REVISION.name : REVISION.uuid);
                    }) : ReverseSubtractEquation.push(SubtractEquation), $d[r.path]) {
                case $d.weights:
                    ZeroFactor = Fa;
                    break;
                case $d.rotation:
                    ZeroFactor = QuaternionKeyframeTrack;
                    break;
                case $d.position:
                case $d.scale:
                    ZeroFactor = VectorKeyframeTrack;
                    break;
                default:
                    if (1 === n.itemSize)
                        ZeroFactor = Fa;
                    else
                        ZeroFactor = VectorKeyframeTrack;
                }
                const OneFactor = void 0 !== i.interpolation ? eu[i.interpolation] : InterpolateLinear, SrcColorFactor = this._getArrayFromAccessor(n);
                for (let REVISION = 0, n = ReverseSubtractEquation.length; REVISION < n; REVISION++) {
                    const n = new ZeroFactor(ReverseSubtractEquation[REVISION] + '.' + $d[r.path], t.array, SrcColorFactor, OneFactor);
                    'CUBICSPLINE' === i.interpolation && this._createCubicSplineTrackInterpolant(n), AddEquation.push(n);
                }
                return AddEquation;
            }
            _getArrayFromAccessor(REVISION) {
                let t = REVISION.array;
                if (REVISION.normalized) {
                    const REVISION = cu(t.constructor), n = new Float32Array(t.length);
                    for (let i = 0, r = t.length; i < r; i++)
                        n[i] = t[i] * REVISION;
                    t = n;
                }
                return t;
            }
            _createCubicSplineTrackInterpolant(REVISION) {
                REVISION.createInterpolant = function (REVISION) {
                    return new (this instanceof QuaternionKeyframeTrack ? Xd : Gd)(this.times, this.values, this.getValueSize() / 3, REVISION);
                }, REVISION.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
            }
        }
        function uu(REVISION, t, n) {
            const i = t.attributes, r = [];
            function AddEquation(t, i) {
                return n.getDependency('accessor', t).then(function (t) {
                    REVISION.setAttribute(i, t);
                });
            }
            for (const t in i) {
                const n = Jd[t] || t.toLowerCase();
                n in REVISION.attributes || r.push(AddEquation(i[t], n));
            }
            if (void 0 !== t.indices && !REVISION.index) {
                const i = n.getDependency('accessor', t.indices).then(function (t) {
                    REVISION.setIndex(t);
                });
                r.push(i);
            }
            return _tables.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ _tables.workingColorSpace }" not supported.`), au(REVISION, t), function (REVISION, t, n) {
                const i = t.attributes, r = new Box3();
                if (void 0 === i.POSITION)
                    return;
                {
                    const REVISION = n.json.accessors[i.POSITION], t = REVISION.min, AddEquation = REVISION.max;
                    if (void 0 === t || void 0 === AddEquation)
                        return void console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
                    if (r.set(new Vector3(t[0], t[1], t[2]), new Vector3(AddEquation[0], AddEquation[1], AddEquation[2])), REVISION.normalized) {
                        const t = cu(qd[REVISION.componentType]);
                        r.min.multiplyScalar(t), r.max.multiplyScalar(t);
                    }
                }
                const AddEquation = t.targets;
                if (void 0 !== AddEquation) {
                    const REVISION = new Vector3(), t = new Vector3();
                    for (let i = 0, r = AddEquation.length; i < r; i++) {
                        const r = AddEquation[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION], AddEquation = i.min, SubtractEquation = i.max;
                            if (void 0 !== AddEquation && void 0 !== SubtractEquation) {
                                if (t.setX(Math.max(Math.abs(AddEquation[0]), Math.abs(SubtractEquation[0]))), t.setY(Math.max(Math.abs(AddEquation[1]), Math.abs(SubtractEquation[1]))), t.setZ(Math.max(Math.abs(AddEquation[2]), Math.abs(SubtractEquation[2]))), i.normalized) {
                                    const REVISION = cu(qd[i.componentType]);
                                    t.multiplyScalar(REVISION);
                                }
                                REVISION.max(t);
                            } else
                                console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
                        }
                    }
                    r.expandByVector(REVISION);
                }
                REVISION.boundingBox = r;
                const SubtractEquation = new Sphere();
                r.getCenter(SubtractEquation.center), SubtractEquation.radius = r.min.distanceTo(r.max) / 2, REVISION.boundingSphere = SubtractEquation;
            }(REVISION, t, n), Promise.all(r).then(function () {
                return void 0 !== t.targets ? function (REVISION, t, n) {
                    let i = !1, r = !1, AddEquation = !1;
                    for (let REVISION = 0, n = t.length; REVISION < n; REVISION++) {
                        const n = t[REVISION];
                        if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (AddEquation = !0), i && r && AddEquation)
                            break;
                    }
                    if (!i && !r && !AddEquation)
                        return Promise.resolve(REVISION);
                    const SubtractEquation = [], ReverseSubtractEquation = [], ZeroFactor = [];
                    for (let OneFactor = 0, SrcColorFactor = t.length; OneFactor < SrcColorFactor; OneFactor++) {
                        const SrcColorFactor = t[OneFactor];
                        if (i) {
                            const t = void 0 !== SrcColorFactor.POSITION ? n.getDependency('accessor', SrcColorFactor.POSITION) : REVISION.attributes.position;
                            SubtractEquation.push(t);
                        }
                        if (r) {
                            const t = void 0 !== SrcColorFactor.NORMAL ? n.getDependency('accessor', SrcColorFactor.NORMAL) : REVISION.attributes.normal;
                            ReverseSubtractEquation.push(t);
                        }
                        if (AddEquation) {
                            const t = void 0 !== SrcColorFactor.COLOR_0 ? n.getDependency('accessor', SrcColorFactor.COLOR_0) : REVISION.attributes.color;
                            ZeroFactor.push(t);
                        }
                    }
                    return Promise.all([
                        Promise.all(SubtractEquation),
                        Promise.all(ReverseSubtractEquation),
                        Promise.all(ZeroFactor)
                    ]).then(function (t) {
                        const n = t[0], SubtractEquation = t[1], ReverseSubtractEquation = t[2];
                        return i && (REVISION.morphAttributes.position = n), r && (REVISION.morphAttributes.normal = SubtractEquation), AddEquation && (REVISION.morphAttributes.color = ReverseSubtractEquation), REVISION.morphTargetsRelative = !0, REVISION;
                    });
                }(REVISION, t.targets, n) : REVISION;
            });
        }
        function fu() {
            let REVISION = null, t = !1, n = null, i = null;
            function r(t, AddEquation) {
                n(t, AddEquation), i = REVISION.requestAnimationFrame(r);
            }
            return {
                start: function () {
                    !0 !== t && null !== n && (i = REVISION.requestAnimationFrame(r), t = !0);
                },
                stop: function () {
                    REVISION.cancelAnimationFrame(i), t = !1;
                },
                setAnimationLoop: function (REVISION) {
                    n = REVISION;
                },
                setContext: function (t) {
                    REVISION = t;
                }
            };
        }
        function pu(REVISION) {
            const t = new WeakMap();
            return {
                get: function (REVISION) {
                    return REVISION.isInterleavedBufferAttribute && (REVISION = REVISION.data), t.get(REVISION);
                },
                remove: function (n) {
                    n.isInterleavedBufferAttribute && (n = n.data);
                    const i = t.get(n);
                    i && (REVISION.deleteBuffer(i.buffer), t.delete(n));
                },
                update: function (n, i) {
                    if (n.isInterleavedBufferAttribute && (n = n.data), n.isGLBufferAttribute) {
                        const REVISION = t.get(n);
                        return void ((!REVISION || REVISION.version < n.version) && t.set(n, {
                            buffer: n.buffer,
                            type: n.type,
                            bytesPerElement: n.elementSize,
                            version: n.version
                        }));
                    }
                    const r = t.get(n);
                    if (void 0 === r)
                        t.set(n, function (t, n) {
                            const i = t.array, r = t.usage, AddEquation = i.byteLength, SubtractEquation = REVISION.createBuffer();
                            let ReverseSubtractEquation;
                            if (REVISION.bindBuffer(n, SubtractEquation), REVISION.bufferData(n, i, r), t.onUploadCallback(), i instanceof Float32Array)
                                ReverseSubtractEquation = REVISION.FLOAT;
                            else if (i instanceof Uint16Array)
                                ReverseSubtractEquation = t.isFloat16BufferAttribute ? REVISION.HALF_FLOAT : REVISION.UNSIGNED_SHORT;
                            else if (i instanceof Int16Array)
                                ReverseSubtractEquation = REVISION.SHORT;
                            else if (i instanceof Uint32Array)
                                ReverseSubtractEquation = REVISION.UNSIGNED_INT;
                            else if (i instanceof Int32Array)
                                ReverseSubtractEquation = REVISION.INT;
                            else if (i instanceof Int8Array)
                                ReverseSubtractEquation = REVISION.BYTE;
                            else if (i instanceof Uint8Array)
                                ReverseSubtractEquation = REVISION.UNSIGNED_BYTE;
                            else {
                                if (!(i instanceof Uint8ClampedArray))
                                    throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + i);
                                ReverseSubtractEquation = REVISION.UNSIGNED_BYTE;
                            }
                            return {
                                buffer: SubtractEquation,
                                type: ReverseSubtractEquation,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: AddEquation
                            };
                        }(n, i));
                    else if (r.version < n.version) {
                        if (r.size !== n.array.byteLength)
                            throw new Error('THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.');
                        !function (t, n, i) {
                            const r = n.array, AddEquation = n.updateRanges;
                            if (REVISION.bindBuffer(i, t), 0 === AddEquation.length)
                                REVISION.bufferSubData(i, 0, r);
                            else {
                                AddEquation.sort((REVISION, t) => REVISION.start - t.start);
                                let t = 0;
                                for (let REVISION = 1; REVISION < AddEquation.length; REVISION++) {
                                    const n = AddEquation[t], i = AddEquation[REVISION];
                                    i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t, AddEquation[t] = i);
                                }
                                AddEquation.length = t + 1;
                                for (let t = 0, n = AddEquation.length; t < n; t++) {
                                    const n = AddEquation[t];
                                    REVISION.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count);
                                }
                                n.clearUpdateRanges();
                            }
                            n.onUploadCallback();
                        }(r.buffer, n, i), r.version = n.version;
                    }
                }
            };
        }
        const mu = {
                alphahash_fragment: '#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif',
                alphahash_pars_fragment: '#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif',
                alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif',
                alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                alphatest_fragment: '#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif',
                alphatest_pars_fragment: '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
                aomap_fragment: '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
                aomap_pars_fragment: '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
                batching_pars_vertex: '#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif',
                batching_vertex: '#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif',
                begin_vertex: 'vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif',
                beginnormal_vertex: 'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
                bsdfs: 'float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated',
                iridescence_fragment: '#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif',
                bumpmap_pars_fragment: '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
                clipping_planes_fragment: '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif',
                clipping_planes_pars_fragment: '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
                clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
                clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
                color_fragment: '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
                color_pars_fragment: '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
                color_pars_vertex: '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif',
                color_vertex: '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif',
                common: '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated',
                cube_uv_reflection_fragment: '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
                defaultnormal_vertex: 'vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
                displacementmap_pars_vertex: '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
                displacementmap_vertex: '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif',
                emissivemap_fragment: '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
                emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
                colorspace_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
                colorspace_pars_fragment: 'vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}',
                envmap_fragment: '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
                envmap_common_pars_fragment: '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
                envmap_pars_fragment: '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
                envmap_pars_vertex: '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
                envmap_physical_pars_fragment: '#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif',
                envmap_vertex: '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
                fog_vertex: '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
                fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
                fog_fragment: '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
                fog_pars_fragment: '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
                gradientmap_pars_fragment: '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}',
                lightmap_pars_fragment: '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
                lights_lambert_fragment: 'LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;',
                lights_lambert_pars_fragment: 'varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert',
                lights_pars_begin: 'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
                lights_toon_fragment: 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
                lights_toon_pars_fragment: 'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon',
                lights_phong_fragment: 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
                lights_phong_pars_fragment: 'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong',
                lights_physical_fragment: 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif',
                lights_physical_pars_fragment: 'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
                lights_fragment_begin: '\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
                lights_fragment_maps: '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
                lights_fragment_end: '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif',
                logdepthbuf_fragment: '#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
                logdepthbuf_pars_fragment: '#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
                logdepthbuf_pars_vertex: '#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
                logdepthbuf_vertex: '#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif',
                map_fragment: '#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif',
                map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
                map_particle_fragment: '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
                map_particle_pars_fragment: '#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                metalnessmap_fragment: 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
                metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
                morphinstance_vertex: '#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif',
                morphcolor_vertex: '#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif',
                morphnormal_vertex: '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif',
                morphtarget_pars_vertex: '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif',
                morphtarget_vertex: '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif',
                normal_fragment_begin: 'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;',
                normal_fragment_maps: '#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
                normal_pars_fragment: '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
                normal_pars_vertex: '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
                normal_vertex: '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
                normalmap_pars_fragment: '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif',
                clearcoat_normal_fragment_begin: '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif',
                clearcoat_normal_fragment_maps: '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif',
                clearcoat_pars_fragment: '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif',
                iridescence_pars_fragment: '#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif',
                opaque_fragment: '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
                packing: 'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}',
                premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
                project_vertex: 'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
                dithering_fragment: '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
                dithering_pars_fragment: '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
                roughnessmap_fragment: 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
                roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
                shadowmap_pars_fragment: '#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif',
                shadowmap_pars_vertex: '#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
                shadowmap_vertex: '#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif',
                shadowmask_pars_fragment: 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
                skinbase_vertex: '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
                skinning_pars_vertex: '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif',
                skinning_vertex: '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
                skinnormal_vertex: '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
                specularmap_fragment: 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
                specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
                tonemapping_fragment: '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
                tonemapping_pars_fragment: '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
                transmission_fragment: '#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif',
                transmission_pars_fragment: '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif',
                uv_pars_fragment: '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif',
                uv_pars_vertex: '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif',
                uv_vertex: '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif',
                worldpos_vertex: '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
                background_vert: 'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
                background_frag: 'uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
                backgroundCube_vert: 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
                backgroundCube_frag: '#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
                cube_vert: 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
                cube_frag: 'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
                depth_vert: '#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
                depth_frag: '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}',
                distanceRGBA_vert: '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
                distanceRGBA_frag: '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
                equirect_vert: 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
                equirect_frag: 'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
                linedashed_vert: 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                linedashed_frag: 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                meshbasic_vert: '#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
                meshbasic_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                meshlambert_vert: '#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                meshlambert_frag: '#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                meshmatcap_vert: '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
                meshmatcap_frag: '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                meshnormal_vert: '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
                meshnormal_frag: '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}',
                meshphong_vert: '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                meshphong_frag: '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                meshphysical_vert: '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
                meshphysical_frag: '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                meshtoon_vert: '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                meshtoon_frag: '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                points_vert: 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
                points_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                shadow_vert: '#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                shadow_frag: 'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}',
                sprite_vert: 'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                sprite_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}'
            }, gu = {
                common: {
                    diffuse: { value: new Color(16777215) },
                    opacity: { value: 1 },
                    map: { value: null },
                    mapTransform: { value: new Matrix3() },
                    alphaMap: { value: null },
                    alphaMapTransform: { value: new Matrix3() },
                    alphaTest: { value: 0 }
                },
                specularmap: {
                    specularMap: { value: null },
                    specularMapTransform: { value: new Matrix3() }
                },
                envmap: {
                    envMap: { value: null },
                    envMapRotation: { value: new Matrix3() },
                    flipEnvMap: { value: -1 },
                    reflectivity: { value: 1 },
                    ior: { value: 1.5 },
                    refractionRatio: { value: 0.98 }
                },
                aomap: {
                    aoMap: { value: null },
                    aoMapIntensity: { value: 1 },
                    aoMapTransform: { value: new Matrix3() }
                },
                lightmap: {
                    lightMap: { value: null },
                    lightMapIntensity: { value: 1 },
                    lightMapTransform: { value: new Matrix3() }
                },
                bumpmap: {
                    bumpMap: { value: null },
                    bumpMapTransform: { value: new Matrix3() },
                    bumpScale: { value: 1 }
                },
                normalmap: {
                    normalMap: { value: null },
                    normalMapTransform: { value: new Matrix3() },
                    normalScale: { value: new Vector2(1, 1) }
                },
                displacementmap: {
                    displacementMap: { value: null },
                    displacementMapTransform: { value: new Matrix3() },
                    displacementScale: { value: 1 },
                    displacementBias: { value: 0 }
                },
                emissivemap: {
                    emissiveMap: { value: null },
                    emissiveMapTransform: { value: new Matrix3() }
                },
                metalnessmap: {
                    metalnessMap: { value: null },
                    metalnessMapTransform: { value: new Matrix3() }
                },
                roughnessmap: {
                    roughnessMap: { value: null },
                    roughnessMapTransform: { value: new Matrix3() }
                },
                gradientmap: { gradientMap: { value: null } },
                fog: {
                    fogDensity: { value: 0.00025 },
                    fogNear: { value: 1 },
                    fogFar: { value: 2000 },
                    fogColor: { value: new Color(16777215) }
                },
                lights: {
                    ambientLightColor: { value: [] },
                    lightProbe: { value: [] },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowIntensity: 1,
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: { value: [] },
                    directionalShadowMatrix: { value: [] },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowIntensity: 1,
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: { value: [] },
                    spotShadowMap: { value: [] },
                    spotLightMatrix: { value: [] },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowIntensity: 1,
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: { value: [] },
                    pointShadowMatrix: { value: [] },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: { value: null },
                    ltc_2: { value: null }
                },
                points: {
                    diffuse: { value: new Color(16777215) },
                    opacity: { value: 1 },
                    size: { value: 1 },
                    scale: { value: 1 },
                    map: { value: null },
                    alphaMap: { value: null },
                    alphaMapTransform: { value: new Matrix3() },
                    alphaTest: { value: 0 },
                    uvTransform: { value: new Matrix3() }
                },
                sprite: {
                    diffuse: { value: new Color(16777215) },
                    opacity: { value: 1 },
                    center: { value: new Vector2(0.5, 0.5) },
                    rotation: { value: 0 },
                    map: { value: null },
                    mapTransform: { value: new Matrix3() },
                    alphaMap: { value: null },
                    alphaMapTransform: { value: new Matrix3() },
                    alphaTest: { value: 0 }
                }
            }, Au = {
                basic: {
                    uniforms: tr([
                        gu.common,
                        gu.specularmap,
                        gu.envmap,
                        gu.aomap,
                        gu.lightmap,
                        gu.fog
                    ]),
                    vertexShader: mu.meshbasic_vert,
                    fragmentShader: mu.meshbasic_frag
                },
                lambert: {
                    uniforms: tr([
                        gu.common,
                        gu.specularmap,
                        gu.envmap,
                        gu.aomap,
                        gu.lightmap,
                        gu.emissivemap,
                        gu.bumpmap,
                        gu.normalmap,
                        gu.displacementmap,
                        gu.fog,
                        gu.lights,
                        { emissive: { value: new Color(0) } }
                    ]),
                    vertexShader: mu.meshlambert_vert,
                    fragmentShader: mu.meshlambert_frag
                },
                phong: {
                    uniforms: tr([
                        gu.common,
                        gu.specularmap,
                        gu.envmap,
                        gu.aomap,
                        gu.lightmap,
                        gu.emissivemap,
                        gu.bumpmap,
                        gu.normalmap,
                        gu.displacementmap,
                        gu.fog,
                        gu.lights,
                        {
                            emissive: { value: new Color(0) },
                            specular: { value: new Color(1118481) },
                            shininess: { value: 30 }
                        }
                    ]),
                    vertexShader: mu.meshphong_vert,
                    fragmentShader: mu.meshphong_frag
                },
                standard: {
                    uniforms: tr([
                        gu.common,
                        gu.envmap,
                        gu.aomap,
                        gu.lightmap,
                        gu.emissivemap,
                        gu.bumpmap,
                        gu.normalmap,
                        gu.displacementmap,
                        gu.roughnessmap,
                        gu.metalnessmap,
                        gu.fog,
                        gu.lights,
                        {
                            emissive: { value: new Color(0) },
                            roughness: { value: 1 },
                            metalness: { value: 0 },
                            envMapIntensity: { value: 1 }
                        }
                    ]),
                    vertexShader: mu.meshphysical_vert,
                    fragmentShader: mu.meshphysical_frag
                },
                toon: {
                    uniforms: tr([
                        gu.common,
                        gu.aomap,
                        gu.lightmap,
                        gu.emissivemap,
                        gu.bumpmap,
                        gu.normalmap,
                        gu.displacementmap,
                        gu.gradientmap,
                        gu.fog,
                        gu.lights,
                        { emissive: { value: new Color(0) } }
                    ]),
                    vertexShader: mu.meshtoon_vert,
                    fragmentShader: mu.meshtoon_frag
                },
                matcap: {
                    uniforms: tr([
                        gu.common,
                        gu.bumpmap,
                        gu.normalmap,
                        gu.displacementmap,
                        gu.fog,
                        { matcap: { value: null } }
                    ]),
                    vertexShader: mu.meshmatcap_vert,
                    fragmentShader: mu.meshmatcap_frag
                },
                points: {
                    uniforms: tr([
                        gu.points,
                        gu.fog
                    ]),
                    vertexShader: mu.points_vert,
                    fragmentShader: mu.points_frag
                },
                dashed: {
                    uniforms: tr([
                        gu.common,
                        gu.fog,
                        {
                            scale: { value: 1 },
                            dashSize: { value: 1 },
                            totalSize: { value: 2 }
                        }
                    ]),
                    vertexShader: mu.linedashed_vert,
                    fragmentShader: mu.linedashed_frag
                },
                depth: {
                    uniforms: tr([
                        gu.common,
                        gu.displacementmap
                    ]),
                    vertexShader: mu.depth_vert,
                    fragmentShader: mu.depth_frag
                },
                normal: {
                    uniforms: tr([
                        gu.common,
                        gu.bumpmap,
                        gu.normalmap,
                        gu.displacementmap,
                        { opacity: { value: 1 } }
                    ]),
                    vertexShader: mu.meshnormal_vert,
                    fragmentShader: mu.meshnormal_frag
                },
                sprite: {
                    uniforms: tr([
                        gu.sprite,
                        gu.fog
                    ]),
                    vertexShader: mu.sprite_vert,
                    fragmentShader: mu.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: { value: new Matrix3() },
                        t2D: { value: null },
                        backgroundIntensity: { value: 1 }
                    },
                    vertexShader: mu.background_vert,
                    fragmentShader: mu.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: { value: null },
                        flipEnvMap: { value: -1 },
                        backgroundBlurriness: { value: 0 },
                        backgroundIntensity: { value: 1 },
                        backgroundRotation: { value: new Matrix3() }
                    },
                    vertexShader: mu.backgroundCube_vert,
                    fragmentShader: mu.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: { value: null },
                        tFlip: { value: -1 },
                        opacity: { value: 1 }
                    },
                    vertexShader: mu.cube_vert,
                    fragmentShader: mu.cube_frag
                },
                equirect: {
                    uniforms: { tEquirect: { value: null } },
                    vertexShader: mu.equirect_vert,
                    fragmentShader: mu.equirect_frag
                },
                distanceRGBA: {
                    uniforms: tr([
                        gu.common,
                        gu.displacementmap,
                        {
                            referencePosition: { value: new Vector3() },
                            nearDistance: { value: 1 },
                            farDistance: { value: 1000 }
                        }
                    ]),
                    vertexShader: mu.distanceRGBA_vert,
                    fragmentShader: mu.distanceRGBA_frag
                },
                shadow: {
                    uniforms: tr([
                        gu.lights,
                        gu.fog,
                        {
                            color: { value: new Color(0) },
                            opacity: { value: 1 }
                        }
                    ]),
                    vertexShader: mu.shadow_vert,
                    fragmentShader: mu.shadow_frag
                }
            };
        Au.physical = {
            uniforms: tr([
                Au.standard.uniforms,
                {
                    clearcoat: { value: 0 },
                    clearcoatMap: { value: null },
                    clearcoatMapTransform: { value: new Matrix3() },
                    clearcoatNormalMap: { value: null },
                    clearcoatNormalMapTransform: { value: new Matrix3() },
                    clearcoatNormalScale: { value: new Vector2(1, 1) },
                    clearcoatRoughness: { value: 0 },
                    clearcoatRoughnessMap: { value: null },
                    clearcoatRoughnessMapTransform: { value: new Matrix3() },
                    dispersion: { value: 0 },
                    iridescence: { value: 0 },
                    iridescenceMap: { value: null },
                    iridescenceMapTransform: { value: new Matrix3() },
                    iridescenceIOR: { value: 1.3 },
                    iridescenceThicknessMinimum: { value: 100 },
                    iridescenceThicknessMaximum: { value: 400 },
                    iridescenceThicknessMap: { value: null },
                    iridescenceThicknessMapTransform: { value: new Matrix3() },
                    sheen: { value: 0 },
                    sheenColor: { value: new Color(0) },
                    sheenColorMap: { value: null },
                    sheenColorMapTransform: { value: new Matrix3() },
                    sheenRoughness: { value: 1 },
                    sheenRoughnessMap: { value: null },
                    sheenRoughnessMapTransform: { value: new Matrix3() },
                    transmission: { value: 0 },
                    transmissionMap: { value: null },
                    transmissionMapTransform: { value: new Matrix3() },
                    transmissionSamplerSize: { value: new Vector2() },
                    transmissionSamplerMap: { value: null },
                    thickness: { value: 0 },
                    thicknessMap: { value: null },
                    thicknessMapTransform: { value: new Matrix3() },
                    attenuationDistance: { value: 0 },
                    attenuationColor: { value: new Color(0) },
                    specularColor: { value: new Color(1, 1, 1) },
                    specularColorMap: { value: null },
                    specularColorMapTransform: { value: new Matrix3() },
                    specularIntensity: { value: 1 },
                    specularIntensityMap: { value: null },
                    specularIntensityMapTransform: { value: new Matrix3() },
                    anisotropyVector: { value: new Vector2() },
                    anisotropyMap: { value: null },
                    anisotropyMapTransform: { value: new Matrix3() }
                }
            ]),
            vertexShader: mu.meshphysical_vert,
            fragmentShader: mu.meshphysical_frag
        };
        const _u = {
                r: 0,
                b: 0,
                g: 0
            }, vu = new Euler(), wu = new Matrix4();
        function yu(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
            const ReverseSubtractEquation = new Color(0);
            let ZeroFactor, OneFactor, SrcColorFactor = !0 === AddEquation ? 0 : 1, OneMinusSrcColorFactor = null, SrcAlphaFactor = 0, OneMinusSrcAlphaFactor = null;
            function DstAlphaFactor(REVISION) {
                let i = !0 === REVISION.isScene ? REVISION.background : null;
                if (i && i.isTexture) {
                    i = (REVISION.backgroundBlurriness > 0 ? n : t).get(i);
                }
                return i;
            }
            function OneMinusDstAlphaFactor(t, n) {
                t.getRGB(_u, nr(REVISION)), i.buffers.color.setClear(_u.r, _u.g, _u.b, n, SubtractEquation);
            }
            return {
                getClearColor: function () {
                    return ReverseSubtractEquation;
                },
                setClearColor: function (REVISION, t = 1) {
                    ReverseSubtractEquation.set(REVISION), SrcColorFactor = t, OneMinusDstAlphaFactor(ReverseSubtractEquation, SrcColorFactor);
                },
                getClearAlpha: function () {
                    return SrcColorFactor;
                },
                setClearAlpha: function (REVISION) {
                    SrcColorFactor = REVISION, OneMinusDstAlphaFactor(ReverseSubtractEquation, SrcColorFactor);
                },
                render: function (t) {
                    let n = !1;
                    const r = DstAlphaFactor(t);
                    null === r ? OneMinusDstAlphaFactor(ReverseSubtractEquation, SrcColorFactor) : r && r.isColor && (OneMinusDstAlphaFactor(r, 1), n = !0);
                    const AddEquation = REVISION.xr.getEnvironmentBlendMode();
                    'additive' === AddEquation ? i.buffers.color.setClear(0, 0, 0, 1, SubtractEquation) : 'alpha-blend' === AddEquation && i.buffers.color.setClear(0, 0, 0, 0, SubtractEquation), (REVISION.autoClear || n) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), REVISION.clear(REVISION.autoClearColor, REVISION.autoClearDepth, REVISION.autoClearStencil));
                },
                addToRenderList: function (t, n) {
                    const i = DstAlphaFactor(n);
                    i && (i.isCubeTexture || i.mapping === CubeUVReflectionMapping) ? (void 0 === OneFactor && (OneFactor = new Mesh(new $i(1, 1, 1), new rr({
                        name: 'BackgroundCubeMaterial',
                        uniforms: er(Au.backgroundCube.uniforms),
                        vertexShader: Au.backgroundCube.vertexShader,
                        fragmentShader: Au.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), OneFactor.geometry.deleteAttribute('normal'), OneFactor.geometry.deleteAttribute('uv'), OneFactor.onBeforeRender = function (REVISION, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                    }, Object.defineProperty(OneFactor.material, 'envMap', {
                        get: function () {
                            return this.uniforms.envMap.value;
                        }
                    }), r.update(OneFactor)), vu.copy(n.backgroundRotation), vu.x *= -1, vu.y *= -1, vu.z *= -1, i.isCubeTexture && !1 === i.isRenderTargetTexture && (vu.y *= -1, vu.z *= -1), OneFactor.material.uniforms.envMap.value = i, OneFactor.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, OneFactor.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, OneFactor.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, OneFactor.material.uniforms.backgroundRotation.value.setFromMatrix4(wu.makeRotationFromEuler(vu)), OneFactor.material.toneMapped = _tables.getTransfer(i.colorSpace) !== SRGBTransfer, OneMinusSrcColorFactor === i && SrcAlphaFactor === i.version && OneMinusSrcAlphaFactor === REVISION.toneMapping || (OneFactor.material.needsUpdate = !0, OneMinusSrcColorFactor = i, SrcAlphaFactor = i.version, OneMinusSrcAlphaFactor = REVISION.toneMapping), OneFactor.layers.enableAll(), t.unshift(OneFactor, OneFactor.geometry, OneFactor.material, 0, 0, null)) : i && i.isTexture && (void 0 === ZeroFactor && (ZeroFactor = new Mesh(new TorusKnotGeometry(2, 2), new rr({
                        name: 'BackgroundMaterial',
                        uniforms: er(Au.background.uniforms),
                        vertexShader: Au.background.vertexShader,
                        fragmentShader: Au.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), ZeroFactor.geometry.deleteAttribute('normal'), Object.defineProperty(ZeroFactor.material, 'map', {
                        get: function () {
                            return this.uniforms.t2D.value;
                        }
                    }), r.update(ZeroFactor)), ZeroFactor.material.uniforms.t2D.value = i, ZeroFactor.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, ZeroFactor.material.toneMapped = _tables.getTransfer(i.colorSpace) !== SRGBTransfer, !0 === i.matrixAutoUpdate && i.updateMatrix(), ZeroFactor.material.uniforms.uvTransform.value.copy(i.matrix), OneMinusSrcColorFactor === i && SrcAlphaFactor === i.version && OneMinusSrcAlphaFactor === REVISION.toneMapping || (ZeroFactor.material.needsUpdate = !0, OneMinusSrcColorFactor = i, SrcAlphaFactor = i.version, OneMinusSrcAlphaFactor = REVISION.toneMapping), ZeroFactor.layers.enableAll(), t.unshift(ZeroFactor, ZeroFactor.geometry, ZeroFactor.material, 0, 0, null));
                },
                dispose: function () {
                    void 0 !== OneFactor && (OneFactor.geometry.dispose(), OneFactor.material.dispose(), OneFactor = void 0), void 0 !== ZeroFactor && (ZeroFactor.geometry.dispose(), ZeroFactor.material.dispose(), ZeroFactor = void 0);
                }
            };
        }
        function xu(REVISION, t) {
            const n = REVISION.getParameter(REVISION.MAX_VERTEX_ATTRIBS), i = {}, r = OneFactor(null);
            let AddEquation = r, SubtractEquation = !1;
            function ReverseSubtractEquation(t) {
                return REVISION.bindVertexArray(t);
            }
            function ZeroFactor(t) {
                return REVISION.deleteVertexArray(t);
            }
            function OneFactor(REVISION) {
                const t = [], i = [], r = [];
                for (let REVISION = 0; REVISION < n; REVISION++)
                    t[REVISION] = 0, i[REVISION] = 0, r[REVISION] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: i,
                    attributeDivisors: r,
                    object: REVISION,
                    attributes: {},
                    index: null
                };
            }
            function SrcColorFactor() {
                const REVISION = AddEquation.newAttributes;
                for (let t = 0, n = REVISION.length; t < n; t++)
                    REVISION[t] = 0;
            }
            function OneMinusSrcColorFactor(REVISION) {
                SrcAlphaFactor(REVISION, 0);
            }
            function SrcAlphaFactor(t, n) {
                const i = AddEquation.newAttributes, r = AddEquation.enabledAttributes, SubtractEquation = AddEquation.attributeDivisors;
                i[t] = 1, 0 === r[t] && (REVISION.enableVertexAttribArray(t), r[t] = 1), SubtractEquation[t] !== n && (REVISION.vertexAttribDivisor(t, n), SubtractEquation[t] = n);
            }
            function OneMinusSrcAlphaFactor() {
                const t = AddEquation.newAttributes, n = AddEquation.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== t[i] && (REVISION.disableVertexAttribArray(i), n[i] = 0);
            }
            function DstAlphaFactor(t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                !0 === ReverseSubtractEquation ? REVISION.vertexAttribIPointer(t, n, i, AddEquation, SubtractEquation) : REVISION.vertexAttribPointer(t, n, i, r, AddEquation, SubtractEquation);
            }
            function OneMinusDstAlphaFactor() {
                DstColorFactor(), SubtractEquation = !0, AddEquation !== r && (AddEquation = r, ReverseSubtractEquation(AddEquation.object));
            }
            function DstColorFactor() {
                r.geometry = null, r.program = null, r.wireframe = !1;
            }
            return {
                setup: function (n, r, ZeroFactor, OneMinusDstAlphaFactor, DstColorFactor) {
                    let OneMinusDstColorFactor = !1;
                    const SrcAlphaSaturateFactor = function (t, n, r) {
                        const AddEquation = !0 === r.wireframe;
                        let SubtractEquation = i[t.id];
                        void 0 === SubtractEquation && (SubtractEquation = {}, i[t.id] = SubtractEquation);
                        let ReverseSubtractEquation = SubtractEquation[n.id];
                        void 0 === ReverseSubtractEquation && (ReverseSubtractEquation = {}, SubtractEquation[n.id] = ReverseSubtractEquation);
                        let ZeroFactor = ReverseSubtractEquation[AddEquation];
                        void 0 === ZeroFactor && (ZeroFactor = OneFactor(REVISION.createVertexArray()), ReverseSubtractEquation[AddEquation] = ZeroFactor);
                        return ZeroFactor;
                    }(OneMinusDstAlphaFactor, ZeroFactor, r);
                    AddEquation !== SrcAlphaSaturateFactor && (AddEquation = SrcAlphaSaturateFactor, ReverseSubtractEquation(AddEquation.object)), OneMinusDstColorFactor = function (REVISION, t, n, i) {
                        const r = AddEquation.attributes, SubtractEquation = t.attributes;
                        let ReverseSubtractEquation = 0;
                        const ZeroFactor = n.getAttributes();
                        for (const t in ZeroFactor) {
                            if (ZeroFactor[t].location >= 0) {
                                const n = r[t];
                                let i = SubtractEquation[t];
                                if (void 0 === i && ('instanceMatrix' === t && REVISION.instanceMatrix && (i = REVISION.instanceMatrix), 'instanceColor' === t && REVISION.instanceColor && (i = REVISION.instanceColor)), void 0 === n)
                                    return !0;
                                if (n.attribute !== i)
                                    return !0;
                                if (i && n.data !== i.data)
                                    return !0;
                                ReverseSubtractEquation++;
                            }
                        }
                        return AddEquation.attributesNum !== ReverseSubtractEquation || AddEquation.index !== i;
                    }(n, OneMinusDstAlphaFactor, ZeroFactor, DstColorFactor), OneMinusDstColorFactor && function (REVISION, t, n, i) {
                        const r = {}, SubtractEquation = t.attributes;
                        let ReverseSubtractEquation = 0;
                        const ZeroFactor = n.getAttributes();
                        for (const t in ZeroFactor) {
                            if (ZeroFactor[t].location >= 0) {
                                let n = SubtractEquation[t];
                                void 0 === n && ('instanceMatrix' === t && REVISION.instanceMatrix && (n = REVISION.instanceMatrix), 'instanceColor' === t && REVISION.instanceColor && (n = REVISION.instanceColor));
                                const i = {};
                                i.attribute = n, n && n.data && (i.data = n.data), r[t] = i, ReverseSubtractEquation++;
                            }
                        }
                        AddEquation.attributes = r, AddEquation.attributesNum = ReverseSubtractEquation, AddEquation.index = i;
                    }(n, OneMinusDstAlphaFactor, ZeroFactor, DstColorFactor), null !== DstColorFactor && t.update(DstColorFactor, REVISION.ELEMENT_ARRAY_BUFFER), (OneMinusDstColorFactor || SubtractEquation) && (SubtractEquation = !1, function (n, i, r, AddEquation) {
                        SrcColorFactor();
                        const SubtractEquation = AddEquation.attributes, ReverseSubtractEquation = r.getAttributes(), ZeroFactor = i.defaultAttributeValues;
                        for (const i in ReverseSubtractEquation) {
                            const r = ReverseSubtractEquation[i];
                            if (r.location >= 0) {
                                let ReverseSubtractEquation = SubtractEquation[i];
                                if (void 0 === ReverseSubtractEquation && ('instanceMatrix' === i && n.instanceMatrix && (ReverseSubtractEquation = n.instanceMatrix), 'instanceColor' === i && n.instanceColor && (ReverseSubtractEquation = n.instanceColor)), void 0 !== ReverseSubtractEquation) {
                                    const i = ReverseSubtractEquation.normalized, SubtractEquation = ReverseSubtractEquation.itemSize, ZeroFactor = t.get(ReverseSubtractEquation);
                                    if (void 0 === ZeroFactor)
                                        continue;
                                    const OneFactor = ZeroFactor.buffer, SrcColorFactor = ZeroFactor.type, OneMinusSrcAlphaFactor = ZeroFactor.bytesPerElement, OneMinusDstAlphaFactor = SrcColorFactor === REVISION.INT || SrcColorFactor === REVISION.UNSIGNED_INT || ReverseSubtractEquation.gpuType === IntType;
                                    if (ReverseSubtractEquation.isInterleavedBufferAttribute) {
                                        const t = ReverseSubtractEquation.data, ZeroFactor = t.stride, DstColorFactor = ReverseSubtractEquation.offset;
                                        if (t.isInstancedInterleavedBuffer) {
                                            for (let REVISION = 0; REVISION < r.locationSize; REVISION++)
                                                SrcAlphaFactor(r.location + REVISION, t.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === AddEquation._maxInstanceCount && (AddEquation._maxInstanceCount = t.meshPerAttribute * t.count);
                                        } else
                                            for (let REVISION = 0; REVISION < r.locationSize; REVISION++)
                                                OneMinusSrcColorFactor(r.location + REVISION);
                                        REVISION.bindBuffer(REVISION.ARRAY_BUFFER, OneFactor);
                                        for (let REVISION = 0; REVISION < r.locationSize; REVISION++)
                                            DstAlphaFactor(r.location + REVISION, SubtractEquation / r.locationSize, SrcColorFactor, i, ZeroFactor * OneMinusSrcAlphaFactor, (DstColorFactor + SubtractEquation / r.locationSize * REVISION) * OneMinusSrcAlphaFactor, OneMinusDstAlphaFactor);
                                    } else {
                                        if (ReverseSubtractEquation.isInstancedBufferAttribute) {
                                            for (let REVISION = 0; REVISION < r.locationSize; REVISION++)
                                                SrcAlphaFactor(r.location + REVISION, ReverseSubtractEquation.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === AddEquation._maxInstanceCount && (AddEquation._maxInstanceCount = ReverseSubtractEquation.meshPerAttribute * ReverseSubtractEquation.count);
                                        } else
                                            for (let REVISION = 0; REVISION < r.locationSize; REVISION++)
                                                OneMinusSrcColorFactor(r.location + REVISION);
                                        REVISION.bindBuffer(REVISION.ARRAY_BUFFER, OneFactor);
                                        for (let REVISION = 0; REVISION < r.locationSize; REVISION++)
                                            DstAlphaFactor(r.location + REVISION, SubtractEquation / r.locationSize, SrcColorFactor, i, SubtractEquation * OneMinusSrcAlphaFactor, SubtractEquation / r.locationSize * REVISION * OneMinusSrcAlphaFactor, OneMinusDstAlphaFactor);
                                    }
                                } else if (void 0 !== ZeroFactor) {
                                    const t = ZeroFactor[i];
                                    if (void 0 !== t)
                                        switch (t.length) {
                                        case 2:
                                            REVISION.vertexAttrib2fv(r.location, t);
                                            break;
                                        case 3:
                                            REVISION.vertexAttrib3fv(r.location, t);
                                            break;
                                        case 4:
                                            REVISION.vertexAttrib4fv(r.location, t);
                                            break;
                                        default:
                                            REVISION.vertexAttrib1fv(r.location, t);
                                        }
                                }
                            }
                        }
                        OneMinusSrcAlphaFactor();
                    }(n, r, ZeroFactor, OneMinusDstAlphaFactor), null !== DstColorFactor && REVISION.bindBuffer(REVISION.ELEMENT_ARRAY_BUFFER, t.get(DstColorFactor).buffer));
                },
                reset: OneMinusDstAlphaFactor,
                resetDefaultState: DstColorFactor,
                dispose: function () {
                    OneMinusDstAlphaFactor();
                    for (const REVISION in i) {
                        const t = i[REVISION];
                        for (const REVISION in t) {
                            const n = t[REVISION];
                            for (const REVISION in n)
                                ZeroFactor(n[REVISION].object), delete n[REVISION];
                            delete t[REVISION];
                        }
                        delete i[REVISION];
                    }
                },
                releaseStatesOfGeometry: function (REVISION) {
                    if (void 0 === i[REVISION.id])
                        return;
                    const t = i[REVISION.id];
                    for (const REVISION in t) {
                        const n = t[REVISION];
                        for (const REVISION in n)
                            ZeroFactor(n[REVISION].object), delete n[REVISION];
                        delete t[REVISION];
                    }
                    delete i[REVISION.id];
                },
                releaseStatesOfProgram: function (REVISION) {
                    for (const t in i) {
                        const n = i[t];
                        if (void 0 === n[REVISION.id])
                            continue;
                        const r = n[REVISION.id];
                        for (const REVISION in r)
                            ZeroFactor(r[REVISION].object), delete r[REVISION];
                        delete n[REVISION.id];
                    }
                },
                initAttributes: SrcColorFactor,
                enableAttribute: OneMinusSrcColorFactor,
                disableUnusedAttributes: OneMinusSrcAlphaFactor
            };
        }
        function bu(REVISION, t, n) {
            let i;
            function r(t, r, AddEquation) {
                0 !== AddEquation && (REVISION.drawArraysInstanced(i, t, r, AddEquation), n.update(r, i, AddEquation));
            }
            this.setMode = function (REVISION) {
                i = REVISION;
            }, this.render = function (t, r) {
                REVISION.drawArrays(i, t, r), n.update(r, i, 1);
            }, this.renderInstances = r, this.renderMultiDraw = function (REVISION, r, AddEquation) {
                if (0 === AddEquation)
                    return;
                t.get('WEBGL_multi_draw').multiDrawArraysWEBGL(i, REVISION, 0, r, 0, AddEquation);
                let SubtractEquation = 0;
                for (let REVISION = 0; REVISION < AddEquation; REVISION++)
                    SubtractEquation += r[REVISION];
                n.update(SubtractEquation, i, 1);
            }, this.renderMultiDrawInstances = function (REVISION, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                if (0 === SubtractEquation)
                    return;
                const ZeroFactor = t.get('WEBGL_multi_draw');
                if (null === ZeroFactor)
                    for (let t = 0; t < REVISION.length; t++)
                        r(REVISION[t], AddEquation[t], ReverseSubtractEquation[t]);
                else {
                    ZeroFactor.multiDrawArraysInstancedWEBGL(i, REVISION, 0, AddEquation, 0, ReverseSubtractEquation, 0, SubtractEquation);
                    let t = 0;
                    for (let REVISION = 0; REVISION < SubtractEquation; REVISION++)
                        t += AddEquation[REVISION] * ReverseSubtractEquation[REVISION];
                    n.update(t, i, 1);
                }
            };
        }
        function Su(REVISION, t, n, i) {
            let r;
            function AddEquation(t) {
                if ('highp' === t) {
                    if (REVISION.getShaderPrecisionFormat(REVISION.VERTEX_SHADER, REVISION.HIGH_FLOAT).precision > 0 && REVISION.getShaderPrecisionFormat(REVISION.FRAGMENT_SHADER, REVISION.HIGH_FLOAT).precision > 0)
                        return 'highp';
                    t = 'mediump';
                }
                return 'mediump' === t && REVISION.getShaderPrecisionFormat(REVISION.VERTEX_SHADER, REVISION.MEDIUM_FLOAT).precision > 0 && REVISION.getShaderPrecisionFormat(REVISION.FRAGMENT_SHADER, REVISION.MEDIUM_FLOAT).precision > 0 ? 'mediump' : 'lowp';
            }
            let SubtractEquation = void 0 !== n.precision ? n.precision : 'highp';
            const ReverseSubtractEquation = AddEquation(SubtractEquation);
            ReverseSubtractEquation !== SubtractEquation && (console.warn('THREE.WebGLRenderer:', SubtractEquation, 'not supported, using', ReverseSubtractEquation, 'instead.'), SubtractEquation = ReverseSubtractEquation);
            const ZeroFactor = !0 === n.logarithmicDepthBuffer, OneFactor = !0 === n.reverseDepthBuffer && t.has('EXT_clip_control'), SrcColorFactor = REVISION.getParameter(REVISION.MAX_TEXTURE_IMAGE_UNITS), OneMinusSrcColorFactor = REVISION.getParameter(REVISION.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            return {
                isWebGL2: !0,
                getMaxAnisotropy: function () {
                    if (void 0 !== r)
                        return r;
                    if (!0 === t.has('EXT_texture_filter_anisotropic')) {
                        const n = t.get('EXT_texture_filter_anisotropic');
                        r = REVISION.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                    } else
                        r = 0;
                    return r;
                },
                getMaxPrecision: AddEquation,
                textureFormatReadable: function (t) {
                    return t === RGBAFormat || i.convert(t) === REVISION.getParameter(REVISION.IMPLEMENTATION_COLOR_READ_FORMAT);
                },
                textureTypeReadable: function (n) {
                    const r = n === HalfFloatType && (t.has('EXT_color_buffer_half_float') || t.has('EXT_color_buffer_float'));
                    return !(n !== UnsignedByteType && i.convert(n) !== REVISION.getParameter(REVISION.IMPLEMENTATION_COLOR_READ_TYPE) && n !== FloatType && !r);
                },
                precision: SubtractEquation,
                logarithmicDepthBuffer: ZeroFactor,
                reverseDepthBuffer: OneFactor,
                maxTextures: SrcColorFactor,
                maxVertexTextures: OneMinusSrcColorFactor,
                maxTextureSize: REVISION.getParameter(REVISION.MAX_TEXTURE_SIZE),
                maxCubemapSize: REVISION.getParameter(REVISION.MAX_CUBE_MAP_TEXTURE_SIZE),
                maxAttributes: REVISION.getParameter(REVISION.MAX_VERTEX_ATTRIBS),
                maxVertexUniforms: REVISION.getParameter(REVISION.MAX_VERTEX_UNIFORM_VECTORS),
                maxVaryings: REVISION.getParameter(REVISION.MAX_VARYING_VECTORS),
                maxFragmentUniforms: REVISION.getParameter(REVISION.MAX_FRAGMENT_UNIFORM_VECTORS),
                vertexTextures: OneMinusSrcColorFactor > 0,
                maxSamples: REVISION.getParameter(REVISION.MAX_SAMPLES)
            };
        }
        function Eu(REVISION) {
            const t = this;
            let n = null, i = 0, r = !1, AddEquation = !1;
            const SubtractEquation = new Plane(), ReverseSubtractEquation = new Matrix3(), ZeroFactor = {
                    value: null,
                    needsUpdate: !1
                };
            function OneFactor(REVISION, n, i, r) {
                const AddEquation = null !== REVISION ? REVISION.length : 0;
                let OneFactor = null;
                if (0 !== AddEquation) {
                    if (OneFactor = ZeroFactor.value, !0 !== r || null === OneFactor) {
                        const t = i + 4 * AddEquation, r = n.matrixWorldInverse;
                        ReverseSubtractEquation.getNormalMatrix(r), (null === OneFactor || OneFactor.length < t) && (OneFactor = new Float32Array(t));
                        for (let t = 0, n = i; t !== AddEquation; ++t, n += 4)
                            SubtractEquation.copy(REVISION[t]).applyMatrix4(r, ReverseSubtractEquation), SubtractEquation.normal.toArray(OneFactor, n), OneFactor[n + 3] = SubtractEquation.constant;
                    }
                    ZeroFactor.value = OneFactor, ZeroFactor.needsUpdate = !0;
                }
                return t.numPlanes = AddEquation, t.numIntersection = 0, OneFactor;
            }
            this.uniform = ZeroFactor, this.numPlanes = 0, this.numIntersection = 0, this.init = function (REVISION, t) {
                const n = 0 !== REVISION.length || t || 0 !== i || r;
                return r = t, i = REVISION.length, n;
            }, this.beginShadows = function () {
                AddEquation = !0, OneFactor(null);
            }, this.endShadows = function () {
                AddEquation = !1;
            }, this.setGlobalState = function (REVISION, t) {
                n = OneFactor(REVISION, t, 0);
            }, this.setState = function (SubtractEquation, ReverseSubtractEquation, SrcColorFactor) {
                const OneMinusSrcColorFactor = SubtractEquation.clippingPlanes, SrcAlphaFactor = SubtractEquation.clipIntersection, OneMinusSrcAlphaFactor = SubtractEquation.clipShadows, DstAlphaFactor = REVISION.get(SubtractEquation);
                if (!r || null === OneMinusSrcColorFactor || 0 === OneMinusSrcColorFactor.length || AddEquation && !OneMinusSrcAlphaFactor)
                    AddEquation ? OneFactor(null) : function () {
                        ZeroFactor.value !== n && (ZeroFactor.value = n, ZeroFactor.needsUpdate = i > 0);
                        t.numPlanes = i, t.numIntersection = 0;
                    }();
                else {
                    const REVISION = AddEquation ? 0 : i, t = 4 * REVISION;
                    let r = DstAlphaFactor.clippingState || null;
                    ZeroFactor.value = r, r = OneFactor(OneMinusSrcColorFactor, ReverseSubtractEquation, t, SrcColorFactor);
                    for (let REVISION = 0; REVISION !== t; ++REVISION)
                        r[REVISION] = n[REVISION];
                    DstAlphaFactor.clippingState = r, this.numIntersection = SrcAlphaFactor ? this.numPlanes : 0, this.numPlanes += REVISION;
                }
            };
        }
        function Mu(REVISION) {
            let t = new WeakMap();
            function n(REVISION, t) {
                return t === EquirectangularReflectionMapping ? REVISION.mapping = CubeReflectionMapping : t === EquirectangularRefractionMapping && (REVISION.mapping = CubeRefractionMapping), REVISION;
            }
            function i(REVISION) {
                const n = REVISION.target;
                n.removeEventListener('dispose', i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n), r.dispose());
            }
            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const AddEquation = r.mapping;
                        if (AddEquation === EquirectangularReflectionMapping || AddEquation === EquirectangularRefractionMapping) {
                            if (t.has(r)) {
                                return n(t.get(r).texture, r.mapping);
                            }
                            {
                                const AddEquation = r.image;
                                if (AddEquation && AddEquation.height > 0) {
                                    const SubtractEquation = new WebGLCubeRenderTarget(AddEquation.height);
                                    return SubtractEquation.fromEquirectangularTexture(REVISION, r), t.set(r, SubtractEquation), r.addEventListener('dispose', i), n(SubtractEquation.texture, r.mapping);
                                }
                                return null;
                            }
                        }
                    }
                    return r;
                },
                dispose: function () {
                    t = new WeakMap();
                }
            };
        }
        const Tu = [
                0.125,
                0.215,
                0.35,
                0.446,
                0.526,
                0.582
            ], Cu = 20, Iu = new OrthographicCamera(), _quaternion = new Color();
        let Pu = null, TangentSpaceNormalMap = 0, BasicShadowMap = 0, Lu = !1;
        const Uu = (1 + Math.sqrt(5)) / 2, Nu = 1 / Uu, ku = [
                new Vector3(-Uu, Nu, 0),
                new Vector3(Uu, Nu, 0),
                new Vector3(-Nu, 0, Uu),
                new Vector3(Nu, 0, Uu),
                new Vector3(0, Uu, -Nu),
                new Vector3(0, Uu, Nu),
                new Vector3(-1, 1, -1),
                new Vector3(1, 1, -1),
                new Vector3(-1, 1, 1),
                new Vector3(1, 1, 1)
            ], Fu = new Vector3();
        class Ou {
            constructor(REVISION) {
                this._renderer = REVISION, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
            }
            fromScene(REVISION, t = 0, n = 0.1, i = 100, r = {}) {
                const {
                    size: AddEquation = 256,
                    position: SubtractEquation = Fu
                } = r;
                Pu = this._renderer.getRenderTarget(), TangentSpaceNormalMap = this._renderer.getActiveCubeFace(), BasicShadowMap = this._renderer.getActiveMipmapLevel(), Lu = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(AddEquation);
                const ReverseSubtractEquation = this._allocateTargets();
                return ReverseSubtractEquation.depthBuffer = !0, this._sceneToCubeUV(REVISION, n, i, ReverseSubtractEquation, SubtractEquation), t > 0 && this._blur(ReverseSubtractEquation, 0, 0, t), this._applyPMREM(ReverseSubtractEquation), this._cleanup(ReverseSubtractEquation), ReverseSubtractEquation;
            }
            fromEquirectangular(REVISION, t = null) {
                return this._fromTexture(REVISION, t);
            }
            fromCubemap(REVISION, t = null) {
                return this._fromTexture(REVISION, t);
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Vu(), this._compileMaterial(this._cubemapMaterial));
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = Wu(), this._compileMaterial(this._equirectMaterial));
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
            }
            _setSize(REVISION) {
                this._lodMax = Math.floor(Math.log2(REVISION)), this._cubeSize = Math.pow(2, this._lodMax);
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let REVISION = 0; REVISION < this._lodPlanes.length; REVISION++)
                    this._lodPlanes[REVISION].dispose();
            }
            _cleanup(REVISION) {
                this._renderer.setRenderTarget(Pu, TangentSpaceNormalMap, BasicShadowMap), this._renderer.xr.enabled = Lu, REVISION.scissorTest = !1, Hu(REVISION, 0, 0, REVISION.width, REVISION.height);
            }
            _fromTexture(REVISION, t) {
                REVISION.mapping === CubeReflectionMapping || REVISION.mapping === CubeRefractionMapping ? this._setSize(0 === REVISION.image.length ? 16 : REVISION.image[0].width || REVISION.image[0].image.width) : this._setSize(REVISION.image.width / 4), Pu = this._renderer.getRenderTarget(), TangentSpaceNormalMap = this._renderer.getActiveCubeFace(), BasicShadowMap = this._renderer.getActiveMipmapLevel(), Lu = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(REVISION, n), this._applyPMREM(n), this._cleanup(n), n;
            }
            _allocateTargets() {
                const REVISION = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
                        magFilter: LinearFilter,
                        minFilter: LinearFilter,
                        generateMipmaps: !1,
                        type: HalfFloatType,
                        format: RGBAFormat,
                        colorSpace: LinearSRGBColorSpace,
                        depthBuffer: !1
                    }, i = zu(REVISION, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== REVISION || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = zu(REVISION, t, n);
                    const {_lodMax: i} = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function (REVISION) {
                        const t = [], n = [], i = [];
                        let r = REVISION;
                        const AddEquation = REVISION - 4 + 1 + Tu.length;
                        for (let SubtractEquation = 0; SubtractEquation < AddEquation; SubtractEquation++) {
                            const AddEquation = Math.pow(2, r);
                            n.push(AddEquation);
                            let ReverseSubtractEquation = 1 / AddEquation;
                            SubtractEquation > REVISION - 4 ? ReverseSubtractEquation = Tu[SubtractEquation - REVISION + 4 - 1] : 0 === SubtractEquation && (ReverseSubtractEquation = 0), i.push(ReverseSubtractEquation);
                            const ZeroFactor = 1 / (AddEquation - 2), OneFactor = -ZeroFactor, SrcColorFactor = 1 + ZeroFactor, OneMinusSrcColorFactor = [
                                    OneFactor,
                                    OneFactor,
                                    SrcColorFactor,
                                    OneFactor,
                                    SrcColorFactor,
                                    SrcColorFactor,
                                    OneFactor,
                                    OneFactor,
                                    SrcColorFactor,
                                    SrcColorFactor,
                                    OneFactor,
                                    SrcColorFactor
                                ], SrcAlphaFactor = 6, OneMinusSrcAlphaFactor = 6, DstAlphaFactor = 3, OneMinusDstAlphaFactor = 2, DstColorFactor = 1, OneMinusDstColorFactor = new Float32Array(DstAlphaFactor * OneMinusSrcAlphaFactor * SrcAlphaFactor), SrcAlphaSaturateFactor = new Float32Array(OneMinusDstAlphaFactor * OneMinusSrcAlphaFactor * SrcAlphaFactor), ConstantColorFactor = new Float32Array(DstColorFactor * OneMinusSrcAlphaFactor * SrcAlphaFactor);
                            for (let REVISION = 0; REVISION < SrcAlphaFactor; REVISION++) {
                                const t = REVISION % 3 * 2 / 3 - 1, n = REVISION > 2 ? 0 : -1, i = [
                                        t,
                                        n,
                                        0,
                                        t + 2 / 3,
                                        n,
                                        0,
                                        t + 2 / 3,
                                        n + 1,
                                        0,
                                        t,
                                        n,
                                        0,
                                        t + 2 / 3,
                                        n + 1,
                                        0,
                                        t,
                                        n + 1,
                                        0
                                    ];
                                OneMinusDstColorFactor.set(i, DstAlphaFactor * OneMinusSrcAlphaFactor * REVISION), SrcAlphaSaturateFactor.set(OneMinusSrcColorFactor, OneMinusDstAlphaFactor * OneMinusSrcAlphaFactor * REVISION);
                                const r = [
                                    REVISION,
                                    REVISION,
                                    REVISION,
                                    REVISION,
                                    REVISION,
                                    REVISION
                                ];
                                ConstantColorFactor.set(r, DstColorFactor * OneMinusSrcAlphaFactor * REVISION);
                            }
                            const OneMinusConstantColorFactor = new BufferGeometry();
                            OneMinusConstantColorFactor.setAttribute('position', new BufferAttribute(OneMinusDstColorFactor, DstAlphaFactor)), OneMinusConstantColorFactor.setAttribute('uv', new BufferAttribute(SrcAlphaSaturateFactor, OneMinusDstAlphaFactor)), OneMinusConstantColorFactor.setAttribute('faceIndex', new BufferAttribute(ConstantColorFactor, DstColorFactor)), t.push(OneMinusConstantColorFactor), r > 4 && r--;
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: i
                        };
                    }(i), this._blurMaterial = function (REVISION, t, n) {
                        const i = new Float32Array(Cu), r = new Vector3(0, 1, 0), AddEquation = new rr({
                                name: 'SphericalGaussianBlur',
                                defines: {
                                    n: Cu,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${ REVISION }.0`
                                },
                                uniforms: {
                                    envMap: { value: null },
                                    samples: { value: 1 },
                                    weights: { value: i },
                                    latitudinal: { value: !1 },
                                    dTheta: { value: 0 },
                                    mipInt: { value: 0 },
                                    poleAxis: { value: r }
                                },
                                vertexShader: Gu(),
                                fragmentShader: '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues\' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t',
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            });
                        return AddEquation;
                    }(i, REVISION, t));
                }
                return i;
            }
            _compileMaterial(REVISION) {
                const t = new Mesh(this._lodPlanes[0], REVISION);
                this._renderer.compile(t, Iu);
            }
            _sceneToCubeUV(REVISION, t, n, i, r) {
                const AddEquation = new PerspectiveCamera(90, 1, t, n), SubtractEquation = [
                        1,
                        -1,
                        1,
                        1,
                        1,
                        1
                    ], ReverseSubtractEquation = [
                        1,
                        1,
                        1,
                        -1,
                        -1,
                        -1
                    ], ZeroFactor = this._renderer, OneFactor = ZeroFactor.autoClear, SrcColorFactor = ZeroFactor.toneMapping;
                ZeroFactor.getClearColor(_quaternion), ZeroFactor.toneMapping = 0, ZeroFactor.autoClear = !1;
                const OneMinusSrcColorFactor = new Si({
                        name: 'PMREM.Background',
                        side: 1,
                        depthWrite: !1,
                        depthTest: !1
                    }), SrcAlphaFactor = new Mesh(new $i(), OneMinusSrcColorFactor);
                let OneMinusSrcAlphaFactor = !1;
                const DstAlphaFactor = REVISION.background;
                DstAlphaFactor ? DstAlphaFactor.isColor && (OneMinusSrcColorFactor.color.copy(DstAlphaFactor), REVISION.background = null, OneMinusSrcAlphaFactor = !0) : (OneMinusSrcColorFactor.color.copy(_quaternion), OneMinusSrcAlphaFactor = !0);
                for (let t = 0; t < 6; t++) {
                    const n = t % 3;
                    0 === n ? (AddEquation.up.set(0, SubtractEquation[t], 0), AddEquation.position.set(r.x, r.y, r.z), AddEquation.lookAt(r.x + ReverseSubtractEquation[t], r.y, r.z)) : 1 === n ? (AddEquation.up.set(0, 0, SubtractEquation[t]), AddEquation.position.set(r.x, r.y, r.z), AddEquation.lookAt(r.x, r.y + ReverseSubtractEquation[t], r.z)) : (AddEquation.up.set(0, SubtractEquation[t], 0), AddEquation.position.set(r.x, r.y, r.z), AddEquation.lookAt(r.x, r.y, r.z + ReverseSubtractEquation[t]));
                    const OneFactor = this._cubeSize;
                    Hu(i, n * OneFactor, t > 2 ? OneFactor : 0, OneFactor, OneFactor), ZeroFactor.setRenderTarget(i), OneMinusSrcAlphaFactor && ZeroFactor.render(SrcAlphaFactor, AddEquation), ZeroFactor.render(REVISION, AddEquation);
                }
                SrcAlphaFactor.geometry.dispose(), SrcAlphaFactor.material.dispose(), ZeroFactor.toneMapping = SrcColorFactor, ZeroFactor.autoClear = OneFactor, REVISION.background = DstAlphaFactor;
            }
            _textureToCubeUV(REVISION, t) {
                const n = this._renderer, i = REVISION.mapping === CubeReflectionMapping || REVISION.mapping === CubeRefractionMapping;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Vu()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === REVISION.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Wu());
                const r = i ? this._cubemapMaterial : this._equirectMaterial, AddEquation = new Mesh(this._lodPlanes[0], r);
                r.uniforms.envMap.value = REVISION;
                const SubtractEquation = this._cubeSize;
                Hu(t, 0, 0, 3 * SubtractEquation, 2 * SubtractEquation), n.setRenderTarget(t), n.render(AddEquation, Iu);
            }
            _applyPMREM(REVISION) {
                const t = this._renderer, n = t.autoClear;
                t.autoClear = !1;
                const i = this._lodPlanes.length;
                for (let t = 1; t < i; t++) {
                    const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]), r = ku[(i - t - 1) % ku.length];
                    this._blur(REVISION, t - 1, t, n, r);
                }
                t.autoClear = n;
            }
            _blur(REVISION, t, n, i, r) {
                const AddEquation = this._pingPongRenderTarget;
                this._halfBlur(REVISION, AddEquation, t, n, i, 'latitudinal', r), this._halfBlur(AddEquation, REVISION, n, n, i, 'longitudinal', r);
            }
            _halfBlur(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
                const ReverseSubtractEquation = this._renderer, ZeroFactor = this._blurMaterial;
                'latitudinal' !== AddEquation && 'longitudinal' !== AddEquation && console.error('blur direction must be either latitudinal or longitudinal!');
                const OneFactor = new Mesh(this._lodPlanes[i], ZeroFactor), SrcColorFactor = ZeroFactor.uniforms, OneMinusSrcColorFactor = this._sizeLods[n] - 1, SrcAlphaFactor = isFinite(r) ? Math.PI / (2 * OneMinusSrcColorFactor) : 2 * Math.PI / 39, OneMinusSrcAlphaFactor = r / SrcAlphaFactor, DstAlphaFactor = isFinite(r) ? 1 + Math.floor(3 * OneMinusSrcAlphaFactor) : Cu;
                DstAlphaFactor > Cu && console.warn(`sigmaRadians, ${ r }, is too large and will clip, as it requested ${ DstAlphaFactor } samples when the maximum is set to 20`);
                const OneMinusDstAlphaFactor = [];
                let DstColorFactor = 0;
                for (let REVISION = 0; REVISION < Cu; ++REVISION) {
                    const t = REVISION / OneMinusSrcAlphaFactor, n = Math.exp(-t * t / 2);
                    OneMinusDstAlphaFactor.push(n), 0 === REVISION ? DstColorFactor += n : REVISION < DstAlphaFactor && (DstColorFactor += 2 * n);
                }
                for (let REVISION = 0; REVISION < OneMinusDstAlphaFactor.length; REVISION++)
                    OneMinusDstAlphaFactor[REVISION] = OneMinusDstAlphaFactor[REVISION] / DstColorFactor;
                SrcColorFactor.envMap.value = REVISION.texture, SrcColorFactor.samples.value = DstAlphaFactor, SrcColorFactor.weights.value = OneMinusDstAlphaFactor, SrcColorFactor.latitudinal.value = 'latitudinal' === AddEquation, SubtractEquation && (SrcColorFactor.poleAxis.value = SubtractEquation);
                const {_lodMax: OneMinusDstColorFactor} = this;
                SrcColorFactor.dTheta.value = SrcAlphaFactor, SrcColorFactor.mipInt.value = OneMinusDstColorFactor - n;
                const SrcAlphaSaturateFactor = this._sizeLods[i];
                Hu(t, 3 * SrcAlphaSaturateFactor * (i > OneMinusDstColorFactor - 4 ? i - OneMinusDstColorFactor + 4 : 0), 4 * (this._cubeSize - SrcAlphaSaturateFactor), 3 * SrcAlphaSaturateFactor, 2 * SrcAlphaSaturateFactor), ReverseSubtractEquation.setRenderTarget(t), ReverseSubtractEquation.render(OneFactor, Iu);
            }
        }
        function zu(REVISION, t, n) {
            const i = new jt(REVISION, t, n);
            return i.texture.mapping = CubeUVReflectionMapping, i.texture.name = 'PMREM.cubeUv', i.scissorTest = !0, i;
        }
        function Hu(REVISION, t, n, i, r) {
            REVISION.viewport.set(t, n, i, r), REVISION.scissor.set(t, n, i, r);
        }
        function Wu() {
            return new rr({
                name: 'EquirectangularToCubeUV',
                uniforms: { envMap: { value: null } },
                vertexShader: Gu(),
                fragmentShader: '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t',
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            });
        }
        function Vu() {
            return new rr({
                name: 'CubemapToCubeUV',
                uniforms: {
                    envMap: { value: null },
                    flipEnvMap: { value: -1 }
                },
                vertexShader: Gu(),
                fragmentShader: '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t',
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            });
        }
        function Gu() {
            return '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t';
        }
        function Qu(REVISION) {
            let t = new WeakMap(), n = null;
            function i(REVISION) {
                const n = REVISION.target;
                n.removeEventListener('dispose', i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n), r.dispose());
            }
            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const AddEquation = r.mapping, SubtractEquation = AddEquation === EquirectangularReflectionMapping || AddEquation === EquirectangularRefractionMapping, ReverseSubtractEquation = AddEquation === CubeReflectionMapping || AddEquation === CubeRefractionMapping;
                        if (SubtractEquation || ReverseSubtractEquation) {
                            let AddEquation = t.get(r);
                            const ZeroFactor = void 0 !== AddEquation ? AddEquation.texture.pmremVersion : 0;
                            if (r.isRenderTargetTexture && r.pmremVersion !== ZeroFactor)
                                return null === n && (n = new Ou(REVISION)), AddEquation = SubtractEquation ? n.fromEquirectangular(r, AddEquation) : n.fromCubemap(r, AddEquation), AddEquation.texture.pmremVersion = r.pmremVersion, t.set(r, AddEquation), AddEquation.texture;
                            if (void 0 !== AddEquation)
                                return AddEquation.texture;
                            {
                                const ZeroFactor = r.image;
                                return SubtractEquation && ZeroFactor && ZeroFactor.height > 0 || ReverseSubtractEquation && ZeroFactor && function (REVISION) {
                                    let t = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++)
                                        void 0 !== REVISION[i] && t++;
                                    return t === n;
                                }(ZeroFactor) ? (null === n && (n = new Ou(REVISION)), AddEquation = SubtractEquation ? n.fromEquirectangular(r) : n.fromCubemap(r), AddEquation.texture.pmremVersion = r.pmremVersion, t.set(r, AddEquation), r.addEventListener('dispose', i), AddEquation.texture) : null;
                            }
                        }
                    }
                    return r;
                },
                dispose: function () {
                    t = new WeakMap(), null !== n && (n.dispose(), n = null);
                }
            };
        }
        function Xu(REVISION) {
            const t = {};
            function n(n) {
                if (void 0 !== t[n])
                    return t[n];
                let i;
                switch (n) {
                case 'WEBGL_depth_texture':
                    i = REVISION.getExtension('WEBGL_depth_texture') || REVISION.getExtension('MOZ_WEBGL_depth_texture') || REVISION.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    i = REVISION.getExtension('EXT_texture_filter_anisotropic') || REVISION.getExtension('MOZ_EXT_texture_filter_anisotropic') || REVISION.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    i = REVISION.getExtension('WEBGL_compressed_texture_s3tc') || REVISION.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || REVISION.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    i = REVISION.getExtension('WEBGL_compressed_texture_pvrtc') || REVISION.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    i = REVISION.getExtension(n);
                }
                return t[n] = i, i;
            }
            return {
                has: function (REVISION) {
                    return null !== n(REVISION);
                },
                init: function () {
                    n('EXT_color_buffer_float'), n('WEBGL_clip_cull_distance'), n('OES_texture_float_linear'), n('EXT_color_buffer_half_float'), n('WEBGL_multisampled_render_to_texture'), n('WEBGL_render_shared_exponent');
                },
                get: function (REVISION) {
                    const t = n(REVISION);
                    return null === t && Pt('THREE.WebGLRenderer: ' + REVISION + ' extension not supported.'), t;
                }
            };
        }
        function ju(REVISION, t, n, i) {
            const r = {}, AddEquation = new WeakMap();
            function SubtractEquation(REVISION) {
                const ReverseSubtractEquation = REVISION.target;
                null !== ReverseSubtractEquation.index && t.remove(ReverseSubtractEquation.index);
                for (const REVISION in ReverseSubtractEquation.attributes)
                    t.remove(ReverseSubtractEquation.attributes[REVISION]);
                ReverseSubtractEquation.removeEventListener('dispose', SubtractEquation), delete r[ReverseSubtractEquation.id];
                const ZeroFactor = AddEquation.get(ReverseSubtractEquation);
                ZeroFactor && (t.remove(ZeroFactor), AddEquation.delete(ReverseSubtractEquation)), i.releaseStatesOfGeometry(ReverseSubtractEquation), !0 === ReverseSubtractEquation.isInstancedBufferGeometry && delete ReverseSubtractEquation._maxInstanceCount, n.memory.geometries--;
            }
            function ReverseSubtractEquation(REVISION) {
                const n = [], i = REVISION.index, r = REVISION.attributes.position;
                let SubtractEquation = 0;
                if (null !== i) {
                    const REVISION = i.array;
                    SubtractEquation = i.version;
                    for (let t = 0, i = REVISION.length; t < i; t += 3) {
                        const i = REVISION[t + 0], r = REVISION[t + 1], AddEquation = REVISION[t + 2];
                        n.push(i, r, r, AddEquation, AddEquation, i);
                    }
                } else {
                    if (void 0 === r)
                        return;
                    {
                        const REVISION = r.array;
                        SubtractEquation = r.version;
                        for (let t = 0, i = REVISION.length / 3 - 1; t < i; t += 3) {
                            const REVISION = t + 0, i = t + 1, r = t + 2;
                            n.push(REVISION, i, i, r, r, REVISION);
                        }
                    }
                }
                const ReverseSubtractEquation = new ((Tt(n)) ? Ri : Ii)(n, 1);
                ReverseSubtractEquation.version = SubtractEquation;
                const ZeroFactor = AddEquation.get(REVISION);
                ZeroFactor && t.remove(ZeroFactor), AddEquation.set(REVISION, ReverseSubtractEquation);
            }
            return {
                get: function (REVISION, t) {
                    return !0 === r[t.id] || (t.addEventListener('dispose', SubtractEquation), r[t.id] = !0, n.memory.geometries++), t;
                },
                update: function (n) {
                    const i = n.attributes;
                    for (const n in i)
                        t.update(i[n], REVISION.ARRAY_BUFFER);
                },
                getWireframeAttribute: function (REVISION) {
                    const t = AddEquation.get(REVISION);
                    if (t) {
                        const n = REVISION.index;
                        null !== n && t.version < n.version && ReverseSubtractEquation(REVISION);
                    } else
                        ReverseSubtractEquation(REVISION);
                    return AddEquation.get(REVISION);
                }
            };
        }
        function qu(REVISION, t, n) {
            let i, r, AddEquation;
            function SubtractEquation(t, SubtractEquation, ReverseSubtractEquation) {
                0 !== ReverseSubtractEquation && (REVISION.drawElementsInstanced(i, SubtractEquation, r, t * AddEquation, ReverseSubtractEquation), n.update(SubtractEquation, i, ReverseSubtractEquation));
            }
            this.setMode = function (REVISION) {
                i = REVISION;
            }, this.setIndex = function (REVISION) {
                r = REVISION.type, AddEquation = REVISION.bytesPerElement;
            }, this.render = function (t, SubtractEquation) {
                REVISION.drawElements(i, SubtractEquation, r, t * AddEquation), n.update(SubtractEquation, i, 1);
            }, this.renderInstances = SubtractEquation, this.renderMultiDraw = function (REVISION, AddEquation, SubtractEquation) {
                if (0 === SubtractEquation)
                    return;
                t.get('WEBGL_multi_draw').multiDrawElementsWEBGL(i, AddEquation, 0, r, REVISION, 0, SubtractEquation);
                let ReverseSubtractEquation = 0;
                for (let REVISION = 0; REVISION < SubtractEquation; REVISION++)
                    ReverseSubtractEquation += AddEquation[REVISION];
                n.update(ReverseSubtractEquation, i, 1);
            }, this.renderMultiDrawInstances = function (REVISION, ReverseSubtractEquation, ZeroFactor, OneFactor) {
                if (0 === ZeroFactor)
                    return;
                const SrcColorFactor = t.get('WEBGL_multi_draw');
                if (null === SrcColorFactor)
                    for (let t = 0; t < REVISION.length; t++)
                        SubtractEquation(REVISION[t] / AddEquation, ReverseSubtractEquation[t], OneFactor[t]);
                else {
                    SrcColorFactor.multiDrawElementsInstancedWEBGL(i, ReverseSubtractEquation, 0, r, REVISION, 0, OneFactor, 0, ZeroFactor);
                    let t = 0;
                    for (let REVISION = 0; REVISION < ZeroFactor; REVISION++)
                        t += ReverseSubtractEquation[REVISION] * OneFactor[REVISION];
                    n.update(t, i, 1);
                }
            };
        }
        function Yu(REVISION) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function () {
                    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
                },
                update: function (n, i, r) {
                    switch (t.calls++, i) {
                    case REVISION.TRIANGLES:
                        t.triangles += r * (n / 3);
                        break;
                    case REVISION.LINES:
                        t.lines += r * (n / 2);
                        break;
                    case REVISION.LINE_STRIP:
                        t.lines += r * (n - 1);
                        break;
                    case REVISION.LINE_LOOP:
                        t.lines += r * n;
                        break;
                    case REVISION.POINTS:
                        t.points += r * n;
                        break;
                    default:
                        console.error('THREE.WebGLInfo: Unknown draw mode:', i);
                    }
                }
            };
        }
        function Ku(REVISION, t, n) {
            const i = new WeakMap(), r = new Vector4();
            return {
                update: function (AddEquation, SubtractEquation, ReverseSubtractEquation) {
                    const ZeroFactor = AddEquation.morphTargetInfluences, OneFactor = SubtractEquation.morphAttributes.position || SubtractEquation.morphAttributes.normal || SubtractEquation.morphAttributes.color, SrcColorFactor = void 0 !== OneFactor ? OneFactor.length : 0;
                    let OneMinusSrcColorFactor = i.get(SubtractEquation);
                    if (void 0 === OneMinusSrcColorFactor || OneMinusSrcColorFactor.count !== SrcColorFactor) {
                        void 0 !== OneMinusSrcColorFactor && OneMinusSrcColorFactor.texture.dispose();
                        const SrcAlphaFactor = void 0 !== SubtractEquation.morphAttributes.position, OneMinusSrcAlphaFactor = void 0 !== SubtractEquation.morphAttributes.normal, DstAlphaFactor = void 0 !== SubtractEquation.morphAttributes.color, OneMinusDstAlphaFactor = SubtractEquation.morphAttributes.position || [], DstColorFactor = SubtractEquation.morphAttributes.normal || [], OneMinusDstColorFactor = SubtractEquation.morphAttributes.color || [];
                        let SrcAlphaSaturateFactor = 0;
                        !0 === SrcAlphaFactor && (SrcAlphaSaturateFactor = 1), !0 === OneMinusSrcAlphaFactor && (SrcAlphaSaturateFactor = 2), !0 === DstAlphaFactor && (SrcAlphaSaturateFactor = 3);
                        let ConstantColorFactor = SubtractEquation.attributes.position.count * SrcAlphaSaturateFactor, OneMinusConstantColorFactor = 1;
                        ConstantColorFactor > t.maxTextureSize && (OneMinusConstantColorFactor = Math.ceil(ConstantColorFactor / t.maxTextureSize), ConstantColorFactor = t.maxTextureSize);
                        const ConstantAlphaFactor = new Float32Array(ConstantColorFactor * OneMinusConstantColorFactor * 4 * SrcColorFactor), OneMinusConstantAlphaFactor = new CompressedArrayTexture(ConstantAlphaFactor, ConstantColorFactor, OneMinusConstantColorFactor, SrcColorFactor);
                        OneMinusConstantAlphaFactor.type = FloatType, OneMinusConstantAlphaFactor.needsUpdate = !0;
                        const b = 4 * SrcAlphaSaturateFactor;
                        for (let CullFaceFront = 0; CullFaceFront < SrcColorFactor; CullFaceFront++) {
                            const LessEqualDepth = OneMinusDstAlphaFactor[CullFaceFront], MultiplyBlending = DstColorFactor[CullFaceFront], CustomBlending = OneMinusDstColorFactor[CullFaceFront], GreaterDepth = ConstantColorFactor * OneMinusConstantColorFactor * 4 * CullFaceFront;
                            for (let NotEqualDepth = 0; NotEqualDepth < LessEqualDepth.count; NotEqualDepth++) {
                                const AttachedBindMode = NotEqualDepth * b;
                                !0 === SrcAlphaFactor && (r.fromBufferAttribute(LessEqualDepth, NotEqualDepth), ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 0] = r.x, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 1] = r.y, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 2] = r.z, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 3] = 0), !0 === OneMinusSrcAlphaFactor && (r.fromBufferAttribute(MultiplyBlending, NotEqualDepth), ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 4] = r.x, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 5] = r.y, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 6] = r.z, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 7] = 0), !0 === DstAlphaFactor && (r.fromBufferAttribute(CustomBlending, NotEqualDepth), ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 8] = r.x, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 9] = r.y, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 10] = r.z, ConstantAlphaFactor[GreaterDepth + AttachedBindMode + 11] = 4 === CustomBlending.itemSize ? r.w : 1);
                            }
                        }
                        function aspect() {
                            OneMinusConstantAlphaFactor.dispose(), i.delete(SubtractEquation), SubtractEquation.removeEventListener('dispose', aspect);
                        }
                        OneMinusSrcColorFactor = {
                            count: SrcColorFactor,
                            texture: OneMinusConstantAlphaFactor,
                            size: new Vector2(ConstantColorFactor, OneMinusConstantColorFactor)
                        }, i.set(SubtractEquation, OneMinusSrcColorFactor), SubtractEquation.addEventListener('dispose', aspect);
                    }
                    if (!0 === AddEquation.isInstancedMesh && null !== AddEquation.morphTexture)
                        ReverseSubtractEquation.getUniforms().setValue(REVISION, 'morphTexture', AddEquation.morphTexture, n);
                    else {
                        let CubeReflectionMapping = 0;
                        for (let EquirectangularReflectionMapping = 0; EquirectangularReflectionMapping < ZeroFactor.length; EquirectangularReflectionMapping++)
                            CubeReflectionMapping += ZeroFactor[EquirectangularReflectionMapping];
                        const CubeRefractionMapping = SubtractEquation.morphTargetsRelative ? 1 : 1 - CubeReflectionMapping;
                        ReverseSubtractEquation.getUniforms().setValue(REVISION, 'morphTargetBaseInfluence', CubeRefractionMapping), ReverseSubtractEquation.getUniforms().setValue(REVISION, 'morphTargetInfluences', ZeroFactor);
                    }
                    ReverseSubtractEquation.getUniforms().setValue(REVISION, 'morphTargetsTexture', OneMinusSrcColorFactor.texture, n), ReverseSubtractEquation.getUniforms().setValue(REVISION, 'morphTargetsTextureSize', OneMinusSrcColorFactor.size);
                }
            };
        }
        function Zu(REVISION, t, n, i) {
            let r = new WeakMap();
            function AddEquation(REVISION) {
                const t = REVISION.target;
                t.removeEventListener('dispose', AddEquation), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor);
            }
            return {
                update: function (SubtractEquation) {
                    const ReverseSubtractEquation = i.render.frame, ZeroFactor = SubtractEquation.geometry, OneFactor = t.get(SubtractEquation, ZeroFactor);
                    if (r.get(OneFactor) !== ReverseSubtractEquation && (t.update(OneFactor), r.set(OneFactor, ReverseSubtractEquation)), SubtractEquation.isInstancedMesh && (!1 === SubtractEquation.hasEventListener('dispose', AddEquation) && SubtractEquation.addEventListener('dispose', AddEquation), r.get(SubtractEquation) !== ReverseSubtractEquation && (n.update(SubtractEquation.instanceMatrix, REVISION.ARRAY_BUFFER), null !== SubtractEquation.instanceColor && n.update(SubtractEquation.instanceColor, REVISION.ARRAY_BUFFER), r.set(SubtractEquation, ReverseSubtractEquation))), SubtractEquation.isSkinnedMesh) {
                        const REVISION = SubtractEquation.skeleton;
                        r.get(REVISION) !== ReverseSubtractEquation && (REVISION.update(), r.set(REVISION, ReverseSubtractEquation));
                    }
                    return OneFactor;
                },
                dispose: function () {
                    r = new WeakMap();
                }
            };
        }
        const Ju = new Texture(), $u = new InstancedBufferGeometry(1, 1), ef = new CompressedArrayTexture(), tf = new Yt(), nf = new CubeTexture(), rf = [], af = [], sf = new Float32Array(16), of = new Float32Array(9), lf = new Float32Array(4);
        function cf(REVISION, t, n) {
            const i = REVISION[0];
            if (i <= 0 || i > 0)
                return REVISION;
            const r = t * n;
            let AddEquation = rf[r];
            if (void 0 === AddEquation && (AddEquation = new Float32Array(r), rf[r] = AddEquation), 0 !== t) {
                i.toArray(AddEquation, 0);
                for (let i = 1, r = 0; i !== t; ++i)
                    r += n, REVISION[i].toArray(AddEquation, r);
            }
            return AddEquation;
        }
        function hf(REVISION, t) {
            if (REVISION.length !== t.length)
                return !1;
            for (let n = 0, i = REVISION.length; n < i; n++)
                if (REVISION[n] !== t[n])
                    return !1;
            return !0;
        }
        function df(REVISION, t) {
            for (let n = 0, i = t.length; n < i; n++)
                REVISION[n] = t[n];
        }
        function uf(REVISION, t) {
            let n = af[t];
            void 0 === n && (n = new Int32Array(t), af[t] = n);
            for (let i = 0; i !== t; ++i)
                n[i] = REVISION.allocateTextureUnit();
            return n;
        }
        function ff(REVISION, t) {
            const n = this.cache;
            n[0] !== t && (REVISION.uniform1f(this.addr, t), n[0] = t);
        }
        function pf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (REVISION.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform2fv(this.addr, t), df(n, t);
            }
        }
        function mf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (REVISION.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else if (void 0 !== t.r)
                n[0] === t.r && n[1] === t.g && n[2] === t.b || (REVISION.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform3fv(this.addr, t), df(n, t);
            }
        }
        function gf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (REVISION.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform4fv(this.addr, t), df(n, t);
            }
        }
        function Af(REVISION, t) {
            const n = this.cache, i = t.elements;
            if (void 0 === i) {
                if (hf(n, t))
                    return;
                REVISION.uniformMatrix2fv(this.addr, !1, t), df(n, t);
            } else {
                if (hf(n, i))
                    return;
                lf.set(i), REVISION.uniformMatrix2fv(this.addr, !1, lf), df(n, i);
            }
        }
        function _f(REVISION, t) {
            const n = this.cache, i = t.elements;
            if (void 0 === i) {
                if (hf(n, t))
                    return;
                REVISION.uniformMatrix3fv(this.addr, !1, t), df(n, t);
            } else {
                if (hf(n, i))
                    return;
                of.set(i), REVISION.uniformMatrix3fv(this.addr, !1, of), df(n, i);
            }
        }
        function vf(REVISION, t) {
            const n = this.cache, i = t.elements;
            if (void 0 === i) {
                if (hf(n, t))
                    return;
                REVISION.uniformMatrix4fv(this.addr, !1, t), df(n, t);
            } else {
                if (hf(n, i))
                    return;
                sf.set(i), REVISION.uniformMatrix4fv(this.addr, !1, sf), df(n, i);
            }
        }
        function wf(REVISION, t) {
            const n = this.cache;
            n[0] !== t && (REVISION.uniform1i(this.addr, t), n[0] = t);
        }
        function yf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (REVISION.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform2iv(this.addr, t), df(n, t);
            }
        }
        function xf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (REVISION.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform3iv(this.addr, t), df(n, t);
            }
        }
        function bf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (REVISION.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform4iv(this.addr, t), df(n, t);
            }
        }
        function Sf(REVISION, t) {
            const n = this.cache;
            n[0] !== t && (REVISION.uniform1ui(this.addr, t), n[0] = t);
        }
        function Ef(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (REVISION.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform2uiv(this.addr, t), df(n, t);
            }
        }
        function Mf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (REVISION.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform3uiv(this.addr, t), df(n, t);
            }
        }
        function Tf(REVISION, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (REVISION.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (hf(n, t))
                    return;
                REVISION.uniform4uiv(this.addr, t), df(n, t);
            }
        }
        function Cf(REVISION, t, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            let AddEquation;
            i[0] !== r && (REVISION.uniform1i(this.addr, r), i[0] = r), this.type === REVISION.SAMPLER_2D_SHADOW ? ($u.compareFunction = 515, AddEquation = $u) : AddEquation = Ju, n.setTexture2D(t || AddEquation, r);
        }
        function If(REVISION, t, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (REVISION.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || tf, r);
        }
        function Rf(REVISION, t, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (REVISION.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || nf, r);
        }
        function Pf(REVISION, t, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (REVISION.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || ef, r);
        }
        function Bf(REVISION, t) {
            REVISION.uniform1fv(this.addr, t);
        }
        function Df(REVISION, t) {
            const n = cf(t, this.size, 2);
            REVISION.uniform2fv(this.addr, n);
        }
        function Lf(REVISION, t) {
            const n = cf(t, this.size, 3);
            REVISION.uniform3fv(this.addr, n);
        }
        function Uf(REVISION, t) {
            const n = cf(t, this.size, 4);
            REVISION.uniform4fv(this.addr, n);
        }
        function Nf(REVISION, t) {
            const n = cf(t, this.size, 4);
            REVISION.uniformMatrix2fv(this.addr, !1, n);
        }
        function kf(REVISION, t) {
            const n = cf(t, this.size, 9);
            REVISION.uniformMatrix3fv(this.addr, !1, n);
        }
        function Ff(REVISION, t) {
            const n = cf(t, this.size, 16);
            REVISION.uniformMatrix4fv(this.addr, !1, n);
        }
        function Of(REVISION, t) {
            REVISION.uniform1iv(this.addr, t);
        }
        function zf(REVISION, t) {
            REVISION.uniform2iv(this.addr, t);
        }
        function Hf(REVISION, t) {
            REVISION.uniform3iv(this.addr, t);
        }
        function Wf(REVISION, t) {
            REVISION.uniform4iv(this.addr, t);
        }
        function Vf(REVISION, t) {
            REVISION.uniform1uiv(this.addr, t);
        }
        function Gf(REVISION, t) {
            REVISION.uniform2uiv(this.addr, t);
        }
        function Qf(REVISION, t) {
            REVISION.uniform3uiv(this.addr, t);
        }
        function Xf(REVISION, t) {
            REVISION.uniform4uiv(this.addr, t);
        }
        function jf(REVISION, t, n) {
            const i = this.cache, r = t.length, AddEquation = uf(n, r);
            hf(i, AddEquation) || (REVISION.uniform1iv(this.addr, AddEquation), df(i, AddEquation));
            for (let REVISION = 0; REVISION !== r; ++REVISION)
                n.setTexture2D(t[REVISION] || Ju, AddEquation[REVISION]);
        }
        function qf(REVISION, t, n) {
            const i = this.cache, r = t.length, AddEquation = uf(n, r);
            hf(i, AddEquation) || (REVISION.uniform1iv(this.addr, AddEquation), df(i, AddEquation));
            for (let REVISION = 0; REVISION !== r; ++REVISION)
                n.setTexture3D(t[REVISION] || tf, AddEquation[REVISION]);
        }
        function Yf(REVISION, t, n) {
            const i = this.cache, r = t.length, AddEquation = uf(n, r);
            hf(i, AddEquation) || (REVISION.uniform1iv(this.addr, AddEquation), df(i, AddEquation));
            for (let REVISION = 0; REVISION !== r; ++REVISION)
                n.setTextureCube(t[REVISION] || nf, AddEquation[REVISION]);
        }
        function Kf(REVISION, t, n) {
            const i = this.cache, r = t.length, AddEquation = uf(n, r);
            hf(i, AddEquation) || (REVISION.uniform1iv(this.addr, AddEquation), df(i, AddEquation));
            for (let REVISION = 0; REVISION !== r; ++REVISION)
                n.setTexture2DArray(t[REVISION] || ef, AddEquation[REVISION]);
        }
        class Zf {
            constructor(REVISION, t, n) {
                this.id = REVISION, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function (REVISION) {
                    switch (REVISION) {
                    case 5126:
                        return ff;
                    case 35664:
                        return pf;
                    case 35665:
                        return mf;
                    case 35666:
                        return gf;
                    case 35674:
                        return Af;
                    case 35675:
                        return _f;
                    case 35676:
                        return vf;
                    case 5124:
                    case 35670:
                        return wf;
                    case 35667:
                    case 35671:
                        return yf;
                    case 35668:
                    case 35672:
                        return xf;
                    case 35669:
                    case 35673:
                        return bf;
                    case 5125:
                        return Sf;
                    case 36294:
                        return Ef;
                    case 36295:
                        return Mf;
                    case 36296:
                        return Tf;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Cf;
                    case 35679:
                    case 36299:
                    case 36307:
                        return If;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Rf;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Pf;
                    }
                }(t.type);
            }
        }
        class Jf {
            constructor(REVISION, t, n) {
                this.id = REVISION, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function (REVISION) {
                    switch (REVISION) {
                    case 5126:
                        return Bf;
                    case 35664:
                        return Df;
                    case 35665:
                        return Lf;
                    case 35666:
                        return Uf;
                    case 35674:
                        return Nf;
                    case 35675:
                        return kf;
                    case 35676:
                        return Ff;
                    case 5124:
                    case 35670:
                        return Of;
                    case 35667:
                    case 35671:
                        return zf;
                    case 35668:
                    case 35672:
                        return Hf;
                    case 35669:
                    case 35673:
                        return Wf;
                    case 5125:
                        return Vf;
                    case 36294:
                        return Gf;
                    case 36295:
                        return Qf;
                    case 36296:
                        return Xf;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return jf;
                    case 35679:
                    case 36299:
                    case 36307:
                        return qf;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Yf;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Kf;
                    }
                }(t.type);
            }
        }
        class $f {
            constructor(REVISION) {
                this.id = REVISION, this.seq = [], this.map = {};
            }
            setValue(REVISION, t, n) {
                const i = this.seq;
                for (let r = 0, AddEquation = i.length; r !== AddEquation; ++r) {
                    const AddEquation = i[r];
                    AddEquation.setValue(REVISION, t[AddEquation.id], n);
                }
            }
        }
        const ep = /(\w+)(\])?(\[|\.)?/g;
        function tp(REVISION, t) {
            REVISION.seq.push(t), REVISION.map[t.id] = t;
        }
        function np(REVISION, t, n) {
            const i = REVISION.name, r = i.length;
            for (ep.lastIndex = 0;;) {
                const AddEquation = ep.exec(i), SubtractEquation = ep.lastIndex;
                let ReverseSubtractEquation = AddEquation[1];
                const ZeroFactor = ']' === AddEquation[2], OneFactor = AddEquation[3];
                if (ZeroFactor && (ReverseSubtractEquation |= 0), void 0 === OneFactor || '[' === OneFactor && SubtractEquation + 2 === r) {
                    tp(n, void 0 === OneFactor ? new Zf(ReverseSubtractEquation, REVISION, t) : new Jf(ReverseSubtractEquation, REVISION, t));
                    break;
                }
                {
                    let REVISION = n.map[ReverseSubtractEquation];
                    void 0 === REVISION && (REVISION = new $f(ReverseSubtractEquation), tp(n, REVISION)), n = REVISION;
                }
            }
        }
        class ip {
            constructor(REVISION, t) {
                this.seq = [], this.map = {};
                const n = REVISION.getProgramParameter(t, REVISION.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = REVISION.getActiveUniform(t, i);
                    np(n, REVISION.getUniformLocation(t, n.name), this);
                }
            }
            setValue(REVISION, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(REVISION, n, i);
            }
            setOptional(REVISION, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(REVISION, n, i);
            }
            static upload(REVISION, t, n, i) {
                for (let r = 0, AddEquation = t.length; r !== AddEquation; ++r) {
                    const AddEquation = t[r], SubtractEquation = n[AddEquation.id];
                    !1 !== SubtractEquation.needsUpdate && AddEquation.setValue(REVISION, SubtractEquation.value, i);
                }
            }
            static seqWithValue(REVISION, t) {
                const n = [];
                for (let i = 0, r = REVISION.length; i !== r; ++i) {
                    const r = REVISION[i];
                    r.id in t && n.push(r);
                }
                return n;
            }
        }
        function rp(REVISION, t, n) {
            const i = REVISION.createShader(t);
            return REVISION.shaderSource(i, n), REVISION.compileShader(i), i;
        }
        let _id = 0;
        const sp = new Matrix3();
        function op(REVISION, t, n) {
            const i = REVISION.getShaderParameter(t, REVISION.COMPILE_STATUS), r = REVISION.getShaderInfoLog(t).trim();
            if (i && '' === r)
                return '';
            const AddEquation = /ERROR: 0:(\d+)/.exec(r);
            if (AddEquation) {
                const i = parseInt(AddEquation[1]);
                return n.toUpperCase() + '\n\n' + r + '\n\n' + function (REVISION, t) {
                    const n = REVISION.split('\n'), i = [], r = Math.max(t - 6, 0), AddEquation = Math.min(t + 6, n.length);
                    for (let REVISION = r; REVISION < AddEquation; REVISION++) {
                        const r = REVISION + 1;
                        i.push(`${ r === t ? '>' : ' ' } ${ r }: ${ n[REVISION] }`);
                    }
                    return i.join('\n');
                }(REVISION.getShaderSource(t), i);
            }
            return r;
        }
        function lp(REVISION, t) {
            const n = function (REVISION) {
                _tables._getMatrix(sp, _tables.workingColorSpace, REVISION);
                const t = `mat3( ${ sp.elements.map(REVISION => REVISION.toFixed(4)) } )`;
                switch (_tables.getTransfer(REVISION)) {
                case LinearTransfer:
                    return [
                        t,
                        'LinearTransferOETF'
                    ];
                case SRGBTransfer:
                    return [
                        t,
                        'sRGBTransferOETF'
                    ];
                default:
                    return console.warn('THREE.WebGLProgram: Unsupported color space: ', REVISION), [
                        t,
                        'LinearTransferOETF'
                    ];
                }
            }(t);
            return [
                `vec4 ${ REVISION }( vec4 value ) {`,
                `\treturn ${ n[1] }( vec4( value.rgb * ${ n[0] }, value.a ) );`,
                '}'
            ].join('\n');
        }
        function cp(REVISION, t) {
            let n;
            switch (t) {
            case 1:
                n = 'Linear';
                break;
            case 2:
                n = 'Reinhard';
                break;
            case 3:
                n = 'Cineon';
                break;
            case 4:
                n = 'ACESFilmic';
                break;
            case 6:
                n = 'AgX';
                break;
            case 7:
                n = 'Neutral';
                break;
            case 5:
                n = 'Custom';
                break;
            default:
                console.warn('THREE.WebGLProgram: Unsupported toneMapping:', t), n = 'Linear';
            }
            return 'vec3 ' + REVISION + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }';
        }
        const hp = new Vector3();
        function dp() {
            _tables.getLuminanceCoefficients(hp);
            return [
                'float luminance( const in vec3 rgb ) {',
                `\tconst vec3 weights = vec3( ${ hp.x.toFixed(4) }, ${ hp.y.toFixed(4) }, ${ hp.z.toFixed(4) } );`,
                '\treturn dot( weights, rgb );',
                '}'
            ].join('\n');
        }
        function up(REVISION) {
            return '' !== REVISION;
        }
        function fp(REVISION, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return REVISION.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
        }
        function pp(REVISION, t) {
            return REVISION.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
        }
        const mp = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function gp(REVISION) {
            return REVISION.replace(mp, _p);
        }
        const Ap = new Map();
        function _p(REVISION, t) {
            let n = mu[t];
            if (void 0 === n) {
                const REVISION = Ap.get(t);
                if (void 0 === REVISION)
                    throw new Error('Can not resolve #include <' + t + '>');
                n = mu[REVISION], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, REVISION);
            }
            return gp(n);
        }
        const vp = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function wp(REVISION) {
            return REVISION.replace(vp, yp);
        }
        function yp(REVISION, t, n, i) {
            let r = '';
            for (let REVISION = parseInt(t); REVISION < parseInt(n); REVISION++)
                r += i.replace(/\[\s*i\s*\]/g, '[ ' + REVISION + ' ]').replace(/UNROLLED_LOOP_INDEX/g, REVISION);
            return r;
        }
        function xp(REVISION) {
            let t = `precision ${ REVISION.precision } float;\n\tprecision ${ REVISION.precision } int;\n\tprecision ${ REVISION.precision } sampler2D;\n\tprecision ${ REVISION.precision } samplerCube;\n\tprecision ${ REVISION.precision } sampler3D;\n\tprecision ${ REVISION.precision } sampler2DArray;\n\tprecision ${ REVISION.precision } sampler2DShadow;\n\tprecision ${ REVISION.precision } samplerCubeShadow;\n\tprecision ${ REVISION.precision } sampler2DArrayShadow;\n\tprecision ${ REVISION.precision } isampler2D;\n\tprecision ${ REVISION.precision } isampler3D;\n\tprecision ${ REVISION.precision } isamplerCube;\n\tprecision ${ REVISION.precision } isampler2DArray;\n\tprecision ${ REVISION.precision } usampler2D;\n\tprecision ${ REVISION.precision } usampler3D;\n\tprecision ${ REVISION.precision } usamplerCube;\n\tprecision ${ REVISION.precision } usampler2DArray;\n\t`;
            return 'highp' === REVISION.precision ? t += '\n#define HIGH_PRECISION' : 'mediump' === REVISION.precision ? t += '\n#define MEDIUM_PRECISION' : 'lowp' === REVISION.precision && (t += '\n#define LOW_PRECISION'), t;
        }
        function bp(REVISION, t, n, i) {
            const r = REVISION.getContext(), AddEquation = n.defines;
            let SubtractEquation = n.vertexShader, ReverseSubtractEquation = n.fragmentShader;
            const ZeroFactor = function (REVISION) {
                    let t = 'SHADOWMAP_TYPE_BASIC';
                    return 1 === REVISION.shadowMapType ? t = 'SHADOWMAP_TYPE_PCF' : 2 === REVISION.shadowMapType ? t = 'SHADOWMAP_TYPE_PCF_SOFT' : 3 === REVISION.shadowMapType && (t = 'SHADOWMAP_TYPE_VSM'), t;
                }(n), OneFactor = function (REVISION) {
                    let t = 'ENVMAP_TYPE_CUBE';
                    if (REVISION.envMap)
                        switch (REVISION.envMapMode) {
                        case CubeReflectionMapping:
                        case CubeRefractionMapping:
                            t = 'ENVMAP_TYPE_CUBE';
                            break;
                        case CubeUVReflectionMapping:
                            t = 'ENVMAP_TYPE_CUBE_UV';
                        }
                    return t;
                }(n), SrcColorFactor = function (REVISION) {
                    let t = 'ENVMAP_MODE_REFLECTION';
                    REVISION.envMap && REVISION.envMapMode === CubeRefractionMapping && (t = 'ENVMAP_MODE_REFRACTION');
                    return t;
                }(n), OneMinusSrcColorFactor = function (REVISION) {
                    let t = 'ENVMAP_BLENDING_NONE';
                    if (REVISION.envMap)
                        switch (REVISION.combine) {
                        case 0:
                            t = 'ENVMAP_BLENDING_MULTIPLY';
                            break;
                        case 1:
                            t = 'ENVMAP_BLENDING_MIX';
                            break;
                        case 2:
                            t = 'ENVMAP_BLENDING_ADD';
                        }
                    return t;
                }(n), SrcAlphaFactor = function (REVISION) {
                    const t = REVISION.envMapCubeUVHeight;
                    if (null === t)
                        return null;
                    const n = Math.log2(t) - 2, i = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    };
                }(n), OneMinusSrcAlphaFactor = function (REVISION) {
                    return [
                        REVISION.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
                        REVISION.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : ''
                    ].filter(up).join('\n');
                }(n), DstAlphaFactor = function (REVISION) {
                    const t = [];
                    for (const n in REVISION) {
                        const i = REVISION[n];
                        !1 !== i && t.push('#define ' + n + ' ' + i);
                    }
                    return t.join('\n');
                }(AddEquation), OneMinusDstAlphaFactor = r.createProgram();
            let DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor = n.glslVersion ? '#version ' + n.glslVersion + '\n' : '';
            n.isRawShaderMaterial ? (DstColorFactor = [
                '#define SHADER_TYPE ' + n.shaderType,
                '#define SHADER_NAME ' + n.shaderName,
                DstAlphaFactor
            ].filter(up).join('\n'), DstColorFactor.length > 0 && (DstColorFactor += '\n'), OneMinusDstColorFactor = [
                '#define SHADER_TYPE ' + n.shaderType,
                '#define SHADER_NAME ' + n.shaderName,
                DstAlphaFactor
            ].filter(up).join('\n'), OneMinusDstColorFactor.length > 0 && (OneMinusDstColorFactor += '\n')) : (DstColorFactor = [
                xp(n),
                '#define SHADER_TYPE ' + n.shaderType,
                '#define SHADER_NAME ' + n.shaderName,
                DstAlphaFactor,
                n.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
                n.batching ? '#define USE_BATCHING' : '',
                n.batchingColor ? '#define USE_BATCHING_COLOR' : '',
                n.instancing ? '#define USE_INSTANCING' : '',
                n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
                n.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
                n.useFog && n.fog ? '#define USE_FOG' : '',
                n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                n.map ? '#define USE_MAP' : '',
                n.envMap ? '#define USE_ENVMAP' : '',
                n.envMap ? '#define ' + SrcColorFactor : '',
                n.lightMap ? '#define USE_LIGHTMAP' : '',
                n.aoMap ? '#define USE_AOMAP' : '',
                n.bumpMap ? '#define USE_BUMPMAP' : '',
                n.normalMap ? '#define USE_NORMALMAP' : '',
                n.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
                n.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
                n.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
                n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                n.anisotropy ? '#define USE_ANISOTROPY' : '',
                n.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
                n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                n.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
                n.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
                n.specularMap ? '#define USE_SPECULARMAP' : '',
                n.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
                n.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
                n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                n.alphaMap ? '#define USE_ALPHAMAP' : '',
                n.alphaHash ? '#define USE_ALPHAHASH' : '',
                n.transmission ? '#define USE_TRANSMISSION' : '',
                n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                n.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
                n.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
                n.mapUv ? '#define MAP_UV ' + n.mapUv : '',
                n.alphaMapUv ? '#define ALPHAMAP_UV ' + n.alphaMapUv : '',
                n.lightMapUv ? '#define LIGHTMAP_UV ' + n.lightMapUv : '',
                n.aoMapUv ? '#define AOMAP_UV ' + n.aoMapUv : '',
                n.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + n.emissiveMapUv : '',
                n.bumpMapUv ? '#define BUMPMAP_UV ' + n.bumpMapUv : '',
                n.normalMapUv ? '#define NORMALMAP_UV ' + n.normalMapUv : '',
                n.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + n.displacementMapUv : '',
                n.metalnessMapUv ? '#define METALNESSMAP_UV ' + n.metalnessMapUv : '',
                n.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + n.roughnessMapUv : '',
                n.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + n.anisotropyMapUv : '',
                n.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + n.clearcoatMapUv : '',
                n.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + n.clearcoatNormalMapUv : '',
                n.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + n.clearcoatRoughnessMapUv : '',
                n.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + n.iridescenceMapUv : '',
                n.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + n.iridescenceThicknessMapUv : '',
                n.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + n.sheenColorMapUv : '',
                n.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + n.sheenRoughnessMapUv : '',
                n.specularMapUv ? '#define SPECULARMAP_UV ' + n.specularMapUv : '',
                n.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + n.specularColorMapUv : '',
                n.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + n.specularIntensityMapUv : '',
                n.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + n.transmissionMapUv : '',
                n.thicknessMapUv ? '#define THICKNESSMAP_UV ' + n.thicknessMapUv : '',
                n.vertexTangents && !1 === n.flatShading ? '#define USE_TANGENT' : '',
                n.vertexColors ? '#define USE_COLOR' : '',
                n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                n.vertexUv1s ? '#define USE_UV1' : '',
                n.vertexUv2s ? '#define USE_UV2' : '',
                n.vertexUv3s ? '#define USE_UV3' : '',
                n.pointsUvs ? '#define USE_POINTS_UV' : '',
                n.flatShading ? '#define FLAT_SHADED' : '',
                n.skinning ? '#define USE_SKINNING' : '',
                n.morphTargets ? '#define USE_MORPHTARGETS' : '',
                n.morphNormals && !1 === n.flatShading ? '#define USE_MORPHNORMALS' : '',
                n.morphColors ? '#define USE_MORPHCOLORS' : '',
                n.morphTargetsCount > 0 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + n.morphTextureStride : '',
                n.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + n.morphTargetsCount : '',
                n.doubleSided ? '#define DOUBLE_SIDED' : '',
                n.flipSided ? '#define FLIP_SIDED' : '',
                n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                n.shadowMapEnabled ? '#define ' + ZeroFactor : '',
                n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                n.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
                n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                n.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                '#ifdef USE_INSTANCING',
                '\tattribute mat4 instanceMatrix;',
                '#endif',
                '#ifdef USE_INSTANCING_COLOR',
                '\tattribute vec3 instanceColor;',
                '#endif',
                '#ifdef USE_INSTANCING_MORPH',
                '\tuniform sampler2D morphTexture;',
                '#endif',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_UV1',
                '\tattribute vec2 uv1;',
                '#endif',
                '#ifdef USE_UV2',
                '\tattribute vec2 uv2;',
                '#endif',
                '#ifdef USE_UV3',
                '\tattribute vec2 uv3;',
                '#endif',
                '#ifdef USE_TANGENT',
                '\tattribute vec4 tangent;',
                '#endif',
                '#if defined( USE_COLOR_ALPHA )',
                '\tattribute vec4 color;',
                '#elif defined( USE_COLOR )',
                '\tattribute vec3 color;',
                '#endif',
                '#ifdef USE_SKINNING',
                '\tattribute vec4 skinIndex;',
                '\tattribute vec4 skinWeight;',
                '#endif',
                '\n'
            ].filter(up).join('\n'), OneMinusDstColorFactor = [
                xp(n),
                '#define SHADER_TYPE ' + n.shaderType,
                '#define SHADER_NAME ' + n.shaderName,
                DstAlphaFactor,
                n.useFog && n.fog ? '#define USE_FOG' : '',
                n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                n.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
                n.map ? '#define USE_MAP' : '',
                n.matcap ? '#define USE_MATCAP' : '',
                n.envMap ? '#define USE_ENVMAP' : '',
                n.envMap ? '#define ' + OneFactor : '',
                n.envMap ? '#define ' + SrcColorFactor : '',
                n.envMap ? '#define ' + OneMinusSrcColorFactor : '',
                SrcAlphaFactor ? '#define CUBEUV_TEXEL_WIDTH ' + SrcAlphaFactor.texelWidth : '',
                SrcAlphaFactor ? '#define CUBEUV_TEXEL_HEIGHT ' + SrcAlphaFactor.texelHeight : '',
                SrcAlphaFactor ? '#define CUBEUV_MAX_MIP ' + SrcAlphaFactor.maxMip + '.0' : '',
                n.lightMap ? '#define USE_LIGHTMAP' : '',
                n.aoMap ? '#define USE_AOMAP' : '',
                n.bumpMap ? '#define USE_BUMPMAP' : '',
                n.normalMap ? '#define USE_NORMALMAP' : '',
                n.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
                n.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
                n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                n.anisotropy ? '#define USE_ANISOTROPY' : '',
                n.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
                n.clearcoat ? '#define USE_CLEARCOAT' : '',
                n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                n.dispersion ? '#define USE_DISPERSION' : '',
                n.iridescence ? '#define USE_IRIDESCENCE' : '',
                n.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
                n.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
                n.specularMap ? '#define USE_SPECULARMAP' : '',
                n.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
                n.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
                n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                n.alphaMap ? '#define USE_ALPHAMAP' : '',
                n.alphaTest ? '#define USE_ALPHATEST' : '',
                n.alphaHash ? '#define USE_ALPHAHASH' : '',
                n.sheen ? '#define USE_SHEEN' : '',
                n.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
                n.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
                n.transmission ? '#define USE_TRANSMISSION' : '',
                n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                n.vertexTangents && !1 === n.flatShading ? '#define USE_TANGENT' : '',
                n.vertexColors || n.instancingColor || n.batchingColor ? '#define USE_COLOR' : '',
                n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                n.vertexUv1s ? '#define USE_UV1' : '',
                n.vertexUv2s ? '#define USE_UV2' : '',
                n.vertexUv3s ? '#define USE_UV3' : '',
                n.pointsUvs ? '#define USE_POINTS_UV' : '',
                n.gradientMap ? '#define USE_GRADIENTMAP' : '',
                n.flatShading ? '#define FLAT_SHADED' : '',
                n.doubleSided ? '#define DOUBLE_SIDED' : '',
                n.flipSided ? '#define FLIP_SIDED' : '',
                n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                n.shadowMapEnabled ? '#define ' + ZeroFactor : '',
                n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                n.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
                n.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
                n.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',
                n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                n.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
                0 !== n.toneMapping ? mu.tonemapping_pars_fragment : '',
                0 !== n.toneMapping ? cp('toneMapping', n.toneMapping) : '',
                n.dithering ? '#define DITHERING' : '',
                n.opaque ? '#define OPAQUE' : '',
                mu.colorspace_pars_fragment,
                lp('linearToOutputTexel', n.outputColorSpace),
                dp(),
                n.useDepthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
                '\n'
            ].filter(up).join('\n')), SubtractEquation = gp(SubtractEquation), SubtractEquation = fp(SubtractEquation, n), SubtractEquation = pp(SubtractEquation, n), ReverseSubtractEquation = gp(ReverseSubtractEquation), ReverseSubtractEquation = fp(ReverseSubtractEquation, n), ReverseSubtractEquation = pp(ReverseSubtractEquation, n), SubtractEquation = wp(SubtractEquation), ReverseSubtractEquation = wp(ReverseSubtractEquation), !0 !== n.isRawShaderMaterial && (SrcAlphaSaturateFactor = '#version 300 es\n', DstColorFactor = [
                OneMinusSrcAlphaFactor,
                '#define attribute in',
                '#define varying out',
                '#define texture2D texture'
            ].join('\n') + '\n' + DstColorFactor, OneMinusDstColorFactor = [
                '#define varying in',
                n.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
                n.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad'
            ].join('\n') + '\n' + OneMinusDstColorFactor);
            const ConstantColorFactor = SrcAlphaSaturateFactor + DstColorFactor + SubtractEquation, OneMinusConstantColorFactor = SrcAlphaSaturateFactor + OneMinusDstColorFactor + ReverseSubtractEquation, ConstantAlphaFactor = rp(r, r.VERTEX_SHADER, ConstantColorFactor), OneMinusConstantAlphaFactor = rp(r, r.FRAGMENT_SHADER, OneMinusConstantColorFactor);
            function b(t) {
                if (REVISION.debug.checkShaderErrors) {
                    const n = r.getProgramInfoLog(OneMinusDstAlphaFactor).trim(), i = r.getShaderInfoLog(ConstantAlphaFactor).trim(), AddEquation = r.getShaderInfoLog(OneMinusConstantAlphaFactor).trim();
                    let SubtractEquation = !0, ReverseSubtractEquation = !0;
                    if (!1 === r.getProgramParameter(OneMinusDstAlphaFactor, r.LINK_STATUS))
                        if (SubtractEquation = !1, 'function' == typeof REVISION.debug.onShaderError)
                            REVISION.debug.onShaderError(r, OneMinusDstAlphaFactor, ConstantAlphaFactor, OneMinusConstantAlphaFactor);
                        else {
                            const REVISION = op(r, ConstantAlphaFactor, 'vertex'), i = op(r, OneMinusConstantAlphaFactor, 'fragment');
                            console.error('THREE.WebGLProgram: Shader Error ' + r.getError() + ' - VALIDATE_STATUS ' + r.getProgramParameter(OneMinusDstAlphaFactor, r.VALIDATE_STATUS) + '\n\nMaterial Name: ' + t.name + '\nMaterial Type: ' + t.type + '\n\nProgram Info Log: ' + n + '\n' + REVISION + '\n' + i);
                        }
                    else
                        '' !== n ? console.warn('THREE.WebGLProgram: Program Info Log:', n) : '' !== i && '' !== AddEquation || (ReverseSubtractEquation = !1);
                    ReverseSubtractEquation && (t.diagnostics = {
                        runnable: SubtractEquation,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: DstColorFactor
                        },
                        fragmentShader: {
                            log: AddEquation,
                            prefix: OneMinusDstColorFactor
                        }
                    });
                }
                r.deleteShader(ConstantAlphaFactor), r.deleteShader(OneMinusConstantAlphaFactor), aspect = new ip(r, OneMinusDstAlphaFactor), CullFaceFront = function (REVISION, t) {
                    const n = {}, i = REVISION.getProgramParameter(t, REVISION.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = REVISION.getActiveAttrib(t, r), AddEquation = i.name;
                        let SubtractEquation = 1;
                        i.type === REVISION.FLOAT_MAT2 && (SubtractEquation = 2), i.type === REVISION.FLOAT_MAT3 && (SubtractEquation = 3), i.type === REVISION.FLOAT_MAT4 && (SubtractEquation = 4), n[AddEquation] = {
                            type: i.type,
                            location: REVISION.getAttribLocation(t, AddEquation),
                            locationSize: SubtractEquation
                        };
                    }
                    return n;
                }(r, OneMinusDstAlphaFactor);
            }
            let aspect, CullFaceFront;
            r.attachShader(OneMinusDstAlphaFactor, ConstantAlphaFactor), r.attachShader(OneMinusDstAlphaFactor, OneMinusConstantAlphaFactor), void 0 !== n.index0AttributeName ? r.bindAttribLocation(OneMinusDstAlphaFactor, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(OneMinusDstAlphaFactor, 0, 'position'), r.linkProgram(OneMinusDstAlphaFactor), this.getUniforms = function () {
                return void 0 === aspect && b(this), aspect;
            }, this.getAttributes = function () {
                return void 0 === CullFaceFront && b(this), CullFaceFront;
            };
            let LessEqualDepth = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function () {
                return !1 === LessEqualDepth && (LessEqualDepth = r.getProgramParameter(OneMinusDstAlphaFactor, 37297)), LessEqualDepth;
            }, this.destroy = function () {
                i.releaseStatesOfProgram(this), r.deleteProgram(OneMinusDstAlphaFactor), this.program = void 0;
            }, this.type = n.shaderType, this.name = n.shaderName, this.id = _id++, this.cacheKey = t, this.usedTimes = 1, this.program = OneMinusDstAlphaFactor, this.vertexShader = ConstantAlphaFactor, this.fragmentShader = OneMinusConstantAlphaFactor, this;
        }
        let Sp = 0;
        class Ep {
            constructor() {
                this.shaderCache = new Map(), this.materialCache = new Map();
            }
            update(REVISION) {
                const t = REVISION.vertexShader, n = REVISION.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), AddEquation = this._getShaderCacheForMaterial(REVISION);
                return !1 === AddEquation.has(i) && (AddEquation.add(i), i.usedTimes++), !1 === AddEquation.has(r) && (AddEquation.add(r), r.usedTimes++), this;
            }
            remove(REVISION) {
                const t = this.materialCache.get(REVISION);
                for (const REVISION of t)
                    REVISION.usedTimes--, 0 === REVISION.usedTimes && this.shaderCache.delete(REVISION.code);
                return this.materialCache.delete(REVISION), this;
            }
            getVertexShaderID(REVISION) {
                return this._getShaderStage(REVISION.vertexShader).id;
            }
            getFragmentShaderID(REVISION) {
                return this._getShaderStage(REVISION.fragmentShader).id;
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear();
            }
            _getShaderCacheForMaterial(REVISION) {
                const t = this.materialCache;
                let n = t.get(REVISION);
                return void 0 === n && (n = new Set(), t.set(REVISION, n)), n;
            }
            _getShaderStage(REVISION) {
                const t = this.shaderCache;
                let n = t.get(REVISION);
                return void 0 === n && (n = new Mp(REVISION), t.set(REVISION, n)), n;
            }
        }
        class Mp {
            constructor(REVISION) {
                this.id = Sp++, this.code = REVISION, this.usedTimes = 0;
            }
        }
        function Tp(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
            const ReverseSubtractEquation = new Layers(), ZeroFactor = new Ep(), OneFactor = new Set(), SrcColorFactor = [], OneMinusSrcColorFactor = r.logarithmicDepthBuffer, SrcAlphaFactor = r.vertexTextures;
            let OneMinusSrcAlphaFactor = r.precision;
            const DstAlphaFactor = {
                MeshDepthMaterial: 'depth',
                MeshDistanceMaterial: 'distanceRGBA',
                MeshNormalMaterial: 'normal',
                MeshBasicMaterial: 'basic',
                MeshLambertMaterial: 'lambert',
                MeshPhongMaterial: 'phong',
                MeshToonMaterial: 'toon',
                MeshStandardMaterial: 'physical',
                MeshPhysicalMaterial: 'physical',
                MeshMatcapMaterial: 'matcap',
                LineBasicMaterial: 'basic',
                LineDashedMaterial: 'dashed',
                PointsMaterial: 'points',
                ShadowMaterial: 'shadow',
                SpriteMaterial: 'sprite'
            };
            function OneMinusDstAlphaFactor(REVISION) {
                return OneFactor.add(REVISION), 0 === REVISION ? 'uv' : `uv${ REVISION }`;
            }
            return {
                getParameters: function (AddEquation, ReverseSubtractEquation, SrcColorFactor, DstColorFactor, OneMinusDstColorFactor) {
                    const SrcAlphaSaturateFactor = DstColorFactor.fog, ConstantColorFactor = OneMinusDstColorFactor.geometry, OneMinusConstantColorFactor = AddEquation.isMeshStandardMaterial ? DstColorFactor.environment : null, ConstantAlphaFactor = (AddEquation.isMeshStandardMaterial ? n : t).get(AddEquation.envMap || OneMinusConstantColorFactor), OneMinusConstantAlphaFactor = ConstantAlphaFactor && ConstantAlphaFactor.mapping === CubeUVReflectionMapping ? ConstantAlphaFactor.image.height : null, b = DstAlphaFactor[AddEquation.type];
                    null !== AddEquation.precision && (OneMinusSrcAlphaFactor = r.getMaxPrecision(AddEquation.precision), OneMinusSrcAlphaFactor !== AddEquation.precision && console.warn('THREE.WebGLProgram.getParameters:', AddEquation.precision, 'not supported, using', OneMinusSrcAlphaFactor, 'instead.'));
                    const aspect = ConstantColorFactor.morphAttributes.position || ConstantColorFactor.morphAttributes.normal || ConstantColorFactor.morphAttributes.color, CullFaceFront = void 0 !== aspect ? aspect.length : 0;
                    let LessEqualDepth, MultiplyBlending, CustomBlending, GreaterDepth, NotEqualDepth = 0;
                    if (void 0 !== ConstantColorFactor.morphAttributes.position && (NotEqualDepth = 1), void 0 !== ConstantColorFactor.morphAttributes.normal && (NotEqualDepth = 2), void 0 !== ConstantColorFactor.morphAttributes.color && (NotEqualDepth = 3), b) {
                        const REVISION = Au[b];
                        LessEqualDepth = REVISION.vertexShader, MultiplyBlending = REVISION.fragmentShader;
                    } else
                        LessEqualDepth = AddEquation.vertexShader, MultiplyBlending = AddEquation.fragmentShader, ZeroFactor.update(AddEquation), CustomBlending = ZeroFactor.getVertexShaderID(AddEquation), GreaterDepth = ZeroFactor.getFragmentShaderID(AddEquation);
                    const AttachedBindMode = REVISION.getRenderTarget(), CubeReflectionMapping = REVISION.state.buffers.depth.getReversed(), CubeRefractionMapping = !0 === OneMinusDstColorFactor.isInstancedMesh, EquirectangularReflectionMapping = !0 === OneMinusDstColorFactor.isBatchedMesh, EquirectangularRefractionMapping = !!AddEquation.map, RepeatWrapping = !!AddEquation.matcap, ClampToEdgeWrapping = !!ConstantAlphaFactor, MirroredRepeatWrapping = !!AddEquation.aoMap, NearestFilter = !!AddEquation.lightMap, NearestMipMapNearestFilter = !!AddEquation.bumpMap, NearestMipMapLinearFilter = !!AddEquation.normalMap, LinearFilter = !!AddEquation.displacementMap, LinearMipMapNearestFilter = !!AddEquation.emissiveMap, LinearMipMapLinearFilter = !!AddEquation.metalnessMap, UnsignedByteType = !!AddEquation.roughnessMap, ByteType = AddEquation.anisotropy > 0, ShortType = AddEquation.clearcoat > 0, UnsignedShortType = AddEquation.dispersion > 0, IntType = AddEquation.iridescence > 0, UnsignedIntType = AddEquation.sheen > 0, FloatType = AddEquation.transmission > 0, HalfFloatType = ByteType && !!AddEquation.anisotropyMap, UnsignedShort4444Type = ShortType && !!AddEquation.clearcoatMap, UnsignedShort5551Type = ShortType && !!AddEquation.clearcoatNormalMap, UnsignedInt248Type = ShortType && !!AddEquation.clearcoatRoughnessMap, UnsignedInt5999Type = IntType && !!AddEquation.iridescenceMap, RGBAFormat = IntType && !!AddEquation.iridescenceThicknessMap, DepthFormat = UnsignedIntType && !!AddEquation.sheenColorMap, DepthStencilFormat = UnsignedIntType && !!AddEquation.sheenRoughnessMap, RedFormat = !!AddEquation.specularMap, RedIntegerFormat = !!AddEquation.specularColorMap, RGIntegerFormat = !!AddEquation.specularIntensityMap, RGBAIntegerFormat = FloatType && !!AddEquation.transmissionMap, RGB_S3TC_DXT1_Format = FloatType && !!AddEquation.thicknessMap, RGBA_S3TC_DXT1_Format = !!AddEquation.gradientMap, RGBA_S3TC_DXT3_Format = !!AddEquation.alphaMap, RGBA_S3TC_DXT5_Format = AddEquation.alphaTest > 0, RGB_PVRTC_4BPPV1_Format = !!AddEquation.alphaHash, RGB_PVRTC_2BPPV1_Format = !!AddEquation.extensions;
                    let RGBA_PVRTC_4BPPV1_Format = 0;
                    AddEquation.toneMapped && (null !== AttachedBindMode && !0 !== AttachedBindMode.isXRRenderTarget || (RGBA_PVRTC_4BPPV1_Format = REVISION.toneMapping));
                    const RGBA_PVRTC_2BPPV1_Format = {
                        shaderID: b,
                        shaderType: AddEquation.type,
                        shaderName: AddEquation.name,
                        vertexShader: LessEqualDepth,
                        fragmentShader: MultiplyBlending,
                        defines: AddEquation.defines,
                        customVertexShaderID: CustomBlending,
                        customFragmentShaderID: GreaterDepth,
                        isRawShaderMaterial: !0 === AddEquation.isRawShaderMaterial,
                        glslVersion: AddEquation.glslVersion,
                        precision: OneMinusSrcAlphaFactor,
                        batching: EquirectangularReflectionMapping,
                        batchingColor: EquirectangularReflectionMapping && null !== OneMinusDstColorFactor._colorsTexture,
                        instancing: CubeRefractionMapping,
                        instancingColor: CubeRefractionMapping && null !== OneMinusDstColorFactor.instanceColor,
                        instancingMorph: CubeRefractionMapping && null !== OneMinusDstColorFactor.morphTexture,
                        supportsVertexTextures: SrcAlphaFactor,
                        outputColorSpace: null === AttachedBindMode ? REVISION.outputColorSpace : !0 === AttachedBindMode.isXRRenderTarget ? AttachedBindMode.texture.colorSpace : LinearSRGBColorSpace,
                        alphaToCoverage: !!AddEquation.alphaToCoverage,
                        map: EquirectangularRefractionMapping,
                        matcap: RepeatWrapping,
                        envMap: ClampToEdgeWrapping,
                        envMapMode: ClampToEdgeWrapping && ConstantAlphaFactor.mapping,
                        envMapCubeUVHeight: OneMinusConstantAlphaFactor,
                        aoMap: MirroredRepeatWrapping,
                        lightMap: NearestFilter,
                        bumpMap: NearestMipMapNearestFilter,
                        normalMap: NearestMipMapLinearFilter,
                        displacementMap: SrcAlphaFactor && LinearFilter,
                        emissiveMap: LinearMipMapNearestFilter,
                        normalMapObjectSpace: NearestMipMapLinearFilter && 1 === AddEquation.normalMapType,
                        normalMapTangentSpace: NearestMipMapLinearFilter && 0 === AddEquation.normalMapType,
                        metalnessMap: LinearMipMapLinearFilter,
                        roughnessMap: UnsignedByteType,
                        anisotropy: ByteType,
                        anisotropyMap: HalfFloatType,
                        clearcoat: ShortType,
                        clearcoatMap: UnsignedShort4444Type,
                        clearcoatNormalMap: UnsignedShort5551Type,
                        clearcoatRoughnessMap: UnsignedInt248Type,
                        dispersion: UnsignedShortType,
                        iridescence: IntType,
                        iridescenceMap: UnsignedInt5999Type,
                        iridescenceThicknessMap: RGBAFormat,
                        sheen: UnsignedIntType,
                        sheenColorMap: DepthFormat,
                        sheenRoughnessMap: DepthStencilFormat,
                        specularMap: RedFormat,
                        specularColorMap: RedIntegerFormat,
                        specularIntensityMap: RGIntegerFormat,
                        transmission: FloatType,
                        transmissionMap: RGBAIntegerFormat,
                        thicknessMap: RGB_S3TC_DXT1_Format,
                        gradientMap: RGBA_S3TC_DXT1_Format,
                        opaque: !1 === AddEquation.transparent && 1 === AddEquation.blending && !1 === AddEquation.alphaToCoverage,
                        alphaMap: RGBA_S3TC_DXT3_Format,
                        alphaTest: RGBA_S3TC_DXT5_Format,
                        alphaHash: RGB_PVRTC_4BPPV1_Format,
                        combine: AddEquation.combine,
                        mapUv: EquirectangularRefractionMapping && OneMinusDstAlphaFactor(AddEquation.map.channel),
                        aoMapUv: MirroredRepeatWrapping && OneMinusDstAlphaFactor(AddEquation.aoMap.channel),
                        lightMapUv: NearestFilter && OneMinusDstAlphaFactor(AddEquation.lightMap.channel),
                        bumpMapUv: NearestMipMapNearestFilter && OneMinusDstAlphaFactor(AddEquation.bumpMap.channel),
                        normalMapUv: NearestMipMapLinearFilter && OneMinusDstAlphaFactor(AddEquation.normalMap.channel),
                        displacementMapUv: LinearFilter && OneMinusDstAlphaFactor(AddEquation.displacementMap.channel),
                        emissiveMapUv: LinearMipMapNearestFilter && OneMinusDstAlphaFactor(AddEquation.emissiveMap.channel),
                        metalnessMapUv: LinearMipMapLinearFilter && OneMinusDstAlphaFactor(AddEquation.metalnessMap.channel),
                        roughnessMapUv: UnsignedByteType && OneMinusDstAlphaFactor(AddEquation.roughnessMap.channel),
                        anisotropyMapUv: HalfFloatType && OneMinusDstAlphaFactor(AddEquation.anisotropyMap.channel),
                        clearcoatMapUv: UnsignedShort4444Type && OneMinusDstAlphaFactor(AddEquation.clearcoatMap.channel),
                        clearcoatNormalMapUv: UnsignedShort5551Type && OneMinusDstAlphaFactor(AddEquation.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: UnsignedInt248Type && OneMinusDstAlphaFactor(AddEquation.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: UnsignedInt5999Type && OneMinusDstAlphaFactor(AddEquation.iridescenceMap.channel),
                        iridescenceThicknessMapUv: RGBAFormat && OneMinusDstAlphaFactor(AddEquation.iridescenceThicknessMap.channel),
                        sheenColorMapUv: DepthFormat && OneMinusDstAlphaFactor(AddEquation.sheenColorMap.channel),
                        sheenRoughnessMapUv: DepthStencilFormat && OneMinusDstAlphaFactor(AddEquation.sheenRoughnessMap.channel),
                        specularMapUv: RedFormat && OneMinusDstAlphaFactor(AddEquation.specularMap.channel),
                        specularColorMapUv: RedIntegerFormat && OneMinusDstAlphaFactor(AddEquation.specularColorMap.channel),
                        specularIntensityMapUv: RGIntegerFormat && OneMinusDstAlphaFactor(AddEquation.specularIntensityMap.channel),
                        transmissionMapUv: RGBAIntegerFormat && OneMinusDstAlphaFactor(AddEquation.transmissionMap.channel),
                        thicknessMapUv: RGB_S3TC_DXT1_Format && OneMinusDstAlphaFactor(AddEquation.thicknessMap.channel),
                        alphaMapUv: RGBA_S3TC_DXT3_Format && OneMinusDstAlphaFactor(AddEquation.alphaMap.channel),
                        vertexTangents: !!ConstantColorFactor.attributes.tangent && (NearestMipMapLinearFilter || ByteType),
                        vertexColors: AddEquation.vertexColors,
                        vertexAlphas: !0 === AddEquation.vertexColors && !!ConstantColorFactor.attributes.color && 4 === ConstantColorFactor.attributes.color.itemSize,
                        pointsUvs: !0 === OneMinusDstColorFactor.isPoints && !!ConstantColorFactor.attributes.uv && (EquirectangularRefractionMapping || RGBA_S3TC_DXT3_Format),
                        fog: !!SrcAlphaSaturateFactor,
                        useFog: !0 === AddEquation.fog,
                        fogExp2: !!SrcAlphaSaturateFactor && SrcAlphaSaturateFactor.isFogExp2,
                        flatShading: !0 === AddEquation.flatShading,
                        sizeAttenuation: !0 === AddEquation.sizeAttenuation,
                        logarithmicDepthBuffer: OneMinusSrcColorFactor,
                        reverseDepthBuffer: CubeReflectionMapping,
                        skinning: !0 === OneMinusDstColorFactor.isSkinnedMesh,
                        morphTargets: void 0 !== ConstantColorFactor.morphAttributes.position,
                        morphNormals: void 0 !== ConstantColorFactor.morphAttributes.normal,
                        morphColors: void 0 !== ConstantColorFactor.morphAttributes.color,
                        morphTargetsCount: CullFaceFront,
                        morphTextureStride: NotEqualDepth,
                        numDirLights: ReverseSubtractEquation.directional.length,
                        numPointLights: ReverseSubtractEquation.point.length,
                        numSpotLights: ReverseSubtractEquation.spot.length,
                        numSpotLightMaps: ReverseSubtractEquation.spotLightMap.length,
                        numRectAreaLights: ReverseSubtractEquation.rectArea.length,
                        numHemiLights: ReverseSubtractEquation.hemi.length,
                        numDirLightShadows: ReverseSubtractEquation.directionalShadowMap.length,
                        numPointLightShadows: ReverseSubtractEquation.pointShadowMap.length,
                        numSpotLightShadows: ReverseSubtractEquation.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: ReverseSubtractEquation.numSpotLightShadowsWithMaps,
                        numLightProbes: ReverseSubtractEquation.numLightProbes,
                        numClippingPlanes: SubtractEquation.numPlanes,
                        numClipIntersection: SubtractEquation.numIntersection,
                        dithering: AddEquation.dithering,
                        shadowMapEnabled: REVISION.shadowMap.enabled && SrcColorFactor.length > 0,
                        shadowMapType: REVISION.shadowMap.type,
                        toneMapping: RGBA_PVRTC_4BPPV1_Format,
                        decodeVideoTexture: EquirectangularRefractionMapping && !0 === AddEquation.map.isVideoTexture && _tables.getTransfer(AddEquation.map.colorSpace) === SRGBTransfer,
                        decodeVideoTextureEmissive: LinearMipMapNearestFilter && !0 === AddEquation.emissiveMap.isVideoTexture && _tables.getTransfer(AddEquation.emissiveMap.colorSpace) === SRGBTransfer,
                        premultipliedAlpha: AddEquation.premultipliedAlpha,
                        doubleSided: 2 === AddEquation.side,
                        flipSided: 1 === AddEquation.side,
                        useDepthPacking: AddEquation.depthPacking >= 0,
                        depthPacking: AddEquation.depthPacking || 0,
                        index0AttributeName: AddEquation.index0AttributeName,
                        extensionClipCullDistance: RGB_PVRTC_2BPPV1_Format && !0 === AddEquation.extensions.clipCullDistance && i.has('WEBGL_clip_cull_distance'),
                        extensionMultiDraw: (RGB_PVRTC_2BPPV1_Format && !0 === AddEquation.extensions.multiDraw || EquirectangularReflectionMapping) && i.has('WEBGL_multi_draw'),
                        rendererExtensionParallelShaderCompile: i.has('KHR_parallel_shader_compile'),
                        customProgramCacheKey: AddEquation.customProgramCacheKey()
                    };
                    return RGBA_PVRTC_2BPPV1_Format.vertexUv1s = OneFactor.has(1), RGBA_PVRTC_2BPPV1_Format.vertexUv2s = OneFactor.has(2), RGBA_PVRTC_2BPPV1_Format.vertexUv3s = OneFactor.has(3), OneFactor.clear(), RGBA_PVRTC_2BPPV1_Format;
                },
                getProgramCacheKey: function (t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                        for (const REVISION in t.defines)
                            n.push(REVISION), n.push(t.defines[REVISION]);
                    return !1 === t.isRawShaderMaterial && (!function (REVISION, t) {
                        REVISION.push(t.precision), REVISION.push(t.outputColorSpace), REVISION.push(t.envMapMode), REVISION.push(t.envMapCubeUVHeight), REVISION.push(t.mapUv), REVISION.push(t.alphaMapUv), REVISION.push(t.lightMapUv), REVISION.push(t.aoMapUv), REVISION.push(t.bumpMapUv), REVISION.push(t.normalMapUv), REVISION.push(t.displacementMapUv), REVISION.push(t.emissiveMapUv), REVISION.push(t.metalnessMapUv), REVISION.push(t.roughnessMapUv), REVISION.push(t.anisotropyMapUv), REVISION.push(t.clearcoatMapUv), REVISION.push(t.clearcoatNormalMapUv), REVISION.push(t.clearcoatRoughnessMapUv), REVISION.push(t.iridescenceMapUv), REVISION.push(t.iridescenceThicknessMapUv), REVISION.push(t.sheenColorMapUv), REVISION.push(t.sheenRoughnessMapUv), REVISION.push(t.specularMapUv), REVISION.push(t.specularColorMapUv), REVISION.push(t.specularIntensityMapUv), REVISION.push(t.transmissionMapUv), REVISION.push(t.thicknessMapUv), REVISION.push(t.combine), REVISION.push(t.fogExp2), REVISION.push(t.sizeAttenuation), REVISION.push(t.morphTargetsCount), REVISION.push(t.morphAttributeCount), REVISION.push(t.numDirLights), REVISION.push(t.numPointLights), REVISION.push(t.numSpotLights), REVISION.push(t.numSpotLightMaps), REVISION.push(t.numHemiLights), REVISION.push(t.numRectAreaLights), REVISION.push(t.numDirLightShadows), REVISION.push(t.numPointLightShadows), REVISION.push(t.numSpotLightShadows), REVISION.push(t.numSpotLightShadowsWithMaps), REVISION.push(t.numLightProbes), REVISION.push(t.shadowMapType), REVISION.push(t.toneMapping), REVISION.push(t.numClippingPlanes), REVISION.push(t.numClipIntersection), REVISION.push(t.depthPacking);
                    }(n, t), function (REVISION, t) {
                        ReverseSubtractEquation.disableAll(), t.supportsVertexTextures && ReverseSubtractEquation.enable(0);
                        t.instancing && ReverseSubtractEquation.enable(1);
                        t.instancingColor && ReverseSubtractEquation.enable(2);
                        t.instancingMorph && ReverseSubtractEquation.enable(3);
                        t.matcap && ReverseSubtractEquation.enable(4);
                        t.envMap && ReverseSubtractEquation.enable(5);
                        t.normalMapObjectSpace && ReverseSubtractEquation.enable(6);
                        t.normalMapTangentSpace && ReverseSubtractEquation.enable(7);
                        t.clearcoat && ReverseSubtractEquation.enable(8);
                        t.iridescence && ReverseSubtractEquation.enable(9);
                        t.alphaTest && ReverseSubtractEquation.enable(10);
                        t.vertexColors && ReverseSubtractEquation.enable(11);
                        t.vertexAlphas && ReverseSubtractEquation.enable(12);
                        t.vertexUv1s && ReverseSubtractEquation.enable(13);
                        t.vertexUv2s && ReverseSubtractEquation.enable(14);
                        t.vertexUv3s && ReverseSubtractEquation.enable(15);
                        t.vertexTangents && ReverseSubtractEquation.enable(16);
                        t.anisotropy && ReverseSubtractEquation.enable(17);
                        t.alphaHash && ReverseSubtractEquation.enable(18);
                        t.batching && ReverseSubtractEquation.enable(19);
                        t.dispersion && ReverseSubtractEquation.enable(20);
                        t.batchingColor && ReverseSubtractEquation.enable(21);
                        REVISION.push(ReverseSubtractEquation.mask), ReverseSubtractEquation.disableAll(), t.fog && ReverseSubtractEquation.enable(0);
                        t.useFog && ReverseSubtractEquation.enable(1);
                        t.flatShading && ReverseSubtractEquation.enable(2);
                        t.logarithmicDepthBuffer && ReverseSubtractEquation.enable(3);
                        t.reverseDepthBuffer && ReverseSubtractEquation.enable(4);
                        t.skinning && ReverseSubtractEquation.enable(5);
                        t.morphTargets && ReverseSubtractEquation.enable(6);
                        t.morphNormals && ReverseSubtractEquation.enable(7);
                        t.morphColors && ReverseSubtractEquation.enable(8);
                        t.premultipliedAlpha && ReverseSubtractEquation.enable(9);
                        t.shadowMapEnabled && ReverseSubtractEquation.enable(10);
                        t.doubleSided && ReverseSubtractEquation.enable(11);
                        t.flipSided && ReverseSubtractEquation.enable(12);
                        t.useDepthPacking && ReverseSubtractEquation.enable(13);
                        t.dithering && ReverseSubtractEquation.enable(14);
                        t.transmission && ReverseSubtractEquation.enable(15);
                        t.sheen && ReverseSubtractEquation.enable(16);
                        t.opaque && ReverseSubtractEquation.enable(17);
                        t.pointsUvs && ReverseSubtractEquation.enable(18);
                        t.decodeVideoTexture && ReverseSubtractEquation.enable(19);
                        t.decodeVideoTextureEmissive && ReverseSubtractEquation.enable(20);
                        t.alphaToCoverage && ReverseSubtractEquation.enable(21);
                        REVISION.push(ReverseSubtractEquation.mask);
                    }(n, t), n.push(REVISION.outputColorSpace)), n.push(t.customProgramCacheKey), n.join();
                },
                getUniforms: function (REVISION) {
                    const t = DstAlphaFactor[REVISION.type];
                    let n;
                    if (t) {
                        const REVISION = Au[t];
                        n = UniformsUtils.clone(REVISION.uniforms);
                    } else
                        n = REVISION.uniforms;
                    return n;
                },
                acquireProgram: function (t, n) {
                    let i;
                    for (let REVISION = 0, t = SrcColorFactor.length; REVISION < t; REVISION++) {
                        const t = SrcColorFactor[REVISION];
                        if (t.cacheKey === n) {
                            i = t, ++i.usedTimes;
                            break;
                        }
                    }
                    return void 0 === i && (i = new bp(REVISION, n, t, AddEquation), SrcColorFactor.push(i)), i;
                },
                releaseProgram: function (REVISION) {
                    if (0 == --REVISION.usedTimes) {
                        const t = SrcColorFactor.indexOf(REVISION);
                        SrcColorFactor[t] = SrcColorFactor[SrcColorFactor.length - 1], SrcColorFactor.pop(), REVISION.destroy();
                    }
                },
                releaseShaderCache: function (REVISION) {
                    ZeroFactor.remove(REVISION);
                },
                programs: SrcColorFactor,
                dispose: function () {
                    ZeroFactor.dispose();
                }
            };
        }
        function Cp() {
            let REVISION = new WeakMap();
            return {
                has: function (t) {
                    return REVISION.has(t);
                },
                get: function (t) {
                    let n = REVISION.get(t);
                    return void 0 === n && (n = {}, REVISION.set(t, n)), n;
                },
                remove: function (t) {
                    REVISION.delete(t);
                },
                update: function (t, n, i) {
                    REVISION.get(t)[n] = i;
                },
                dispose: function () {
                    REVISION = new WeakMap();
                }
            };
        }
        function Ip(REVISION, t) {
            return REVISION.groupOrder !== t.groupOrder ? REVISION.groupOrder - t.groupOrder : REVISION.renderOrder !== t.renderOrder ? REVISION.renderOrder - t.renderOrder : REVISION.material.id !== t.material.id ? REVISION.material.id - t.material.id : REVISION.z !== t.z ? REVISION.z - t.z : REVISION.id - t.id;
        }
        function Rp(REVISION, t) {
            return REVISION.groupOrder !== t.groupOrder ? REVISION.groupOrder - t.groupOrder : REVISION.renderOrder !== t.renderOrder ? REVISION.renderOrder - t.renderOrder : REVISION.z !== t.z ? t.z - REVISION.z : REVISION.id - t.id;
        }
        function Pp() {
            const REVISION = [];
            let t = 0;
            const n = [], i = [], r = [];
            function AddEquation(n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                let ZeroFactor = REVISION[t];
                return void 0 === ZeroFactor ? (ZeroFactor = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: AddEquation,
                    renderOrder: n.renderOrder,
                    z: SubtractEquation,
                    group: ReverseSubtractEquation
                }, REVISION[t] = ZeroFactor) : (ZeroFactor.id = n.id, ZeroFactor.object = n, ZeroFactor.geometry = i, ZeroFactor.material = r, ZeroFactor.groupOrder = AddEquation, ZeroFactor.renderOrder = n.renderOrder, ZeroFactor.z = SubtractEquation, ZeroFactor.group = ReverseSubtractEquation), t++, ZeroFactor;
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function () {
                    t = 0, n.length = 0, i.length = 0, r.length = 0;
                },
                push: function (REVISION, t, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) {
                    const SrcColorFactor = AddEquation(REVISION, t, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor);
                    SubtractEquation.transmission > 0 ? i.push(SrcColorFactor) : !0 === SubtractEquation.transparent ? r.push(SrcColorFactor) : n.push(SrcColorFactor);
                },
                unshift: function (REVISION, t, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) {
                    const SrcColorFactor = AddEquation(REVISION, t, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor);
                    SubtractEquation.transmission > 0 ? i.unshift(SrcColorFactor) : !0 === SubtractEquation.transparent ? r.unshift(SrcColorFactor) : n.unshift(SrcColorFactor);
                },
                finish: function () {
                    for (let n = t, i = REVISION.length; n < i; n++) {
                        const t = REVISION[n];
                        if (null === t.id)
                            break;
                        t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null;
                    }
                },
                sort: function (REVISION, t) {
                    n.length > 1 && n.sort(REVISION || Ip), i.length > 1 && i.sort(t || Rp), r.length > 1 && r.sort(t || Rp);
                }
            };
        }
        function Bp() {
            let REVISION = new WeakMap();
            return {
                get: function (t, n) {
                    const i = REVISION.get(t);
                    let r;
                    return void 0 === i ? (r = new Pp(), REVISION.set(t, [r])) : n >= i.length ? (r = new Pp(), i.push(r)) : r = i[n], r;
                },
                dispose: function () {
                    REVISION = new WeakMap();
                }
            };
        }
        function Dp() {
            const REVISION = {};
            return {
                get: function (t) {
                    if (void 0 !== REVISION[t.id])
                        return REVISION[t.id];
                    let n;
                    switch (t.type) {
                    case 'DirectionalLight':
                        n = {
                            direction: new Vector3(),
                            color: new Color()
                        };
                        break;
                    case 'SpotLight':
                        n = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case 'PointLight':
                        n = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case 'HemisphereLight':
                        n = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;
                    case 'RectAreaLight':
                        n = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                        };
                    }
                    return REVISION[t.id] = n, n;
                }
            };
        }
        let Lp = 0;
        function Up(REVISION, t) {
            return (t.castShadow ? 2 : 0) - (REVISION.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (REVISION.map ? 1 : 0);
        }
        function Np(REVISION) {
            const t = new Dp(), n = function () {
                    const REVISION = {};
                    return {
                        get: function (t) {
                            if (void 0 !== REVISION[t.id])
                                return REVISION[t.id];
                            let n;
                            switch (t.type) {
                            case 'DirectionalLight':
                            case 'SpotLight':
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Vector2()
                                };
                                break;
                            case 'PointLight':
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Vector2(),
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1000
                                };
                            }
                            return REVISION[t.id] = n, n;
                        }
                    };
                }(), i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [
                        0,
                        0,
                        0
                    ],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
            for (let REVISION = 0; REVISION < 9; REVISION++)
                i.probe.push(new Vector3());
            const r = new Vector3(), AddEquation = new Matrix4(), SubtractEquation = new Matrix4();
            return {
                setup: function (r) {
                    let AddEquation = 0, SubtractEquation = 0, ReverseSubtractEquation = 0;
                    for (let REVISION = 0; REVISION < 9; REVISION++)
                        i.probe[REVISION].set(0, 0, 0);
                    let ZeroFactor = 0, OneFactor = 0, SrcColorFactor = 0, OneMinusSrcColorFactor = 0, SrcAlphaFactor = 0, OneMinusSrcAlphaFactor = 0, DstAlphaFactor = 0, OneMinusDstAlphaFactor = 0, DstColorFactor = 0, OneMinusDstColorFactor = 0, SrcAlphaSaturateFactor = 0;
                    r.sort(Up);
                    for (let REVISION = 0, ConstantColorFactor = r.length; REVISION < ConstantColorFactor; REVISION++) {
                        const ConstantColorFactor = r[REVISION], OneMinusConstantColorFactor = ConstantColorFactor.color, ConstantAlphaFactor = ConstantColorFactor.intensity, OneMinusConstantAlphaFactor = ConstantColorFactor.distance, b = ConstantColorFactor.shadow && ConstantColorFactor.shadow.map ? ConstantColorFactor.shadow.map.texture : null;
                        if (ConstantColorFactor.isAmbientLight)
                            AddEquation += OneMinusConstantColorFactor.r * ConstantAlphaFactor, SubtractEquation += OneMinusConstantColorFactor.g * ConstantAlphaFactor, ReverseSubtractEquation += OneMinusConstantColorFactor.b * ConstantAlphaFactor;
                        else if (ConstantColorFactor.isLightProbe) {
                            for (let REVISION = 0; REVISION < 9; REVISION++)
                                i.probe[REVISION].addScaledVector(ConstantColorFactor.sh.coefficients[REVISION], ConstantAlphaFactor);
                            SrcAlphaSaturateFactor++;
                        } else if (ConstantColorFactor.isDirectionalLight) {
                            const REVISION = t.get(ConstantColorFactor);
                            if (REVISION.color.copy(ConstantColorFactor.color).multiplyScalar(ConstantColorFactor.intensity), ConstantColorFactor.castShadow) {
                                const REVISION = ConstantColorFactor.shadow, t = n.get(ConstantColorFactor);
                                t.shadowIntensity = REVISION.intensity, t.shadowBias = REVISION.bias, t.shadowNormalBias = REVISION.normalBias, t.shadowRadius = REVISION.radius, t.shadowMapSize = REVISION.mapSize, i.directionalShadow[ZeroFactor] = t, i.directionalShadowMap[ZeroFactor] = b, i.directionalShadowMatrix[ZeroFactor] = ConstantColorFactor.shadow.matrix, OneMinusSrcAlphaFactor++;
                            }
                            i.directional[ZeroFactor] = REVISION, ZeroFactor++;
                        } else if (ConstantColorFactor.isSpotLight) {
                            const REVISION = t.get(ConstantColorFactor);
                            REVISION.position.setFromMatrixPosition(ConstantColorFactor.matrixWorld), REVISION.color.copy(OneMinusConstantColorFactor).multiplyScalar(ConstantAlphaFactor), REVISION.distance = OneMinusConstantAlphaFactor, REVISION.coneCos = Math.cos(ConstantColorFactor.angle), REVISION.penumbraCos = Math.cos(ConstantColorFactor.angle * (1 - ConstantColorFactor.penumbra)), REVISION.decay = ConstantColorFactor.decay, i.spot[SrcColorFactor] = REVISION;
                            const r = ConstantColorFactor.shadow;
                            if (ConstantColorFactor.map && (i.spotLightMap[DstColorFactor] = ConstantColorFactor.map, DstColorFactor++, r.updateMatrices(ConstantColorFactor), ConstantColorFactor.castShadow && OneMinusDstColorFactor++), i.spotLightMatrix[SrcColorFactor] = r.matrix, ConstantColorFactor.castShadow) {
                                const REVISION = n.get(ConstantColorFactor);
                                REVISION.shadowIntensity = r.intensity, REVISION.shadowBias = r.bias, REVISION.shadowNormalBias = r.normalBias, REVISION.shadowRadius = r.radius, REVISION.shadowMapSize = r.mapSize, i.spotShadow[SrcColorFactor] = REVISION, i.spotShadowMap[SrcColorFactor] = b, OneMinusDstAlphaFactor++;
                            }
                            SrcColorFactor++;
                        } else if (ConstantColorFactor.isRectAreaLight) {
                            const REVISION = t.get(ConstantColorFactor);
                            REVISION.color.copy(OneMinusConstantColorFactor).multiplyScalar(ConstantAlphaFactor), REVISION.halfWidth.set(0.5 * ConstantColorFactor.width, 0, 0), REVISION.halfHeight.set(0, 0.5 * ConstantColorFactor.height, 0), i.rectArea[OneMinusSrcColorFactor] = REVISION, OneMinusSrcColorFactor++;
                        } else if (ConstantColorFactor.isPointLight) {
                            const REVISION = t.get(ConstantColorFactor);
                            if (REVISION.color.copy(ConstantColorFactor.color).multiplyScalar(ConstantColorFactor.intensity), REVISION.distance = ConstantColorFactor.distance, REVISION.decay = ConstantColorFactor.decay, ConstantColorFactor.castShadow) {
                                const REVISION = ConstantColorFactor.shadow, t = n.get(ConstantColorFactor);
                                t.shadowIntensity = REVISION.intensity, t.shadowBias = REVISION.bias, t.shadowNormalBias = REVISION.normalBias, t.shadowRadius = REVISION.radius, t.shadowMapSize = REVISION.mapSize, t.shadowCameraNear = REVISION.camera.near, t.shadowCameraFar = REVISION.camera.far, i.pointShadow[OneFactor] = t, i.pointShadowMap[OneFactor] = b, i.pointShadowMatrix[OneFactor] = ConstantColorFactor.shadow.matrix, DstAlphaFactor++;
                            }
                            i.point[OneFactor] = REVISION, OneFactor++;
                        } else if (ConstantColorFactor.isHemisphereLight) {
                            const REVISION = t.get(ConstantColorFactor);
                            REVISION.skyColor.copy(ConstantColorFactor.color).multiplyScalar(ConstantAlphaFactor), REVISION.groundColor.copy(ConstantColorFactor.groundColor).multiplyScalar(ConstantAlphaFactor), i.hemi[SrcAlphaFactor] = REVISION, SrcAlphaFactor++;
                        }
                    }
                    OneMinusSrcColorFactor > 0 && (!0 === REVISION.has('OES_texture_float_linear') ? (i.rectAreaLTC1 = gu.LTC_FLOAT_1, i.rectAreaLTC2 = gu.LTC_FLOAT_2) : (i.rectAreaLTC1 = gu.LTC_HALF_1, i.rectAreaLTC2 = gu.LTC_HALF_2)), i.ambient[0] = AddEquation, i.ambient[1] = SubtractEquation, i.ambient[2] = ReverseSubtractEquation;
                    const ConstantColorFactor = i.hash;
                    ConstantColorFactor.directionalLength === ZeroFactor && ConstantColorFactor.pointLength === OneFactor && ConstantColorFactor.spotLength === SrcColorFactor && ConstantColorFactor.rectAreaLength === OneMinusSrcColorFactor && ConstantColorFactor.hemiLength === SrcAlphaFactor && ConstantColorFactor.numDirectionalShadows === OneMinusSrcAlphaFactor && ConstantColorFactor.numPointShadows === DstAlphaFactor && ConstantColorFactor.numSpotShadows === OneMinusDstAlphaFactor && ConstantColorFactor.numSpotMaps === DstColorFactor && ConstantColorFactor.numLightProbes === SrcAlphaSaturateFactor || (i.directional.length = ZeroFactor, i.spot.length = SrcColorFactor, i.rectArea.length = OneMinusSrcColorFactor, i.point.length = OneFactor, i.hemi.length = SrcAlphaFactor, i.directionalShadow.length = OneMinusSrcAlphaFactor, i.directionalShadowMap.length = OneMinusSrcAlphaFactor, i.pointShadow.length = DstAlphaFactor, i.pointShadowMap.length = DstAlphaFactor, i.spotShadow.length = OneMinusDstAlphaFactor, i.spotShadowMap.length = OneMinusDstAlphaFactor, i.directionalShadowMatrix.length = OneMinusSrcAlphaFactor, i.pointShadowMatrix.length = DstAlphaFactor, i.spotLightMatrix.length = OneMinusDstAlphaFactor + DstColorFactor - OneMinusDstColorFactor, i.spotLightMap.length = DstColorFactor, i.numSpotLightShadowsWithMaps = OneMinusDstColorFactor, i.numLightProbes = SrcAlphaSaturateFactor, ConstantColorFactor.directionalLength = ZeroFactor, ConstantColorFactor.pointLength = OneFactor, ConstantColorFactor.spotLength = SrcColorFactor, ConstantColorFactor.rectAreaLength = OneMinusSrcColorFactor, ConstantColorFactor.hemiLength = SrcAlphaFactor, ConstantColorFactor.numDirectionalShadows = OneMinusSrcAlphaFactor, ConstantColorFactor.numPointShadows = DstAlphaFactor, ConstantColorFactor.numSpotShadows = OneMinusDstAlphaFactor, ConstantColorFactor.numSpotMaps = DstColorFactor, ConstantColorFactor.numLightProbes = SrcAlphaSaturateFactor, i.version = Lp++);
                },
                setupView: function (REVISION, t) {
                    let n = 0, ReverseSubtractEquation = 0, ZeroFactor = 0, OneFactor = 0, SrcColorFactor = 0;
                    const OneMinusSrcColorFactor = t.matrixWorldInverse;
                    for (let t = 0, SrcAlphaFactor = REVISION.length; t < SrcAlphaFactor; t++) {
                        const SrcAlphaFactor = REVISION[t];
                        if (SrcAlphaFactor.isDirectionalLight) {
                            const REVISION = i.directional[n];
                            REVISION.direction.setFromMatrixPosition(SrcAlphaFactor.matrixWorld), r.setFromMatrixPosition(SrcAlphaFactor.target.matrixWorld), REVISION.direction.sub(r), REVISION.direction.transformDirection(OneMinusSrcColorFactor), n++;
                        } else if (SrcAlphaFactor.isSpotLight) {
                            const REVISION = i.spot[ZeroFactor];
                            REVISION.position.setFromMatrixPosition(SrcAlphaFactor.matrixWorld), REVISION.position.applyMatrix4(OneMinusSrcColorFactor), REVISION.direction.setFromMatrixPosition(SrcAlphaFactor.matrixWorld), r.setFromMatrixPosition(SrcAlphaFactor.target.matrixWorld), REVISION.direction.sub(r), REVISION.direction.transformDirection(OneMinusSrcColorFactor), ZeroFactor++;
                        } else if (SrcAlphaFactor.isRectAreaLight) {
                            const REVISION = i.rectArea[OneFactor];
                            REVISION.position.setFromMatrixPosition(SrcAlphaFactor.matrixWorld), REVISION.position.applyMatrix4(OneMinusSrcColorFactor), SubtractEquation.identity(), AddEquation.copy(SrcAlphaFactor.matrixWorld), AddEquation.premultiply(OneMinusSrcColorFactor), SubtractEquation.extractRotation(AddEquation), REVISION.halfWidth.set(0.5 * SrcAlphaFactor.width, 0, 0), REVISION.halfHeight.set(0, 0.5 * SrcAlphaFactor.height, 0), REVISION.halfWidth.applyMatrix4(SubtractEquation), REVISION.halfHeight.applyMatrix4(SubtractEquation), OneFactor++;
                        } else if (SrcAlphaFactor.isPointLight) {
                            const REVISION = i.point[ReverseSubtractEquation];
                            REVISION.position.setFromMatrixPosition(SrcAlphaFactor.matrixWorld), REVISION.position.applyMatrix4(OneMinusSrcColorFactor), ReverseSubtractEquation++;
                        } else if (SrcAlphaFactor.isHemisphereLight) {
                            const REVISION = i.hemi[SrcColorFactor];
                            REVISION.direction.setFromMatrixPosition(SrcAlphaFactor.matrixWorld), REVISION.direction.transformDirection(OneMinusSrcColorFactor), SrcColorFactor++;
                        }
                    }
                },
                state: i
            };
        }
        function kp(REVISION) {
            const t = new Np(REVISION), n = [], i = [];
            const r = {
                lightsArray: n,
                shadowsArray: i,
                camera: null,
                lights: t,
                transmissionRenderTarget: {}
            };
            return {
                init: function (REVISION) {
                    r.camera = REVISION, n.length = 0, i.length = 0;
                },
                state: r,
                setupLights: function () {
                    t.setup(n);
                },
                setupLightsView: function (REVISION) {
                    t.setupView(n, REVISION);
                },
                pushLight: function (REVISION) {
                    n.push(REVISION);
                },
                pushShadow: function (REVISION) {
                    i.push(REVISION);
                }
            };
        }
        function Fp(REVISION) {
            let t = new WeakMap();
            return {
                get: function (n, i = 0) {
                    const r = t.get(n);
                    let AddEquation;
                    return void 0 === r ? (AddEquation = new kp(REVISION), t.set(n, [AddEquation])) : i >= r.length ? (AddEquation = new kp(REVISION), r.push(AddEquation)) : AddEquation = r[i], AddEquation;
                },
                dispose: function () {
                    t = new WeakMap();
                }
            };
        }
        function Op(REVISION, n, AddEquation) {
            let SubtractEquation = new Frustum();
            const ReverseSubtractEquation = new Vector2(), ZeroFactor = new Vector2(), OneFactor = new Vector4(), SrcColorFactor = new Sa({ depthPacking: 3201 }), OneMinusSrcColorFactor = new Ea(), SrcAlphaFactor = {}, OneMinusSrcAlphaFactor = AddEquation.maxTextureSize, DstAlphaFactor = {
                    [t]: 1,
                    [i]: 0,
                    [r]: 2
                }, OneMinusDstAlphaFactor = new rr({
                    defines: { VSM_SAMPLES: 8 },
                    uniforms: {
                        shadow_pass: { value: null },
                        resolution: { value: new Vector2() },
                        radius: { value: 4 }
                    },
                    vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
                    fragmentShader: 'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
                }), DstColorFactor = OneMinusDstAlphaFactor.clone();
            DstColorFactor.defines.HORIZONTAL_PASS = 1;
            const OneMinusDstColorFactor = new BufferGeometry();
            OneMinusDstColorFactor.setAttribute('position', new BufferAttribute(new Float32Array([
                -1,
                -1,
                0.5,
                3,
                -1,
                0.5,
                -1,
                3,
                0.5
            ]), 3));
            const SrcAlphaSaturateFactor = new Mesh(OneMinusDstColorFactor, OneMinusDstAlphaFactor), ConstantColorFactor = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
            let OneMinusConstantColorFactor = this.type;
            function ConstantAlphaFactor(t, i) {
                const r = n.update(SrcAlphaSaturateFactor);
                OneMinusDstAlphaFactor.defines.VSM_SAMPLES !== t.blurSamples && (OneMinusDstAlphaFactor.defines.VSM_SAMPLES = t.blurSamples, DstColorFactor.defines.VSM_SAMPLES = t.blurSamples, OneMinusDstAlphaFactor.needsUpdate = !0, DstColorFactor.needsUpdate = !0), null === t.mapPass && (t.mapPass = new jt(ReverseSubtractEquation.x, ReverseSubtractEquation.y)), OneMinusDstAlphaFactor.uniforms.shadow_pass.value = t.map.texture, OneMinusDstAlphaFactor.uniforms.resolution.value = t.mapSize, OneMinusDstAlphaFactor.uniforms.radius.value = t.radius, REVISION.setRenderTarget(t.mapPass), REVISION.clear(), REVISION.renderBufferDirect(i, null, r, OneMinusDstAlphaFactor, SrcAlphaSaturateFactor, null), DstColorFactor.uniforms.shadow_pass.value = t.mapPass.texture, DstColorFactor.uniforms.resolution.value = t.mapSize, DstColorFactor.uniforms.radius.value = t.radius, REVISION.setRenderTarget(t.map), REVISION.clear(), REVISION.renderBufferDirect(i, null, r, DstColorFactor, SrcAlphaSaturateFactor, null);
            }
            function OneMinusConstantAlphaFactor(t, n, i, r) {
                let AddEquation = null;
                const SubtractEquation = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== SubtractEquation)
                    AddEquation = SubtractEquation;
                else if (AddEquation = !0 === i.isPointLight ? OneMinusSrcColorFactor : SrcColorFactor, REVISION.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const REVISION = AddEquation.uuid, t = n.uuid;
                    let i = SrcAlphaFactor[REVISION];
                    void 0 === i && (i = {}, SrcAlphaFactor[REVISION] = i);
                    let r = i[t];
                    void 0 === r && (r = AddEquation.clone(), i[t] = r, n.addEventListener('dispose', aspect)), AddEquation = r;
                }
                if (AddEquation.visible = n.visible, AddEquation.wireframe = n.wireframe, AddEquation.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : DstAlphaFactor[n.side], AddEquation.alphaMap = n.alphaMap, AddEquation.alphaTest = n.alphaTest, AddEquation.map = n.map, AddEquation.clipShadows = n.clipShadows, AddEquation.clippingPlanes = n.clippingPlanes, AddEquation.clipIntersection = n.clipIntersection, AddEquation.displacementMap = n.displacementMap, AddEquation.displacementScale = n.displacementScale, AddEquation.displacementBias = n.displacementBias, AddEquation.wireframeLinewidth = n.wireframeLinewidth, AddEquation.linewidth = n.linewidth, !0 === i.isPointLight && !0 === AddEquation.isMeshDistanceMaterial) {
                    REVISION.properties.get(AddEquation).light = i;
                }
                return AddEquation;
            }
            function b(t, i, r, AddEquation, ReverseSubtractEquation) {
                if (!1 === t.visible)
                    return;
                if (t.layers.test(i.layers) && (t.isMesh || t.isLine || t.isPoints) && (t.castShadow || t.receiveShadow && 3 === ReverseSubtractEquation) && (!t.frustumCulled || SubtractEquation.intersectsObject(t))) {
                    t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld);
                    const SubtractEquation = n.update(t), ZeroFactor = t.material;
                    if (Array.isArray(ZeroFactor)) {
                        const n = SubtractEquation.groups;
                        for (let OneFactor = 0, SrcColorFactor = n.length; OneFactor < SrcColorFactor; OneFactor++) {
                            const SrcColorFactor = n[OneFactor], OneMinusSrcColorFactor = ZeroFactor[SrcColorFactor.materialIndex];
                            if (OneMinusSrcColorFactor && OneMinusSrcColorFactor.visible) {
                                const n = OneMinusConstantAlphaFactor(t, OneMinusSrcColorFactor, AddEquation, ReverseSubtractEquation);
                                t.onBeforeShadow(REVISION, t, i, r, SubtractEquation, n, SrcColorFactor), REVISION.renderBufferDirect(r, null, SubtractEquation, n, t, SrcColorFactor), t.onAfterShadow(REVISION, t, i, r, SubtractEquation, n, SrcColorFactor);
                            }
                        }
                    } else if (ZeroFactor.visible) {
                        const n = OneMinusConstantAlphaFactor(t, ZeroFactor, AddEquation, ReverseSubtractEquation);
                        t.onBeforeShadow(REVISION, t, i, r, SubtractEquation, n, null), REVISION.renderBufferDirect(r, null, SubtractEquation, n, t, null), t.onAfterShadow(REVISION, t, i, r, SubtractEquation, n, null);
                    }
                }
                const ZeroFactor = t.children;
                for (let REVISION = 0, t = ZeroFactor.length; REVISION < t; REVISION++)
                    b(ZeroFactor[REVISION], i, r, AddEquation, ReverseSubtractEquation);
            }
            function aspect(REVISION) {
                REVISION.target.removeEventListener('dispose', aspect);
                for (const t in SrcAlphaFactor) {
                    const n = SrcAlphaFactor[t], i = REVISION.target.uuid;
                    if (i in n) {
                        n[i].dispose(), delete n[i];
                    }
                }
            }
            this.render = function (t, n, i) {
                if (!1 === ConstantColorFactor.enabled)
                    return;
                if (!1 === ConstantColorFactor.autoUpdate && !1 === ConstantColorFactor.needsUpdate)
                    return;
                if (0 === t.length)
                    return;
                const r = REVISION.getRenderTarget(), AddEquation = REVISION.getActiveCubeFace(), SrcColorFactor = REVISION.getActiveMipmapLevel(), OneMinusSrcColorFactor = REVISION.state;
                OneMinusSrcColorFactor.setBlending(0), OneMinusSrcColorFactor.buffers.color.setClear(1, 1, 1, 1), OneMinusSrcColorFactor.buffers.depth.setTest(!0), OneMinusSrcColorFactor.setScissorTest(!1);
                const SrcAlphaFactor = 3 !== OneMinusConstantColorFactor && 3 === this.type, DstAlphaFactor = 3 === OneMinusConstantColorFactor && 3 !== this.type;
                for (let r = 0, AddEquation = t.length; r < AddEquation; r++) {
                    const AddEquation = t[r], SrcColorFactor = AddEquation.shadow;
                    if (void 0 === SrcColorFactor) {
                        console.warn('THREE.WebGLShadowMap:', AddEquation, 'has no shadow.');
                        continue;
                    }
                    if (!1 === SrcColorFactor.autoUpdate && !1 === SrcColorFactor.needsUpdate)
                        continue;
                    ReverseSubtractEquation.copy(SrcColorFactor.mapSize);
                    const OneMinusDstAlphaFactor = SrcColorFactor.getFrameExtents();
                    if (ReverseSubtractEquation.multiply(OneMinusDstAlphaFactor), ZeroFactor.copy(SrcColorFactor.mapSize), (ReverseSubtractEquation.x > OneMinusSrcAlphaFactor || ReverseSubtractEquation.y > OneMinusSrcAlphaFactor) && (ReverseSubtractEquation.x > OneMinusSrcAlphaFactor && (ZeroFactor.x = Math.floor(OneMinusSrcAlphaFactor / OneMinusDstAlphaFactor.x), ReverseSubtractEquation.x = ZeroFactor.x * OneMinusDstAlphaFactor.x, SrcColorFactor.mapSize.x = ZeroFactor.x), ReverseSubtractEquation.y > OneMinusSrcAlphaFactor && (ZeroFactor.y = Math.floor(OneMinusSrcAlphaFactor / OneMinusDstAlphaFactor.y), ReverseSubtractEquation.y = ZeroFactor.y * OneMinusDstAlphaFactor.y, SrcColorFactor.mapSize.y = ZeroFactor.y)), null === SrcColorFactor.map || !0 === SrcAlphaFactor || !0 === DstAlphaFactor) {
                        const REVISION = 3 !== this.type ? {
                            minFilter: NearestFilter,
                            magFilter: NearestFilter
                        } : {};
                        null !== SrcColorFactor.map && SrcColorFactor.map.dispose(), SrcColorFactor.map = new jt(ReverseSubtractEquation.x, ReverseSubtractEquation.y, REVISION), SrcColorFactor.map.texture.name = AddEquation.name + '.shadowMap', SrcColorFactor.camera.updateProjectionMatrix();
                    }
                    REVISION.setRenderTarget(SrcColorFactor.map), REVISION.clear();
                    const DstColorFactor = SrcColorFactor.getViewportCount();
                    for (let REVISION = 0; REVISION < DstColorFactor; REVISION++) {
                        const t = SrcColorFactor.getViewport(REVISION);
                        OneFactor.set(ZeroFactor.x * t.x, ZeroFactor.y * t.y, ZeroFactor.x * t.z, ZeroFactor.y * t.w), OneMinusSrcColorFactor.viewport(OneFactor), SrcColorFactor.updateMatrices(AddEquation, REVISION), SubtractEquation = SrcColorFactor.getFrustum(), b(n, i, SrcColorFactor.camera, AddEquation, this.type);
                    }
                    !0 !== SrcColorFactor.isPointLightShadow && 3 === this.type && ConstantAlphaFactor(SrcColorFactor, i), SrcColorFactor.needsUpdate = !1;
                }
                OneMinusConstantColorFactor = this.type, ConstantColorFactor.needsUpdate = !1, REVISION.setRenderTarget(r, AddEquation, SrcColorFactor);
            };
        }
        const zp = {
            [b]: 1,
            [CullFaceFront]: 6,
            [MultiplyBlending]: 7,
            [LessEqualDepth]: 5,
            [aspect]: 0,
            [GreaterDepth]: 2,
            [NotEqualDepth]: 4,
            [CustomBlending]: 3
        };
        function Hp(REVISION, t) {
            const n = new function () {
                    let t = !1;
                    const n = new Vector4();
                    let i = null;
                    const r = new Vector4(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || t || (REVISION.colorMask(n, n, n, n), i = n);
                        },
                        setLocked: function (REVISION) {
                            t = REVISION;
                        },
                        setClear: function (t, i, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                            !0 === ReverseSubtractEquation && (t *= SubtractEquation, i *= SubtractEquation, AddEquation *= SubtractEquation), n.set(t, i, AddEquation, SubtractEquation), !1 === r.equals(n) && (REVISION.clearColor(t, i, AddEquation, SubtractEquation), r.copy(n));
                        },
                        reset: function () {
                            t = !1, i = null, r.set(-1, 0, 0, 0);
                        }
                    };
                }(), i = new function () {
                    let n = !1, i = !1, r = null, AddEquation = null, SubtractEquation = null;
                    return {
                        setReversed: function (REVISION) {
                            if (i !== REVISION) {
                                const REVISION = t.get('EXT_clip_control');
                                i ? REVISION.clipControlEXT(REVISION.LOWER_LEFT_EXT, REVISION.ZERO_TO_ONE_EXT) : REVISION.clipControlEXT(REVISION.LOWER_LEFT_EXT, REVISION.NEGATIVE_ONE_TO_ONE_EXT);
                                const n = SubtractEquation;
                                SubtractEquation = null, this.setClear(n);
                            }
                            i = REVISION;
                        },
                        getReversed: function () {
                            return i;
                        },
                        setTest: function (t) {
                            t ? RGBAFormat(REVISION.DEPTH_TEST) : DepthFormat(REVISION.DEPTH_TEST);
                        },
                        setMask: function (t) {
                            r === t || n || (REVISION.depthMask(t), r = t);
                        },
                        setFunc: function (t) {
                            if (i && (t = zp[t]), AddEquation !== t) {
                                switch (t) {
                                case 0:
                                    REVISION.depthFunc(REVISION.NEVER);
                                    break;
                                case 1:
                                    REVISION.depthFunc(REVISION.ALWAYS);
                                    break;
                                case 2:
                                    REVISION.depthFunc(REVISION.LESS);
                                    break;
                                case 3:
                                default:
                                    REVISION.depthFunc(REVISION.LEQUAL);
                                    break;
                                case 4:
                                    REVISION.depthFunc(REVISION.EQUAL);
                                    break;
                                case 5:
                                    REVISION.depthFunc(REVISION.GEQUAL);
                                    break;
                                case 6:
                                    REVISION.depthFunc(REVISION.GREATER);
                                    break;
                                case 7:
                                    REVISION.depthFunc(REVISION.NOTEQUAL);
                                }
                                AddEquation = t;
                            }
                        },
                        setLocked: function (REVISION) {
                            n = REVISION;
                        },
                        setClear: function (t) {
                            SubtractEquation !== t && (i && (t = 1 - t), REVISION.clearDepth(t), SubtractEquation = t);
                        },
                        reset: function () {
                            n = !1, r = null, AddEquation = null, SubtractEquation = null, i = !1;
                        }
                    };
                }(), r = new function () {
                    let t = !1, n = null, i = null, r = null, AddEquation = null, SubtractEquation = null, ReverseSubtractEquation = null, ZeroFactor = null, OneFactor = null;
                    return {
                        setTest: function (n) {
                            t || (n ? RGBAFormat(REVISION.STENCIL_TEST) : DepthFormat(REVISION.STENCIL_TEST));
                        },
                        setMask: function (i) {
                            n === i || t || (REVISION.stencilMask(i), n = i);
                        },
                        setFunc: function (t, n, SubtractEquation) {
                            i === t && r === n && AddEquation === SubtractEquation || (REVISION.stencilFunc(t, n, SubtractEquation), i = t, r = n, AddEquation = SubtractEquation);
                        },
                        setOp: function (t, n, i) {
                            SubtractEquation === t && ReverseSubtractEquation === n && ZeroFactor === i || (REVISION.stencilOp(t, n, i), SubtractEquation = t, ReverseSubtractEquation = n, ZeroFactor = i);
                        },
                        setLocked: function (REVISION) {
                            t = REVISION;
                        },
                        setClear: function (t) {
                            OneFactor !== t && (REVISION.clearStencil(t), OneFactor = t);
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null, AddEquation = null, SubtractEquation = null, ReverseSubtractEquation = null, ZeroFactor = null, OneFactor = null;
                        }
                    };
                }(), b = new WeakMap(), aspect = new WeakMap();
            let CullFaceFront = {}, LessEqualDepth = {}, MultiplyBlending = new WeakMap(), CustomBlending = [], GreaterDepth = null, NotEqualDepth = !1, AttachedBindMode = null, CubeReflectionMapping = null, CubeRefractionMapping = null, EquirectangularReflectionMapping = null, EquirectangularRefractionMapping = null, CubeUVReflectionMapping = null, RepeatWrapping = null, ClampToEdgeWrapping = new Color(0, 0, 0), MirroredRepeatWrapping = 0, NearestFilter = !1, NearestMipMapNearestFilter = null, NearestMipMapLinearFilter = null, LinearFilter = null, LinearMipMapNearestFilter = null, LinearMipMapLinearFilter = null;
            const UnsignedByteType = REVISION.getParameter(REVISION.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let ByteType = !1, ShortType = 0;
            const UnsignedShortType = REVISION.getParameter(REVISION.VERSION);
            -1 !== UnsignedShortType.indexOf('WebGL') ? (ShortType = parseFloat(/^WebGL (\d)/.exec(UnsignedShortType)[1]), ByteType = ShortType >= 1) : -1 !== UnsignedShortType.indexOf('OpenGL ES') && (ShortType = parseFloat(/^OpenGL ES (\d)/.exec(UnsignedShortType)[1]), ByteType = ShortType >= 2);
            let IntType = null, UnsignedIntType = {};
            const FloatType = REVISION.getParameter(REVISION.SCISSOR_BOX), HalfFloatType = REVISION.getParameter(REVISION.VIEWPORT), UnsignedShort4444Type = new Vector4().fromArray(FloatType), UnsignedShort5551Type = new Vector4().fromArray(HalfFloatType);
            function UnsignedInt248Type(t, n, i, r) {
                const AddEquation = new Uint8Array(4), SubtractEquation = REVISION.createTexture();
                REVISION.bindTexture(t, SubtractEquation), REVISION.texParameteri(t, REVISION.TEXTURE_MIN_FILTER, REVISION.NEAREST), REVISION.texParameteri(t, REVISION.TEXTURE_MAG_FILTER, REVISION.NEAREST);
                for (let SubtractEquation = 0; SubtractEquation < i; SubtractEquation++)
                    t === REVISION.TEXTURE_3D || t === REVISION.TEXTURE_2D_ARRAY ? REVISION.texImage3D(n, 0, REVISION.RGBA, 1, 1, r, 0, REVISION.RGBA, REVISION.UNSIGNED_BYTE, AddEquation) : REVISION.texImage2D(n + SubtractEquation, 0, REVISION.RGBA, 1, 1, 0, REVISION.RGBA, REVISION.UNSIGNED_BYTE, AddEquation);
                return SubtractEquation;
            }
            const UnsignedInt5999Type = {};
            function RGBAFormat(t) {
                !0 !== CullFaceFront[t] && (REVISION.enable(t), CullFaceFront[t] = !0);
            }
            function DepthFormat(t) {
                !1 !== CullFaceFront[t] && (REVISION.disable(t), CullFaceFront[t] = !1);
            }
            UnsignedInt5999Type[REVISION.TEXTURE_2D] = UnsignedInt248Type(REVISION.TEXTURE_2D, REVISION.TEXTURE_2D, 1), UnsignedInt5999Type[REVISION.TEXTURE_CUBE_MAP] = UnsignedInt248Type(REVISION.TEXTURE_CUBE_MAP, REVISION.TEXTURE_CUBE_MAP_POSITIVE_X, 6), UnsignedInt5999Type[REVISION.TEXTURE_2D_ARRAY] = UnsignedInt248Type(REVISION.TEXTURE_2D_ARRAY, REVISION.TEXTURE_2D_ARRAY, 1, 1), UnsignedInt5999Type[REVISION.TEXTURE_3D] = UnsignedInt248Type(REVISION.TEXTURE_3D, REVISION.TEXTURE_3D, 1, 1), n.setClear(0, 0, 0, 1), i.setClear(1), r.setClear(0), RGBAFormat(REVISION.DEPTH_TEST), i.setFunc(3), RGIntegerFormat(!1), RGBAIntegerFormat(1), RGBAFormat(REVISION.CULL_FACE), RedIntegerFormat(0);
            const DepthStencilFormat = {
                [AddEquation]: REVISION.FUNC_ADD,
                [SubtractEquation]: REVISION.FUNC_SUBTRACT,
                [ReverseSubtractEquation]: REVISION.FUNC_REVERSE_SUBTRACT
            };
            DepthStencilFormat[103] = REVISION.MIN, DepthStencilFormat[104] = REVISION.MAX;
            const RedFormat = {
                [ZeroFactor]: REVISION.ZERO,
                [OneFactor]: REVISION.ONE,
                [SrcColorFactor]: REVISION.SRC_COLOR,
                [SrcAlphaFactor]: REVISION.SRC_ALPHA,
                [SrcAlphaSaturateFactor]: REVISION.SRC_ALPHA_SATURATE,
                [DstColorFactor]: REVISION.DST_COLOR,
                [DstAlphaFactor]: REVISION.DST_ALPHA,
                [OneMinusSrcColorFactor]: REVISION.ONE_MINUS_SRC_COLOR,
                [OneMinusSrcAlphaFactor]: REVISION.ONE_MINUS_SRC_ALPHA,
                [OneMinusDstColorFactor]: REVISION.ONE_MINUS_DST_COLOR,
                [OneMinusDstAlphaFactor]: REVISION.ONE_MINUS_DST_ALPHA,
                [ConstantColorFactor]: REVISION.CONSTANT_COLOR,
                [OneMinusConstantColorFactor]: REVISION.ONE_MINUS_CONSTANT_COLOR,
                [ConstantAlphaFactor]: REVISION.CONSTANT_ALPHA,
                [OneMinusConstantAlphaFactor]: REVISION.ONE_MINUS_CONSTANT_ALPHA
            };
            function RedIntegerFormat(t, n, i, r, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor) {
                if (0 !== t) {
                    if (!1 === NotEqualDepth && (RGBAFormat(REVISION.BLEND), NotEqualDepth = !0), 5 === t)
                        SubtractEquation = SubtractEquation || n, ReverseSubtractEquation = ReverseSubtractEquation || i, ZeroFactor = ZeroFactor || r, n === CubeReflectionMapping && SubtractEquation === EquirectangularRefractionMapping || (REVISION.blendEquationSeparate(DepthStencilFormat[n], DepthStencilFormat[SubtractEquation]), CubeReflectionMapping = n, EquirectangularRefractionMapping = SubtractEquation), i === CubeRefractionMapping && r === EquirectangularReflectionMapping && ReverseSubtractEquation === CubeUVReflectionMapping && ZeroFactor === RepeatWrapping || (REVISION.blendFuncSeparate(RedFormat[i], RedFormat[r], RedFormat[ReverseSubtractEquation], RedFormat[ZeroFactor]), CubeRefractionMapping = i, EquirectangularReflectionMapping = r, CubeUVReflectionMapping = ReverseSubtractEquation, RepeatWrapping = ZeroFactor), !1 !== OneFactor.equals(ClampToEdgeWrapping) && SrcColorFactor === MirroredRepeatWrapping || (REVISION.blendColor(OneFactor.r, OneFactor.g, OneFactor.b, SrcColorFactor), ClampToEdgeWrapping.copy(OneFactor), MirroredRepeatWrapping = SrcColorFactor), AttachedBindMode = t, NearestFilter = !1;
                    else if (t !== AttachedBindMode || OneMinusSrcColorFactor !== NearestFilter) {
                        if (CubeReflectionMapping === AddEquation && EquirectangularRefractionMapping === AddEquation || (REVISION.blendEquation(REVISION.FUNC_ADD), CubeReflectionMapping = AddEquation, EquirectangularRefractionMapping = AddEquation), OneMinusSrcColorFactor)
                            switch (t) {
                            case 1:
                                REVISION.blendFuncSeparate(REVISION.ONE, REVISION.ONE_MINUS_SRC_ALPHA, REVISION.ONE, REVISION.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                REVISION.blendFunc(REVISION.ONE, REVISION.ONE);
                                break;
                            case 3:
                                REVISION.blendFuncSeparate(REVISION.ZERO, REVISION.ONE_MINUS_SRC_COLOR, REVISION.ZERO, REVISION.ONE);
                                break;
                            case 4:
                                REVISION.blendFuncSeparate(REVISION.ZERO, REVISION.SRC_COLOR, REVISION.ZERO, REVISION.SRC_ALPHA);
                                break;
                            default:
                                console.error('THREE.WebGLState: Invalid blending: ', t);
                            }
                        else
                            switch (t) {
                            case 1:
                                REVISION.blendFuncSeparate(REVISION.SRC_ALPHA, REVISION.ONE_MINUS_SRC_ALPHA, REVISION.ONE, REVISION.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                REVISION.blendFunc(REVISION.SRC_ALPHA, REVISION.ONE);
                                break;
                            case 3:
                                REVISION.blendFuncSeparate(REVISION.ZERO, REVISION.ONE_MINUS_SRC_COLOR, REVISION.ZERO, REVISION.ONE);
                                break;
                            case 4:
                                REVISION.blendFunc(REVISION.ZERO, REVISION.SRC_COLOR);
                                break;
                            default:
                                console.error('THREE.WebGLState: Invalid blending: ', t);
                            }
                        CubeRefractionMapping = null, EquirectangularReflectionMapping = null, CubeUVReflectionMapping = null, RepeatWrapping = null, ClampToEdgeWrapping.set(0, 0, 0), MirroredRepeatWrapping = 0, AttachedBindMode = t, NearestFilter = OneMinusSrcColorFactor;
                    }
                } else
                    !0 === NotEqualDepth && (DepthFormat(REVISION.BLEND), NotEqualDepth = !1);
            }
            function RGIntegerFormat(t) {
                NearestMipMapNearestFilter !== t && (t ? REVISION.frontFace(REVISION.CW) : REVISION.frontFace(REVISION.CCW), NearestMipMapNearestFilter = t);
            }
            function RGBAIntegerFormat(t) {
                0 !== t ? (RGBAFormat(REVISION.CULL_FACE), t !== NearestMipMapLinearFilter && (1 === t ? REVISION.cullFace(REVISION.BACK) : 2 === t ? REVISION.cullFace(REVISION.FRONT) : REVISION.cullFace(REVISION.FRONT_AND_BACK))) : DepthFormat(REVISION.CULL_FACE), NearestMipMapLinearFilter = t;
            }
            function RGB_S3TC_DXT1_Format(t, n, i) {
                t ? (RGBAFormat(REVISION.POLYGON_OFFSET_FILL), LinearMipMapNearestFilter === n && LinearMipMapLinearFilter === i || (REVISION.polygonOffset(n, i), LinearMipMapNearestFilter = n, LinearMipMapLinearFilter = i)) : DepthFormat(REVISION.POLYGON_OFFSET_FILL);
            }
            return {
                buffers: {
                    color: n,
                    depth: i,
                    stencil: r
                },
                enable: RGBAFormat,
                disable: DepthFormat,
                bindFramebuffer: function (t, n) {
                    return LessEqualDepth[t] !== n && (REVISION.bindFramebuffer(t, n), LessEqualDepth[t] = n, t === REVISION.DRAW_FRAMEBUFFER && (LessEqualDepth[REVISION.FRAMEBUFFER] = n), t === REVISION.FRAMEBUFFER && (LessEqualDepth[REVISION.DRAW_FRAMEBUFFER] = n), !0);
                },
                drawBuffers: function (t, n) {
                    let i = CustomBlending, r = !1;
                    if (t) {
                        i = MultiplyBlending.get(n), void 0 === i && (i = [], MultiplyBlending.set(n, i));
                        const AddEquation = t.textures;
                        if (i.length !== AddEquation.length || i[0] !== REVISION.COLOR_ATTACHMENT0) {
                            for (let t = 0, n = AddEquation.length; t < n; t++)
                                i[t] = REVISION.COLOR_ATTACHMENT0 + t;
                            i.length = AddEquation.length, r = !0;
                        }
                    } else
                        i[0] !== REVISION.BACK && (i[0] = REVISION.BACK, r = !0);
                    r && REVISION.drawBuffers(i);
                },
                useProgram: function (t) {
                    return GreaterDepth !== t && (REVISION.useProgram(t), GreaterDepth = t, !0);
                },
                setBlending: RedIntegerFormat,
                setMaterial: function (t, AddEquation) {
                    2 === t.side ? DepthFormat(REVISION.CULL_FACE) : RGBAFormat(REVISION.CULL_FACE);
                    let SubtractEquation = 1 === t.side;
                    AddEquation && (SubtractEquation = !SubtractEquation), RGIntegerFormat(SubtractEquation), 1 === t.blending && !1 === t.transparent ? RedIntegerFormat(0) : RedIntegerFormat(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), i.setFunc(t.depthFunc), i.setTest(t.depthTest), i.setMask(t.depthWrite), n.setMask(t.colorWrite);
                    const ReverseSubtractEquation = t.stencilWrite;
                    r.setTest(ReverseSubtractEquation), ReverseSubtractEquation && (r.setMask(t.stencilWriteMask), r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), RGB_S3TC_DXT1_Format(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? RGBAFormat(REVISION.SAMPLE_ALPHA_TO_COVERAGE) : DepthFormat(REVISION.SAMPLE_ALPHA_TO_COVERAGE);
                },
                setFlipSided: RGIntegerFormat,
                setCullFace: RGBAIntegerFormat,
                setLineWidth: function (t) {
                    t !== LinearFilter && (ByteType && REVISION.lineWidth(t), LinearFilter = t);
                },
                setPolygonOffset: RGB_S3TC_DXT1_Format,
                setScissorTest: function (t) {
                    t ? RGBAFormat(REVISION.SCISSOR_TEST) : DepthFormat(REVISION.SCISSOR_TEST);
                },
                activeTexture: function (t) {
                    void 0 === t && (t = REVISION.TEXTURE0 + UnsignedByteType - 1), IntType !== t && (REVISION.activeTexture(t), IntType = t);
                },
                bindTexture: function (t, n, i) {
                    void 0 === i && (i = null === IntType ? REVISION.TEXTURE0 + UnsignedByteType - 1 : IntType);
                    let r = UnsignedIntType[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, UnsignedIntType[i] = r), r.type === t && r.texture === n || (IntType !== i && (REVISION.activeTexture(i), IntType = i), REVISION.bindTexture(t, n || UnsignedInt5999Type[t]), r.type = t, r.texture = n);
                },
                unbindTexture: function () {
                    const t = UnsignedIntType[IntType];
                    void 0 !== t && void 0 !== t.type && (REVISION.bindTexture(t.type, null), t.type = void 0, t.texture = void 0);
                },
                compressedTexImage2D: function () {
                    try {
                        REVISION.compressedTexImage2D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                compressedTexImage3D: function () {
                    try {
                        REVISION.compressedTexImage3D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                texImage2D: function () {
                    try {
                        REVISION.texImage2D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                texImage3D: function () {
                    try {
                        REVISION.texImage3D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                updateUBOMapping: function (t, n) {
                    let i = aspect.get(n);
                    void 0 === i && (i = new WeakMap(), aspect.set(n, i));
                    let r = i.get(t);
                    void 0 === r && (r = REVISION.getUniformBlockIndex(n, t.name), i.set(t, r));
                },
                uniformBlockBinding: function (t, n) {
                    const i = aspect.get(n).get(t);
                    b.get(n) !== i && (REVISION.uniformBlockBinding(n, i, t.__bindingPointIndex), b.set(n, i));
                },
                texStorage2D: function () {
                    try {
                        REVISION.texStorage2D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                texStorage3D: function () {
                    try {
                        REVISION.texStorage3D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                texSubImage2D: function () {
                    try {
                        REVISION.texSubImage2D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                texSubImage3D: function () {
                    try {
                        REVISION.texSubImage3D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                compressedTexSubImage2D: function () {
                    try {
                        REVISION.compressedTexSubImage2D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                compressedTexSubImage3D: function () {
                    try {
                        REVISION.compressedTexSubImage3D(...arguments);
                    } catch (REVISION) {
                        console.error('THREE.WebGLState:', REVISION);
                    }
                },
                scissor: function (t) {
                    !1 === UnsignedShort4444Type.equals(t) && (REVISION.scissor(t.x, t.y, t.z, t.w), UnsignedShort4444Type.copy(t));
                },
                viewport: function (t) {
                    !1 === UnsignedShort5551Type.equals(t) && (REVISION.viewport(t.x, t.y, t.z, t.w), UnsignedShort5551Type.copy(t));
                },
                reset: function () {
                    REVISION.disable(REVISION.BLEND), REVISION.disable(REVISION.CULL_FACE), REVISION.disable(REVISION.DEPTH_TEST), REVISION.disable(REVISION.POLYGON_OFFSET_FILL), REVISION.disable(REVISION.SCISSOR_TEST), REVISION.disable(REVISION.STENCIL_TEST), REVISION.disable(REVISION.SAMPLE_ALPHA_TO_COVERAGE), REVISION.blendEquation(REVISION.FUNC_ADD), REVISION.blendFunc(REVISION.ONE, REVISION.ZERO), REVISION.blendFuncSeparate(REVISION.ONE, REVISION.ZERO, REVISION.ONE, REVISION.ZERO), REVISION.blendColor(0, 0, 0, 0), REVISION.colorMask(!0, !0, !0, !0), REVISION.clearColor(0, 0, 0, 0), REVISION.depthMask(!0), REVISION.depthFunc(REVISION.LESS), i.setReversed(!1), REVISION.clearDepth(1), REVISION.stencilMask(4294967295), REVISION.stencilFunc(REVISION.ALWAYS, 0, 4294967295), REVISION.stencilOp(REVISION.KEEP, REVISION.KEEP, REVISION.KEEP), REVISION.clearStencil(0), REVISION.cullFace(REVISION.BACK), REVISION.frontFace(REVISION.CCW), REVISION.polygonOffset(0, 0), REVISION.activeTexture(REVISION.TEXTURE0), REVISION.bindFramebuffer(REVISION.FRAMEBUFFER, null), REVISION.bindFramebuffer(REVISION.DRAW_FRAMEBUFFER, null), REVISION.bindFramebuffer(REVISION.READ_FRAMEBUFFER, null), REVISION.useProgram(null), REVISION.lineWidth(1), REVISION.scissor(0, 0, REVISION.canvas.width, REVISION.canvas.height), REVISION.viewport(0, 0, REVISION.canvas.width, REVISION.canvas.height), CullFaceFront = {}, IntType = null, UnsignedIntType = {}, LessEqualDepth = {}, MultiplyBlending = new WeakMap(), CustomBlending = [], GreaterDepth = null, NotEqualDepth = !1, AttachedBindMode = null, CubeReflectionMapping = null, CubeRefractionMapping = null, EquirectangularReflectionMapping = null, EquirectangularRefractionMapping = null, CubeUVReflectionMapping = null, RepeatWrapping = null, ClampToEdgeWrapping = new Color(0, 0, 0), MirroredRepeatWrapping = 0, NearestFilter = !1, NearestMipMapNearestFilter = null, NearestMipMapLinearFilter = null, LinearFilter = null, LinearMipMapNearestFilter = null, LinearMipMapLinearFilter = null, UnsignedShort4444Type.set(0, 0, REVISION.canvas.width, REVISION.canvas.height), UnsignedShort5551Type.set(0, 0, REVISION.canvas.width, REVISION.canvas.height), n.reset(), i.reset(), r.reset();
                }
            };
        }
        function Wp(REVISION, t, n, i, r, AddEquation, SubtractEquation) {
            const ReverseSubtractEquation = t.has('WEBGL_multisampled_render_to_texture') ? t.get('WEBGL_multisampled_render_to_texture') : null, ZeroFactor = 'undefined' != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), OneFactor = new Vector2(), SrcColorFactor = new WeakMap();
            let OneMinusSrcColorFactor;
            const SrcAlphaFactor = new WeakMap();
            let OneMinusSrcAlphaFactor = !1;
            try {
                OneMinusSrcAlphaFactor = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext('2d');
            } catch (REVISION) {
            }
            function DstAlphaFactor(REVISION, t) {
                return OneMinusSrcAlphaFactor ? new OffscreenCanvas(REVISION, t) : createElementNS('canvas');
            }
            function OneMinusDstAlphaFactor(REVISION, t, n) {
                let i = 1;
                const r = UnsignedShort4444Type(REVISION);
                if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)), i < 1) {
                    if ('undefined' != typeof HTMLImageElement && REVISION instanceof HTMLImageElement || 'undefined' != typeof HTMLCanvasElement && REVISION instanceof HTMLCanvasElement || 'undefined' != typeof ImageBitmap && REVISION instanceof ImageBitmap || 'undefined' != typeof VideoFrame && REVISION instanceof VideoFrame) {
                        const n = Math.floor(i * r.width), AddEquation = Math.floor(i * r.height);
                        void 0 === OneMinusSrcColorFactor && (OneMinusSrcColorFactor = DstAlphaFactor(n, AddEquation));
                        const SubtractEquation = t ? DstAlphaFactor(n, AddEquation) : OneMinusSrcColorFactor;
                        SubtractEquation.width = n, SubtractEquation.height = AddEquation;
                        return SubtractEquation.getContext('2d').drawImage(REVISION, 0, 0, n, AddEquation), console.warn('THREE.WebGLRenderer: Texture has been resized from (' + r.width + 'x' + r.height + ') to (' + n + 'x' + AddEquation + ').'), SubtractEquation;
                    }
                    return 'data' in REVISION && console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + r.width + 'x' + r.height + ').'), REVISION;
                }
                return REVISION;
            }
            function DstColorFactor(REVISION) {
                return REVISION.generateMipmaps;
            }
            function OneMinusDstColorFactor(t) {
                REVISION.generateMipmap(t);
            }
            function SrcAlphaSaturateFactor(t) {
                return t.isWebGLCubeRenderTarget ? REVISION.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? REVISION.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? REVISION.TEXTURE_2D_ARRAY : REVISION.TEXTURE_2D;
            }
            function ConstantColorFactor(n, i, r, AddEquation, SubtractEquation = !1) {
                if (null !== n) {
                    if (void 0 !== REVISION[n])
                        return REVISION[n];
                    console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + n + '\'');
                }
                let ReverseSubtractEquation = i;
                if (i === REVISION.RED && (r === REVISION.FLOAT && (ReverseSubtractEquation = REVISION.R32F), r === REVISION.HALF_FLOAT && (ReverseSubtractEquation = REVISION.R16F), r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = REVISION.R8)), i === REVISION.RED_INTEGER && (r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = REVISION.R8UI), r === REVISION.UNSIGNED_SHORT && (ReverseSubtractEquation = REVISION.R16UI), r === REVISION.UNSIGNED_INT && (ReverseSubtractEquation = REVISION.R32UI), r === REVISION.BYTE && (ReverseSubtractEquation = REVISION.R8I), r === REVISION.SHORT && (ReverseSubtractEquation = REVISION.R16I), r === REVISION.INT && (ReverseSubtractEquation = REVISION.R32I)), i === REVISION.RG && (r === REVISION.FLOAT && (ReverseSubtractEquation = REVISION.RG32F), r === REVISION.HALF_FLOAT && (ReverseSubtractEquation = REVISION.RG16F), r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = REVISION.RG8)), i === REVISION.RG_INTEGER && (r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = REVISION.RG8UI), r === REVISION.UNSIGNED_SHORT && (ReverseSubtractEquation = REVISION.RG16UI), r === REVISION.UNSIGNED_INT && (ReverseSubtractEquation = REVISION.RG32UI), r === REVISION.BYTE && (ReverseSubtractEquation = REVISION.RG8I), r === REVISION.SHORT && (ReverseSubtractEquation = REVISION.RG16I), r === REVISION.INT && (ReverseSubtractEquation = REVISION.RG32I)), i === REVISION.RGB_INTEGER && (r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = REVISION.RGB8UI), r === REVISION.UNSIGNED_SHORT && (ReverseSubtractEquation = REVISION.RGB16UI), r === REVISION.UNSIGNED_INT && (ReverseSubtractEquation = REVISION.RGB32UI), r === REVISION.BYTE && (ReverseSubtractEquation = REVISION.RGB8I), r === REVISION.SHORT && (ReverseSubtractEquation = REVISION.RGB16I), r === REVISION.INT && (ReverseSubtractEquation = REVISION.RGB32I)), i === REVISION.RGBA_INTEGER && (r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = REVISION.RGBA8UI), r === REVISION.UNSIGNED_SHORT && (ReverseSubtractEquation = REVISION.RGBA16UI), r === REVISION.UNSIGNED_INT && (ReverseSubtractEquation = REVISION.RGBA32UI), r === REVISION.BYTE && (ReverseSubtractEquation = REVISION.RGBA8I), r === REVISION.SHORT && (ReverseSubtractEquation = REVISION.RGBA16I), r === REVISION.INT && (ReverseSubtractEquation = REVISION.RGBA32I)), i === REVISION.RGB && r === REVISION.UNSIGNED_INT_5_9_9_9_REV && (ReverseSubtractEquation = REVISION.RGB9_E5), i === REVISION.RGBA) {
                    const t = SubtractEquation ? LinearTransfer : _tables.getTransfer(AddEquation);
                    r === REVISION.FLOAT && (ReverseSubtractEquation = REVISION.RGBA32F), r === REVISION.HALF_FLOAT && (ReverseSubtractEquation = REVISION.RGBA16F), r === REVISION.UNSIGNED_BYTE && (ReverseSubtractEquation = t === SRGBTransfer ? REVISION.SRGB8_ALPHA8 : REVISION.RGBA8), r === REVISION.UNSIGNED_SHORT_4_4_4_4 && (ReverseSubtractEquation = REVISION.RGBA4), r === REVISION.UNSIGNED_SHORT_5_5_5_1 && (ReverseSubtractEquation = REVISION.RGB5_A1);
                }
                return ReverseSubtractEquation !== REVISION.R16F && ReverseSubtractEquation !== REVISION.R32F && ReverseSubtractEquation !== REVISION.RG16F && ReverseSubtractEquation !== REVISION.RG32F && ReverseSubtractEquation !== REVISION.RGBA16F && ReverseSubtractEquation !== REVISION.RGBA32F || t.get('EXT_color_buffer_float'), ReverseSubtractEquation;
            }
            function OneMinusConstantColorFactor(t, n) {
                let i;
                return t ? null === n || n === UnsignedIntType || n === UnsignedInt248Type ? i = REVISION.DEPTH24_STENCIL8 : n === FloatType ? i = REVISION.DEPTH32F_STENCIL8 : n === UnsignedShortType && (i = REVISION.DEPTH24_STENCIL8, console.warn('DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.')) : null === n || n === UnsignedIntType || n === UnsignedInt248Type ? i = REVISION.DEPTH_COMPONENT24 : n === FloatType ? i = REVISION.DEPTH_COMPONENT32F : n === UnsignedShortType && (i = REVISION.DEPTH_COMPONENT16), i;
            }
            function ConstantAlphaFactor(REVISION, t) {
                return !0 === DstColorFactor(REVISION) || REVISION.isFramebufferTexture && REVISION.minFilter !== NearestFilter && REVISION.minFilter !== LinearFilter ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== REVISION.mipmaps && REVISION.mipmaps.length > 0 ? REVISION.mipmaps.length : REVISION.isCompressedTexture && Array.isArray(REVISION.image) ? t.mipmaps.length : 1;
            }
            function OneMinusConstantAlphaFactor(REVISION) {
                const t = REVISION.target;
                t.removeEventListener('dispose', OneMinusConstantAlphaFactor), function (REVISION) {
                    const t = i.get(REVISION);
                    if (void 0 === t.__webglInit)
                        return;
                    const n = REVISION.source, r = SrcAlphaFactor.get(n);
                    if (r) {
                        const i = r[t.__cacheKey];
                        i.usedTimes--, 0 === i.usedTimes && aspect(REVISION), 0 === Object.keys(r).length && SrcAlphaFactor.delete(n);
                    }
                    i.remove(REVISION);
                }(t), t.isVideoTexture && SrcColorFactor.delete(t);
            }
            function b(t) {
                const n = t.target;
                n.removeEventListener('dispose', b), function (t) {
                    const n = i.get(t);
                    t.depthTexture && (t.depthTexture.dispose(), i.remove(t.depthTexture));
                    if (t.isWebGLCubeRenderTarget)
                        for (let t = 0; t < 6; t++) {
                            if (Array.isArray(n.__webglFramebuffer[t]))
                                for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                                    REVISION.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                            else
                                REVISION.deleteFramebuffer(n.__webglFramebuffer[t]);
                            n.__webglDepthbuffer && REVISION.deleteRenderbuffer(n.__webglDepthbuffer[t]);
                        }
                    else {
                        if (Array.isArray(n.__webglFramebuffer))
                            for (let t = 0; t < n.__webglFramebuffer.length; t++)
                                REVISION.deleteFramebuffer(n.__webglFramebuffer[t]);
                        else
                            REVISION.deleteFramebuffer(n.__webglFramebuffer);
                        if (n.__webglDepthbuffer && REVISION.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && REVISION.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                            for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                                n.__webglColorRenderbuffer[t] && REVISION.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                        n.__webglDepthRenderbuffer && REVISION.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                    }
                    const r = t.textures;
                    for (let t = 0, n = r.length; t < n; t++) {
                        const n = i.get(r[t]);
                        n.__webglTexture && (REVISION.deleteTexture(n.__webglTexture), SubtractEquation.memory.textures--), i.remove(r[t]);
                    }
                    i.remove(t);
                }(n);
            }
            function aspect(t) {
                const n = i.get(t);
                REVISION.deleteTexture(n.__webglTexture);
                const r = t.source;
                delete SrcAlphaFactor.get(r)[n.__cacheKey], SubtractEquation.memory.textures--;
            }
            let CullFaceFront = 0;
            function LessEqualDepth(t, r) {
                const AddEquation = i.get(t);
                if (t.isVideoTexture && function (REVISION) {
                        const t = SubtractEquation.render.frame;
                        SrcColorFactor.get(REVISION) !== t && (SrcColorFactor.set(REVISION, t), REVISION.update());
                    }(t), !1 === t.isRenderTargetTexture && t.version > 0 && AddEquation.__version !== t.version) {
                    const REVISION = t.image;
                    if (null === REVISION)
                        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
                    else {
                        if (!1 !== REVISION.complete)
                            return void CubeReflectionMapping(AddEquation, t, r);
                        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
                    }
                }
                n.bindTexture(REVISION.TEXTURE_2D, AddEquation.__webglTexture, REVISION.TEXTURE0 + r);
            }
            const MultiplyBlending = {
                    [RepeatWrapping]: REVISION.REPEAT,
                    [ClampToEdgeWrapping]: REVISION.CLAMP_TO_EDGE,
                    [MirroredRepeatWrapping]: REVISION.MIRRORED_REPEAT
                }, CustomBlending = {
                    [NearestFilter]: REVISION.NEAREST,
                    [NearestMipMapNearestFilter]: REVISION.NEAREST_MIPMAP_NEAREST,
                    [NearestMipMapLinearFilter]: REVISION.NEAREST_MIPMAP_LINEAR,
                    [LinearFilter]: REVISION.LINEAR,
                    [LinearMipMapNearestFilter]: REVISION.LINEAR_MIPMAP_NEAREST,
                    [LinearMipMapLinearFilter]: REVISION.LINEAR_MIPMAP_LINEAR
                }, GreaterDepth = {
                    [NeverStencilFunc]: REVISION.NEVER,
                    [AlwaysCompare]: REVISION.ALWAYS,
                    [LessStencilFunc]: REVISION.LESS,
                    [LessEqualStencilFunc]: REVISION.LEQUAL,
                    [EqualStencilFunc]: REVISION.EQUAL,
                    [GreaterEqualStencilFunc]: REVISION.GEQUAL,
                    [GreaterStencilFunc]: REVISION.GREATER,
                    [NotEqualStencilFunc]: REVISION.NOTEQUAL
                };
            function NotEqualDepth(n, AddEquation) {
                if (AddEquation.type !== FloatType || !1 !== t.has('OES_texture_float_linear') || AddEquation.magFilter !== LinearFilter && AddEquation.magFilter !== LinearMipMapNearestFilter && AddEquation.magFilter !== NearestMipMapLinearFilter && AddEquation.magFilter !== LinearMipMapLinearFilter && AddEquation.minFilter !== LinearFilter && AddEquation.minFilter !== LinearMipMapNearestFilter && AddEquation.minFilter !== NearestMipMapLinearFilter && AddEquation.minFilter !== LinearMipMapLinearFilter || console.warn('THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'), REVISION.texParameteri(n, REVISION.TEXTURE_WRAP_S, MultiplyBlending[AddEquation.wrapS]), REVISION.texParameteri(n, REVISION.TEXTURE_WRAP_T, MultiplyBlending[AddEquation.wrapT]), n !== REVISION.TEXTURE_3D && n !== REVISION.TEXTURE_2D_ARRAY || REVISION.texParameteri(n, REVISION.TEXTURE_WRAP_R, MultiplyBlending[AddEquation.wrapR]), REVISION.texParameteri(n, REVISION.TEXTURE_MAG_FILTER, CustomBlending[AddEquation.magFilter]), REVISION.texParameteri(n, REVISION.TEXTURE_MIN_FILTER, CustomBlending[AddEquation.minFilter]), AddEquation.compareFunction && (REVISION.texParameteri(n, REVISION.TEXTURE_COMPARE_MODE, REVISION.COMPARE_REF_TO_TEXTURE), REVISION.texParameteri(n, REVISION.TEXTURE_COMPARE_FUNC, GreaterDepth[AddEquation.compareFunction])), !0 === t.has('EXT_texture_filter_anisotropic')) {
                    if (AddEquation.magFilter === NearestFilter)
                        return;
                    if (AddEquation.minFilter !== NearestMipMapLinearFilter && AddEquation.minFilter !== LinearMipMapLinearFilter)
                        return;
                    if (AddEquation.type === FloatType && !1 === t.has('OES_texture_float_linear'))
                        return;
                    if (AddEquation.anisotropy > 1 || i.get(AddEquation).__currentAnisotropy) {
                        const SubtractEquation = t.get('EXT_texture_filter_anisotropic');
                        REVISION.texParameterf(n, SubtractEquation.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(AddEquation.anisotropy, r.getMaxAnisotropy())), i.get(AddEquation).__currentAnisotropy = AddEquation.anisotropy;
                    }
                }
            }
            function AttachedBindMode(t, n) {
                let i = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener('dispose', OneMinusConstantAlphaFactor));
                const r = n.source;
                let AddEquation = SrcAlphaFactor.get(r);
                void 0 === AddEquation && (AddEquation = {}, SrcAlphaFactor.set(r, AddEquation));
                const ReverseSubtractEquation = function (REVISION) {
                    const t = [];
                    return t.push(REVISION.wrapS), t.push(REVISION.wrapT), t.push(REVISION.wrapR || 0), t.push(REVISION.magFilter), t.push(REVISION.minFilter), t.push(REVISION.anisotropy), t.push(REVISION.internalFormat), t.push(REVISION.format), t.push(REVISION.type), t.push(REVISION.generateMipmaps), t.push(REVISION.premultiplyAlpha), t.push(REVISION.flipY), t.push(REVISION.unpackAlignment), t.push(REVISION.colorSpace), t.join();
                }(n);
                if (ReverseSubtractEquation !== t.__cacheKey) {
                    void 0 === AddEquation[ReverseSubtractEquation] && (AddEquation[ReverseSubtractEquation] = {
                        texture: REVISION.createTexture(),
                        usedTimes: 0
                    }, SubtractEquation.memory.textures++, i = !0), AddEquation[ReverseSubtractEquation].usedTimes++;
                    const r = AddEquation[t.__cacheKey];
                    void 0 !== r && (AddEquation[t.__cacheKey].usedTimes--, 0 === r.usedTimes && aspect(n)), t.__cacheKey = ReverseSubtractEquation, t.__webglTexture = AddEquation[ReverseSubtractEquation].texture;
                }
                return i;
            }
            function CubeReflectionMapping(t, SubtractEquation, ReverseSubtractEquation) {
                let ZeroFactor = REVISION.TEXTURE_2D;
                (SubtractEquation.isDataArrayTexture || SubtractEquation.isCompressedArrayTexture) && (ZeroFactor = REVISION.TEXTURE_2D_ARRAY), SubtractEquation.isData3DTexture && (ZeroFactor = REVISION.TEXTURE_3D);
                const OneFactor = AttachedBindMode(t, SubtractEquation), SrcColorFactor = SubtractEquation.source;
                n.bindTexture(ZeroFactor, t.__webglTexture, REVISION.TEXTURE0 + ReverseSubtractEquation);
                const OneMinusSrcColorFactor = i.get(SrcColorFactor);
                if (SrcColorFactor.version !== OneMinusSrcColorFactor.__version || !0 === OneFactor) {
                    n.activeTexture(REVISION.TEXTURE0 + ReverseSubtractEquation);
                    const t = _tables.getPrimaries(_tables.workingColorSpace), i = SubtractEquation.colorSpace === qe ? null : _tables.getPrimaries(SubtractEquation.colorSpace), SrcAlphaFactor = SubtractEquation.colorSpace === qe || t === i ? REVISION.NONE : REVISION.BROWSER_DEFAULT_WEBGL;
                    REVISION.pixelStorei(REVISION.UNPACK_FLIP_Y_WEBGL, SubtractEquation.flipY), REVISION.pixelStorei(REVISION.UNPACK_PREMULTIPLY_ALPHA_WEBGL, SubtractEquation.premultiplyAlpha), REVISION.pixelStorei(REVISION.UNPACK_ALIGNMENT, SubtractEquation.unpackAlignment), REVISION.pixelStorei(REVISION.UNPACK_COLORSPACE_CONVERSION_WEBGL, SrcAlphaFactor);
                    let OneMinusSrcAlphaFactor = OneMinusDstAlphaFactor(SubtractEquation.image, !1, r.maxTextureSize);
                    OneMinusSrcAlphaFactor = HalfFloatType(SubtractEquation, OneMinusSrcAlphaFactor);
                    const DstAlphaFactor = AddEquation.convert(SubtractEquation.format, SubtractEquation.colorSpace), SrcAlphaSaturateFactor = AddEquation.convert(SubtractEquation.type);
                    let OneMinusConstantAlphaFactor, b = ConstantColorFactor(SubtractEquation.internalFormat, DstAlphaFactor, SrcAlphaSaturateFactor, SubtractEquation.colorSpace, SubtractEquation.isVideoTexture);
                    NotEqualDepth(ZeroFactor, SubtractEquation);
                    const aspect = SubtractEquation.mipmaps, CullFaceFront = !0 !== SubtractEquation.isVideoTexture, LessEqualDepth = void 0 === OneMinusSrcColorFactor.__version || !0 === OneFactor, MultiplyBlending = SrcColorFactor.dataReady, CustomBlending = ConstantAlphaFactor(SubtractEquation, OneMinusSrcAlphaFactor);
                    if (SubtractEquation.isDepthTexture)
                        b = OneMinusConstantColorFactor(SubtractEquation.format === DepthStencilFormat, SubtractEquation.type), LessEqualDepth && (CullFaceFront ? n.texStorage2D(REVISION.TEXTURE_2D, 1, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height) : n.texImage2D(REVISION.TEXTURE_2D, 0, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, 0, DstAlphaFactor, SrcAlphaSaturateFactor, null));
                    else if (SubtractEquation.isDataTexture)
                        if (aspect.length > 0) {
                            CullFaceFront && LessEqualDepth && n.texStorage2D(REVISION.TEXTURE_2D, CustomBlending, b, aspect[0].width, aspect[0].height);
                            for (let t = 0, i = aspect.length; t < i; t++)
                                OneMinusConstantAlphaFactor = aspect[t], CullFaceFront ? MultiplyBlending && n.texSubImage2D(REVISION.TEXTURE_2D, t, 0, 0, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor.data) : n.texImage2D(REVISION.TEXTURE_2D, t, b, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor.data);
                            SubtractEquation.generateMipmaps = !1;
                        } else
                            CullFaceFront ? (LessEqualDepth && n.texStorage2D(REVISION.TEXTURE_2D, CustomBlending, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height), MultiplyBlending && n.texSubImage2D(REVISION.TEXTURE_2D, 0, 0, 0, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor.data)) : n.texImage2D(REVISION.TEXTURE_2D, 0, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor.data);
                    else if (SubtractEquation.isCompressedTexture)
                        if (SubtractEquation.isCompressedArrayTexture) {
                            CullFaceFront && LessEqualDepth && n.texStorage3D(REVISION.TEXTURE_2D_ARRAY, CustomBlending, b, aspect[0].width, aspect[0].height, OneMinusSrcAlphaFactor.depth);
                            for (let t = 0, i = aspect.length; t < i; t++)
                                if (OneMinusConstantAlphaFactor = aspect[t], SubtractEquation.format !== RGBAFormat)
                                    if (null !== DstAlphaFactor)
                                        if (CullFaceFront) {
                                            if (MultiplyBlending)
                                                if (SubtractEquation.layerUpdates.size > 0) {
                                                    const i = Ms(OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, SubtractEquation.format, SubtractEquation.type);
                                                    for (const r of SubtractEquation.layerUpdates) {
                                                        const AddEquation = OneMinusConstantAlphaFactor.data.subarray(r * i / OneMinusConstantAlphaFactor.data.BYTES_PER_ELEMENT, (r + 1) * i / OneMinusConstantAlphaFactor.data.BYTES_PER_ELEMENT);
                                                        n.compressedTexSubImage3D(REVISION.TEXTURE_2D_ARRAY, t, 0, 0, r, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, 1, DstAlphaFactor, AddEquation);
                                                    }
                                                    SubtractEquation.clearLayerUpdates();
                                                } else
                                                    n.compressedTexSubImage3D(REVISION.TEXTURE_2D_ARRAY, t, 0, 0, 0, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, OneMinusSrcAlphaFactor.depth, DstAlphaFactor, OneMinusConstantAlphaFactor.data);
                                        } else
                                            n.compressedTexImage3D(REVISION.TEXTURE_2D_ARRAY, t, b, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, OneMinusSrcAlphaFactor.depth, 0, OneMinusConstantAlphaFactor.data, 0, 0);
                                    else
                                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                                else
                                    CullFaceFront ? MultiplyBlending && n.texSubImage3D(REVISION.TEXTURE_2D_ARRAY, t, 0, 0, 0, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, OneMinusSrcAlphaFactor.depth, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor.data) : n.texImage3D(REVISION.TEXTURE_2D_ARRAY, t, b, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, OneMinusSrcAlphaFactor.depth, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor.data);
                        } else {
                            CullFaceFront && LessEqualDepth && n.texStorage2D(REVISION.TEXTURE_2D, CustomBlending, b, aspect[0].width, aspect[0].height);
                            for (let t = 0, i = aspect.length; t < i; t++)
                                OneMinusConstantAlphaFactor = aspect[t], SubtractEquation.format !== RGBAFormat ? null !== DstAlphaFactor ? CullFaceFront ? MultiplyBlending && n.compressedTexSubImage2D(REVISION.TEXTURE_2D, t, 0, 0, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, DstAlphaFactor, OneMinusConstantAlphaFactor.data) : n.compressedTexImage2D(REVISION.TEXTURE_2D, t, b, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, 0, OneMinusConstantAlphaFactor.data) : console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()') : CullFaceFront ? MultiplyBlending && n.texSubImage2D(REVISION.TEXTURE_2D, t, 0, 0, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor.data) : n.texImage2D(REVISION.TEXTURE_2D, t, b, OneMinusConstantAlphaFactor.width, OneMinusConstantAlphaFactor.height, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor.data);
                        }
                    else if (SubtractEquation.isDataArrayTexture)
                        if (CullFaceFront) {
                            if (LessEqualDepth && n.texStorage3D(REVISION.TEXTURE_2D_ARRAY, CustomBlending, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, OneMinusSrcAlphaFactor.depth), MultiplyBlending)
                                if (SubtractEquation.layerUpdates.size > 0) {
                                    const t = Ms(OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, SubtractEquation.format, SubtractEquation.type);
                                    for (const i of SubtractEquation.layerUpdates) {
                                        const r = OneMinusSrcAlphaFactor.data.subarray(i * t / OneMinusSrcAlphaFactor.data.BYTES_PER_ELEMENT, (i + 1) * t / OneMinusSrcAlphaFactor.data.BYTES_PER_ELEMENT);
                                        n.texSubImage3D(REVISION.TEXTURE_2D_ARRAY, 0, 0, 0, i, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, 1, DstAlphaFactor, SrcAlphaSaturateFactor, r);
                                    }
                                    SubtractEquation.clearLayerUpdates();
                                } else
                                    n.texSubImage3D(REVISION.TEXTURE_2D_ARRAY, 0, 0, 0, 0, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, OneMinusSrcAlphaFactor.depth, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor.data);
                        } else
                            n.texImage3D(REVISION.TEXTURE_2D_ARRAY, 0, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, OneMinusSrcAlphaFactor.depth, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor.data);
                    else if (SubtractEquation.isData3DTexture)
                        CullFaceFront ? (LessEqualDepth && n.texStorage3D(REVISION.TEXTURE_3D, CustomBlending, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, OneMinusSrcAlphaFactor.depth), MultiplyBlending && n.texSubImage3D(REVISION.TEXTURE_3D, 0, 0, 0, 0, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, OneMinusSrcAlphaFactor.depth, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor.data)) : n.texImage3D(REVISION.TEXTURE_3D, 0, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height, OneMinusSrcAlphaFactor.depth, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor.data);
                    else if (SubtractEquation.isFramebufferTexture) {
                        if (LessEqualDepth)
                            if (CullFaceFront)
                                n.texStorage2D(REVISION.TEXTURE_2D, CustomBlending, b, OneMinusSrcAlphaFactor.width, OneMinusSrcAlphaFactor.height);
                            else {
                                let t = OneMinusSrcAlphaFactor.width, i = OneMinusSrcAlphaFactor.height;
                                for (let r = 0; r < CustomBlending; r++)
                                    n.texImage2D(REVISION.TEXTURE_2D, r, b, t, i, 0, DstAlphaFactor, SrcAlphaSaturateFactor, null), t >>= 1, i >>= 1;
                            }
                    } else if (aspect.length > 0) {
                        if (CullFaceFront && LessEqualDepth) {
                            const t = UnsignedShort4444Type(aspect[0]);
                            n.texStorage2D(REVISION.TEXTURE_2D, CustomBlending, b, t.width, t.height);
                        }
                        for (let t = 0, i = aspect.length; t < i; t++)
                            OneMinusConstantAlphaFactor = aspect[t], CullFaceFront ? MultiplyBlending && n.texSubImage2D(REVISION.TEXTURE_2D, t, 0, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor) : n.texImage2D(REVISION.TEXTURE_2D, t, b, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusConstantAlphaFactor);
                        SubtractEquation.generateMipmaps = !1;
                    } else if (CullFaceFront) {
                        if (LessEqualDepth) {
                            const t = UnsignedShort4444Type(OneMinusSrcAlphaFactor);
                            n.texStorage2D(REVISION.TEXTURE_2D, CustomBlending, b, t.width, t.height);
                        }
                        MultiplyBlending && n.texSubImage2D(REVISION.TEXTURE_2D, 0, 0, 0, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor);
                    } else
                        n.texImage2D(REVISION.TEXTURE_2D, 0, b, DstAlphaFactor, SrcAlphaSaturateFactor, OneMinusSrcAlphaFactor);
                    DstColorFactor(SubtractEquation) && OneMinusDstColorFactor(ZeroFactor), OneMinusSrcColorFactor.__version = SrcColorFactor.version, SubtractEquation.onUpdate && SubtractEquation.onUpdate(SubtractEquation);
                }
                t.__version = SubtractEquation.version;
            }
            function CubeRefractionMapping(t, r, SubtractEquation, ZeroFactor, OneFactor, SrcColorFactor) {
                const OneMinusSrcColorFactor = AddEquation.convert(SubtractEquation.format, SubtractEquation.colorSpace), SrcAlphaFactor = AddEquation.convert(SubtractEquation.type), OneMinusSrcAlphaFactor = ConstantColorFactor(SubtractEquation.internalFormat, OneMinusSrcColorFactor, SrcAlphaFactor, SubtractEquation.colorSpace), DstAlphaFactor = i.get(r), OneMinusDstAlphaFactor = i.get(SubtractEquation);
                if (OneMinusDstAlphaFactor.__renderTarget = r, !DstAlphaFactor.__hasExternalTextures) {
                    const t = Math.max(1, r.width >> SrcColorFactor), i = Math.max(1, r.height >> SrcColorFactor);
                    OneFactor === REVISION.TEXTURE_3D || OneFactor === REVISION.TEXTURE_2D_ARRAY ? n.texImage3D(OneFactor, SrcColorFactor, OneMinusSrcAlphaFactor, t, i, r.depth, 0, OneMinusSrcColorFactor, SrcAlphaFactor, null) : n.texImage2D(OneFactor, SrcColorFactor, OneMinusSrcAlphaFactor, t, i, 0, OneMinusSrcColorFactor, SrcAlphaFactor, null);
                }
                n.bindFramebuffer(REVISION.FRAMEBUFFER, t), IntType(r) ? ReverseSubtractEquation.framebufferTexture2DMultisampleEXT(REVISION.FRAMEBUFFER, ZeroFactor, OneFactor, OneMinusDstAlphaFactor.__webglTexture, 0, ShortType(r)) : (OneFactor === REVISION.TEXTURE_2D || OneFactor >= REVISION.TEXTURE_CUBE_MAP_POSITIVE_X && OneFactor <= REVISION.TEXTURE_CUBE_MAP_NEGATIVE_Z) && REVISION.framebufferTexture2D(REVISION.FRAMEBUFFER, ZeroFactor, OneFactor, OneMinusDstAlphaFactor.__webglTexture, SrcColorFactor), n.bindFramebuffer(REVISION.FRAMEBUFFER, null);
            }
            function EquirectangularReflectionMapping(t, n, i) {
                if (REVISION.bindRenderbuffer(REVISION.RENDERBUFFER, t), n.depthBuffer) {
                    const r = n.depthTexture, AddEquation = r && r.isDepthTexture ? r.type : null, SubtractEquation = OneMinusConstantColorFactor(n.stencilBuffer, AddEquation), ZeroFactor = n.stencilBuffer ? REVISION.DEPTH_STENCIL_ATTACHMENT : REVISION.DEPTH_ATTACHMENT, OneFactor = ShortType(n);
                    IntType(n) ? ReverseSubtractEquation.renderbufferStorageMultisampleEXT(REVISION.RENDERBUFFER, OneFactor, SubtractEquation, n.width, n.height) : i ? REVISION.renderbufferStorageMultisample(REVISION.RENDERBUFFER, OneFactor, SubtractEquation, n.width, n.height) : REVISION.renderbufferStorage(REVISION.RENDERBUFFER, SubtractEquation, n.width, n.height), REVISION.framebufferRenderbuffer(REVISION.FRAMEBUFFER, ZeroFactor, REVISION.RENDERBUFFER, t);
                } else {
                    const t = n.textures;
                    for (let r = 0; r < t.length; r++) {
                        const SubtractEquation = t[r], ZeroFactor = AddEquation.convert(SubtractEquation.format, SubtractEquation.colorSpace), OneFactor = AddEquation.convert(SubtractEquation.type), SrcColorFactor = ConstantColorFactor(SubtractEquation.internalFormat, ZeroFactor, OneFactor, SubtractEquation.colorSpace), OneMinusSrcColorFactor = ShortType(n);
                        i && !1 === IntType(n) ? REVISION.renderbufferStorageMultisample(REVISION.RENDERBUFFER, OneMinusSrcColorFactor, SrcColorFactor, n.width, n.height) : IntType(n) ? ReverseSubtractEquation.renderbufferStorageMultisampleEXT(REVISION.RENDERBUFFER, OneMinusSrcColorFactor, SrcColorFactor, n.width, n.height) : REVISION.renderbufferStorage(REVISION.RENDERBUFFER, SrcColorFactor, n.width, n.height);
                    }
                }
                REVISION.bindRenderbuffer(REVISION.RENDERBUFFER, null);
            }
            function EquirectangularRefractionMapping(t) {
                const r = i.get(t), AddEquation = !0 === t.isWebGLCubeRenderTarget;
                if (r.__boundDepthTexture !== t.depthTexture) {
                    const REVISION = t.depthTexture;
                    if (r.__depthDisposeCallback && r.__depthDisposeCallback(), REVISION) {
                        const t = () => {
                            delete r.__boundDepthTexture, delete r.__depthDisposeCallback, REVISION.removeEventListener('dispose', t);
                        };
                        REVISION.addEventListener('dispose', t), r.__depthDisposeCallback = t;
                    }
                    r.__boundDepthTexture = REVISION;
                }
                if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (AddEquation)
                        throw new Error('target.depthTexture not supported in Cube render targets');
                    !function (t, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error('Depth Texture with cube render targets is not supported');
                        if (n.bindFramebuffer(REVISION.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
                        const AddEquation = i.get(r.depthTexture);
                        AddEquation.__renderTarget = r, AddEquation.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), LessEqualDepth(r.depthTexture, 0);
                        const SubtractEquation = AddEquation.__webglTexture, ZeroFactor = ShortType(r);
                        if (r.depthTexture.format === DepthFormat)
                            IntType(r) ? ReverseSubtractEquation.framebufferTexture2DMultisampleEXT(REVISION.FRAMEBUFFER, REVISION.DEPTH_ATTACHMENT, REVISION.TEXTURE_2D, SubtractEquation, 0, ZeroFactor) : REVISION.framebufferTexture2D(REVISION.FRAMEBUFFER, REVISION.DEPTH_ATTACHMENT, REVISION.TEXTURE_2D, SubtractEquation, 0);
                        else {
                            if (r.depthTexture.format !== DepthStencilFormat)
                                throw new Error('Unknown depthTexture format');
                            IntType(r) ? ReverseSubtractEquation.framebufferTexture2DMultisampleEXT(REVISION.FRAMEBUFFER, REVISION.DEPTH_STENCIL_ATTACHMENT, REVISION.TEXTURE_2D, SubtractEquation, 0, ZeroFactor) : REVISION.framebufferTexture2D(REVISION.FRAMEBUFFER, REVISION.DEPTH_STENCIL_ATTACHMENT, REVISION.TEXTURE_2D, SubtractEquation, 0);
                        }
                    }(r.__webglFramebuffer, t);
                } else if (AddEquation) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        if (n.bindFramebuffer(REVISION.FRAMEBUFFER, r.__webglFramebuffer[i]), void 0 === r.__webglDepthbuffer[i])
                            r.__webglDepthbuffer[i] = REVISION.createRenderbuffer(), EquirectangularReflectionMapping(r.__webglDepthbuffer[i], t, !1);
                        else {
                            const n = t.stencilBuffer ? REVISION.DEPTH_STENCIL_ATTACHMENT : REVISION.DEPTH_ATTACHMENT, AddEquation = r.__webglDepthbuffer[i];
                            REVISION.bindRenderbuffer(REVISION.RENDERBUFFER, AddEquation), REVISION.framebufferRenderbuffer(REVISION.FRAMEBUFFER, n, REVISION.RENDERBUFFER, AddEquation);
                        }
                } else if (n.bindFramebuffer(REVISION.FRAMEBUFFER, r.__webglFramebuffer), void 0 === r.__webglDepthbuffer)
                    r.__webglDepthbuffer = REVISION.createRenderbuffer(), EquirectangularReflectionMapping(r.__webglDepthbuffer, t, !1);
                else {
                    const n = t.stencilBuffer ? REVISION.DEPTH_STENCIL_ATTACHMENT : REVISION.DEPTH_ATTACHMENT, i = r.__webglDepthbuffer;
                    REVISION.bindRenderbuffer(REVISION.RENDERBUFFER, i), REVISION.framebufferRenderbuffer(REVISION.FRAMEBUFFER, n, REVISION.RENDERBUFFER, i);
                }
                n.bindFramebuffer(REVISION.FRAMEBUFFER, null);
            }
            const CubeUVReflectionMapping = [], ByteType = [];
            function ShortType(REVISION) {
                return Math.min(r.maxSamples, REVISION.samples);
            }
            function IntType(REVISION) {
                const n = i.get(REVISION);
                return REVISION.samples > 0 && !0 === t.has('WEBGL_multisampled_render_to_texture') && !1 !== n.__useRenderToTexture;
            }
            function HalfFloatType(REVISION, t) {
                const n = REVISION.colorSpace, i = REVISION.format, r = REVISION.type;
                return !0 === REVISION.isCompressedTexture || !0 === REVISION.isVideoTexture || n !== LinearSRGBColorSpace && n !== qe && (_tables.getTransfer(n) === SRGBTransfer ? i === RGBAFormat && r === UnsignedByteType || console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.') : console.error('THREE.WebGLTextures: Unsupported texture color space:', n)), t;
            }
            function UnsignedShort4444Type(REVISION) {
                return 'undefined' != typeof HTMLImageElement && REVISION instanceof HTMLImageElement ? (OneFactor.width = REVISION.naturalWidth || REVISION.width, OneFactor.height = REVISION.naturalHeight || REVISION.height) : 'undefined' != typeof VideoFrame && REVISION instanceof VideoFrame ? (OneFactor.width = REVISION.displayWidth, OneFactor.height = REVISION.displayHeight) : (OneFactor.width = REVISION.width, OneFactor.height = REVISION.height), OneFactor;
            }
            this.allocateTextureUnit = function () {
                const REVISION = CullFaceFront;
                return REVISION >= r.maxTextures && console.warn('THREE.WebGLTextures: Trying to use ' + REVISION + ' texture units while this GPU supports only ' + r.maxTextures), CullFaceFront += 1, REVISION;
            }, this.resetTextureUnits = function () {
                CullFaceFront = 0;
            }, this.setTexture2D = LessEqualDepth, this.setTexture2DArray = function (t, r) {
                const AddEquation = i.get(t);
                t.version > 0 && AddEquation.__version !== t.version ? CubeReflectionMapping(AddEquation, t, r) : n.bindTexture(REVISION.TEXTURE_2D_ARRAY, AddEquation.__webglTexture, REVISION.TEXTURE0 + r);
            }, this.setTexture3D = function (t, r) {
                const AddEquation = i.get(t);
                t.version > 0 && AddEquation.__version !== t.version ? CubeReflectionMapping(AddEquation, t, r) : n.bindTexture(REVISION.TEXTURE_3D, AddEquation.__webglTexture, REVISION.TEXTURE0 + r);
            }, this.setTextureCube = function (t, SubtractEquation) {
                const ReverseSubtractEquation = i.get(t);
                t.version > 0 && ReverseSubtractEquation.__version !== t.version ? function (t, SubtractEquation, ReverseSubtractEquation) {
                    if (6 !== SubtractEquation.image.length)
                        return;
                    const ZeroFactor = AttachedBindMode(t, SubtractEquation), OneFactor = SubtractEquation.source;
                    n.bindTexture(REVISION.TEXTURE_CUBE_MAP, t.__webglTexture, REVISION.TEXTURE0 + ReverseSubtractEquation);
                    const SrcColorFactor = i.get(OneFactor);
                    if (OneFactor.version !== SrcColorFactor.__version || !0 === ZeroFactor) {
                        n.activeTexture(REVISION.TEXTURE0 + ReverseSubtractEquation);
                        const t = _tables.getPrimaries(_tables.workingColorSpace), i = SubtractEquation.colorSpace === qe ? null : _tables.getPrimaries(SubtractEquation.colorSpace), OneMinusSrcColorFactor = SubtractEquation.colorSpace === qe || t === i ? REVISION.NONE : REVISION.BROWSER_DEFAULT_WEBGL;
                        REVISION.pixelStorei(REVISION.UNPACK_FLIP_Y_WEBGL, SubtractEquation.flipY), REVISION.pixelStorei(REVISION.UNPACK_PREMULTIPLY_ALPHA_WEBGL, SubtractEquation.premultiplyAlpha), REVISION.pixelStorei(REVISION.UNPACK_ALIGNMENT, SubtractEquation.unpackAlignment), REVISION.pixelStorei(REVISION.UNPACK_COLORSPACE_CONVERSION_WEBGL, OneMinusSrcColorFactor);
                        const SrcAlphaFactor = SubtractEquation.isCompressedTexture || SubtractEquation.image[0].isCompressedTexture, OneMinusSrcAlphaFactor = SubtractEquation.image[0] && SubtractEquation.image[0].isDataTexture, DstAlphaFactor = [];
                        for (let REVISION = 0; REVISION < 6; REVISION++)
                            DstAlphaFactor[REVISION] = SrcAlphaFactor || OneMinusSrcAlphaFactor ? OneMinusSrcAlphaFactor ? SubtractEquation.image[REVISION].image : SubtractEquation.image[REVISION] : OneMinusDstAlphaFactor(SubtractEquation.image[REVISION], !0, r.maxCubemapSize), DstAlphaFactor[REVISION] = HalfFloatType(SubtractEquation, DstAlphaFactor[REVISION]);
                        const SrcAlphaSaturateFactor = DstAlphaFactor[0], OneMinusConstantColorFactor = AddEquation.convert(SubtractEquation.format, SubtractEquation.colorSpace), OneMinusConstantAlphaFactor = AddEquation.convert(SubtractEquation.type), b = ConstantColorFactor(SubtractEquation.internalFormat, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, SubtractEquation.colorSpace), aspect = !0 !== SubtractEquation.isVideoTexture, CullFaceFront = void 0 === SrcColorFactor.__version || !0 === ZeroFactor, LessEqualDepth = OneFactor.dataReady;
                        let MultiplyBlending, CustomBlending = ConstantAlphaFactor(SubtractEquation, SrcAlphaSaturateFactor);
                        if (NotEqualDepth(REVISION.TEXTURE_CUBE_MAP, SubtractEquation), SrcAlphaFactor) {
                            aspect && CullFaceFront && n.texStorage2D(REVISION.TEXTURE_CUBE_MAP, CustomBlending, b, SrcAlphaSaturateFactor.width, SrcAlphaSaturateFactor.height);
                            for (let t = 0; t < 6; t++) {
                                MultiplyBlending = DstAlphaFactor[t].mipmaps;
                                for (let i = 0; i < MultiplyBlending.length; i++) {
                                    const r = MultiplyBlending[i];
                                    SubtractEquation.format !== RGBAFormat ? null !== OneMinusConstantColorFactor ? aspect ? LessEqualDepth && n.compressedTexSubImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, OneMinusConstantColorFactor, r.data) : n.compressedTexImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, b, r.width, r.height, 0, r.data) : console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()') : aspect ? LessEqualDepth && n.texSubImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, r.data) : n.texImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, b, r.width, r.height, 0, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, r.data);
                                }
                            }
                        } else {
                            if (MultiplyBlending = SubtractEquation.mipmaps, aspect && CullFaceFront) {
                                MultiplyBlending.length > 0 && CustomBlending++;
                                const t = UnsignedShort4444Type(DstAlphaFactor[0]);
                                n.texStorage2D(REVISION.TEXTURE_CUBE_MAP, CustomBlending, b, t.width, t.height);
                            }
                            for (let t = 0; t < 6; t++)
                                if (OneMinusSrcAlphaFactor) {
                                    aspect ? LessEqualDepth && n.texSubImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, DstAlphaFactor[t].width, DstAlphaFactor[t].height, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, DstAlphaFactor[t].data) : n.texImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, b, DstAlphaFactor[t].width, DstAlphaFactor[t].height, 0, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, DstAlphaFactor[t].data);
                                    for (let i = 0; i < MultiplyBlending.length; i++) {
                                        const r = MultiplyBlending[i].image[t].image;
                                        aspect ? LessEqualDepth && n.texSubImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, r.data) : n.texImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, b, r.width, r.height, 0, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, r.data);
                                    }
                                } else {
                                    aspect ? LessEqualDepth && n.texSubImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, DstAlphaFactor[t]) : n.texImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, b, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, DstAlphaFactor[t]);
                                    for (let i = 0; i < MultiplyBlending.length; i++) {
                                        const r = MultiplyBlending[i];
                                        aspect ? LessEqualDepth && n.texSubImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, r.image[t]) : n.texImage2D(REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, b, OneMinusConstantColorFactor, OneMinusConstantAlphaFactor, r.image[t]);
                                    }
                                }
                        }
                        DstColorFactor(SubtractEquation) && OneMinusDstColorFactor(REVISION.TEXTURE_CUBE_MAP), SrcColorFactor.__version = OneFactor.version, SubtractEquation.onUpdate && SubtractEquation.onUpdate(SubtractEquation);
                    }
                    t.__version = SubtractEquation.version;
                }(ReverseSubtractEquation, t, SubtractEquation) : n.bindTexture(REVISION.TEXTURE_CUBE_MAP, ReverseSubtractEquation.__webglTexture, REVISION.TEXTURE0 + SubtractEquation);
            }, this.rebindTextures = function (t, n, r) {
                const AddEquation = i.get(t);
                void 0 !== n && CubeRefractionMapping(AddEquation.__webglFramebuffer, t, t.texture, REVISION.COLOR_ATTACHMENT0, REVISION.TEXTURE_2D, 0), void 0 !== r && EquirectangularRefractionMapping(t);
            }, this.setupRenderTarget = function (t) {
                const r = t.texture, ReverseSubtractEquation = i.get(t), ZeroFactor = i.get(r);
                t.addEventListener('dispose', b);
                const OneFactor = t.textures, SrcColorFactor = !0 === t.isWebGLCubeRenderTarget, OneMinusSrcColorFactor = OneFactor.length > 1;
                if (OneMinusSrcColorFactor || (void 0 === ZeroFactor.__webglTexture && (ZeroFactor.__webglTexture = REVISION.createTexture()), ZeroFactor.__version = r.version, SubtractEquation.memory.textures++), SrcColorFactor) {
                    ReverseSubtractEquation.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (r.mipmaps && r.mipmaps.length > 0) {
                            ReverseSubtractEquation.__webglFramebuffer[t] = [];
                            for (let n = 0; n < r.mipmaps.length; n++)
                                ReverseSubtractEquation.__webglFramebuffer[t][n] = REVISION.createFramebuffer();
                        } else
                            ReverseSubtractEquation.__webglFramebuffer[t] = REVISION.createFramebuffer();
                } else {
                    if (r.mipmaps && r.mipmaps.length > 0) {
                        ReverseSubtractEquation.__webglFramebuffer = [];
                        for (let t = 0; t < r.mipmaps.length; t++)
                            ReverseSubtractEquation.__webglFramebuffer[t] = REVISION.createFramebuffer();
                    } else
                        ReverseSubtractEquation.__webglFramebuffer = REVISION.createFramebuffer();
                    if (OneMinusSrcColorFactor)
                        for (let t = 0, n = OneFactor.length; t < n; t++) {
                            const n = i.get(OneFactor[t]);
                            void 0 === n.__webglTexture && (n.__webglTexture = REVISION.createTexture(), SubtractEquation.memory.textures++);
                        }
                    if (t.samples > 0 && !1 === IntType(t)) {
                        ReverseSubtractEquation.__webglMultisampledFramebuffer = REVISION.createFramebuffer(), ReverseSubtractEquation.__webglColorRenderbuffer = [], n.bindFramebuffer(REVISION.FRAMEBUFFER, ReverseSubtractEquation.__webglMultisampledFramebuffer);
                        for (let n = 0; n < OneFactor.length; n++) {
                            const i = OneFactor[n];
                            ReverseSubtractEquation.__webglColorRenderbuffer[n] = REVISION.createRenderbuffer(), REVISION.bindRenderbuffer(REVISION.RENDERBUFFER, ReverseSubtractEquation.__webglColorRenderbuffer[n]);
                            const r = AddEquation.convert(i.format, i.colorSpace), SubtractEquation = AddEquation.convert(i.type), ZeroFactor = ConstantColorFactor(i.internalFormat, r, SubtractEquation, i.colorSpace, !0 === t.isXRRenderTarget), SrcColorFactor = ShortType(t);
                            REVISION.renderbufferStorageMultisample(REVISION.RENDERBUFFER, SrcColorFactor, ZeroFactor, t.width, t.height), REVISION.framebufferRenderbuffer(REVISION.FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0 + n, REVISION.RENDERBUFFER, ReverseSubtractEquation.__webglColorRenderbuffer[n]);
                        }
                        REVISION.bindRenderbuffer(REVISION.RENDERBUFFER, null), t.depthBuffer && (ReverseSubtractEquation.__webglDepthRenderbuffer = REVISION.createRenderbuffer(), EquirectangularReflectionMapping(ReverseSubtractEquation.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(REVISION.FRAMEBUFFER, null);
                    }
                }
                if (SrcColorFactor) {
                    n.bindTexture(REVISION.TEXTURE_CUBE_MAP, ZeroFactor.__webglTexture), NotEqualDepth(REVISION.TEXTURE_CUBE_MAP, r);
                    for (let n = 0; n < 6; n++)
                        if (r.mipmaps && r.mipmaps.length > 0)
                            for (let i = 0; i < r.mipmaps.length; i++)
                                CubeRefractionMapping(ReverseSubtractEquation.__webglFramebuffer[n][i], t, r, REVISION.COLOR_ATTACHMENT0, REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else
                            CubeRefractionMapping(ReverseSubtractEquation.__webglFramebuffer[n], t, r, REVISION.COLOR_ATTACHMENT0, REVISION.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    DstColorFactor(r) && OneMinusDstColorFactor(REVISION.TEXTURE_CUBE_MAP), n.unbindTexture();
                } else if (OneMinusSrcColorFactor) {
                    for (let r = 0, AddEquation = OneFactor.length; r < AddEquation; r++) {
                        const AddEquation = OneFactor[r], SubtractEquation = i.get(AddEquation);
                        n.bindTexture(REVISION.TEXTURE_2D, SubtractEquation.__webglTexture), NotEqualDepth(REVISION.TEXTURE_2D, AddEquation), CubeRefractionMapping(ReverseSubtractEquation.__webglFramebuffer, t, AddEquation, REVISION.COLOR_ATTACHMENT0 + r, REVISION.TEXTURE_2D, 0), DstColorFactor(AddEquation) && OneMinusDstColorFactor(REVISION.TEXTURE_2D);
                    }
                    n.unbindTexture();
                } else {
                    let i = REVISION.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? REVISION.TEXTURE_3D : REVISION.TEXTURE_2D_ARRAY), n.bindTexture(i, ZeroFactor.__webglTexture), NotEqualDepth(i, r), r.mipmaps && r.mipmaps.length > 0)
                        for (let n = 0; n < r.mipmaps.length; n++)
                            CubeRefractionMapping(ReverseSubtractEquation.__webglFramebuffer[n], t, r, REVISION.COLOR_ATTACHMENT0, i, n);
                    else
                        CubeRefractionMapping(ReverseSubtractEquation.__webglFramebuffer, t, r, REVISION.COLOR_ATTACHMENT0, i, 0);
                    DstColorFactor(r) && OneMinusDstColorFactor(i), n.unbindTexture();
                }
                t.depthBuffer && EquirectangularRefractionMapping(t);
            }, this.updateRenderTargetMipmap = function (REVISION) {
                const t = REVISION.textures;
                for (let r = 0, AddEquation = t.length; r < AddEquation; r++) {
                    const AddEquation = t[r];
                    if (DstColorFactor(AddEquation)) {
                        const t = SrcAlphaSaturateFactor(REVISION), r = i.get(AddEquation).__webglTexture;
                        n.bindTexture(t, r), OneMinusDstColorFactor(t), n.unbindTexture();
                    }
                }
            }, this.updateMultisampleRenderTarget = function (t) {
                if (t.samples > 0)
                    if (!1 === IntType(t)) {
                        const r = t.textures, AddEquation = t.width, SubtractEquation = t.height;
                        let ReverseSubtractEquation = REVISION.COLOR_BUFFER_BIT;
                        const OneFactor = t.stencilBuffer ? REVISION.DEPTH_STENCIL_ATTACHMENT : REVISION.DEPTH_ATTACHMENT, SrcColorFactor = i.get(t), OneMinusSrcColorFactor = r.length > 1;
                        if (OneMinusSrcColorFactor)
                            for (let t = 0; t < r.length; t++)
                                n.bindFramebuffer(REVISION.FRAMEBUFFER, SrcColorFactor.__webglMultisampledFramebuffer), REVISION.framebufferRenderbuffer(REVISION.FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0 + t, REVISION.RENDERBUFFER, null), n.bindFramebuffer(REVISION.FRAMEBUFFER, SrcColorFactor.__webglFramebuffer), REVISION.framebufferTexture2D(REVISION.DRAW_FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0 + t, REVISION.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(REVISION.READ_FRAMEBUFFER, SrcColorFactor.__webglMultisampledFramebuffer), n.bindFramebuffer(REVISION.DRAW_FRAMEBUFFER, SrcColorFactor.__webglFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            if (t.resolveDepthBuffer && (t.depthBuffer && (ReverseSubtractEquation |= REVISION.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (ReverseSubtractEquation |= REVISION.STENCIL_BUFFER_BIT)), OneMinusSrcColorFactor) {
                                REVISION.framebufferRenderbuffer(REVISION.READ_FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0, REVISION.RENDERBUFFER, SrcColorFactor.__webglColorRenderbuffer[n]);
                                const t = i.get(r[n]).__webglTexture;
                                REVISION.framebufferTexture2D(REVISION.DRAW_FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0, REVISION.TEXTURE_2D, t, 0);
                            }
                            REVISION.blitFramebuffer(0, 0, AddEquation, SubtractEquation, 0, 0, AddEquation, SubtractEquation, ReverseSubtractEquation, REVISION.NEAREST), !0 === ZeroFactor && (CubeUVReflectionMapping.length = 0, ByteType.length = 0, CubeUVReflectionMapping.push(REVISION.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && (CubeUVReflectionMapping.push(OneFactor), ByteType.push(OneFactor), REVISION.invalidateFramebuffer(REVISION.DRAW_FRAMEBUFFER, ByteType)), REVISION.invalidateFramebuffer(REVISION.READ_FRAMEBUFFER, CubeUVReflectionMapping));
                        }
                        if (n.bindFramebuffer(REVISION.READ_FRAMEBUFFER, null), n.bindFramebuffer(REVISION.DRAW_FRAMEBUFFER, null), OneMinusSrcColorFactor)
                            for (let t = 0; t < r.length; t++) {
                                n.bindFramebuffer(REVISION.FRAMEBUFFER, SrcColorFactor.__webglMultisampledFramebuffer), REVISION.framebufferRenderbuffer(REVISION.FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0 + t, REVISION.RENDERBUFFER, SrcColorFactor.__webglColorRenderbuffer[t]);
                                const AddEquation = i.get(r[t]).__webglTexture;
                                n.bindFramebuffer(REVISION.FRAMEBUFFER, SrcColorFactor.__webglFramebuffer), REVISION.framebufferTexture2D(REVISION.DRAW_FRAMEBUFFER, REVISION.COLOR_ATTACHMENT0 + t, REVISION.TEXTURE_2D, AddEquation, 0);
                            }
                        n.bindFramebuffer(REVISION.DRAW_FRAMEBUFFER, SrcColorFactor.__webglMultisampledFramebuffer);
                    } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && ZeroFactor) {
                        const n = t.stencilBuffer ? REVISION.DEPTH_STENCIL_ATTACHMENT : REVISION.DEPTH_ATTACHMENT;
                        REVISION.invalidateFramebuffer(REVISION.DRAW_FRAMEBUFFER, [n]);
                    }
            }, this.setupDepthRenderbuffer = EquirectangularRefractionMapping, this.setupFrameBufferTexture = CubeRefractionMapping, this.useMultisampledRTT = IntType;
        }
        function Vp(REVISION, t) {
            return {
                convert: function (n, i = '') {
                    let r;
                    const AddEquation = _tables.getTransfer(i);
                    if (n === UnsignedByteType)
                        return REVISION.UNSIGNED_BYTE;
                    if (n === UnsignedShort4444Type)
                        return REVISION.UNSIGNED_SHORT_4_4_4_4;
                    if (n === UnsignedShort5551Type)
                        return REVISION.UNSIGNED_SHORT_5_5_5_1;
                    if (n === UnsignedInt5999Type)
                        return REVISION.UNSIGNED_INT_5_9_9_9_REV;
                    if (n === ByteType)
                        return REVISION.BYTE;
                    if (n === ShortType)
                        return REVISION.SHORT;
                    if (n === UnsignedShortType)
                        return REVISION.UNSIGNED_SHORT;
                    if (n === IntType)
                        return REVISION.INT;
                    if (n === UnsignedIntType)
                        return REVISION.UNSIGNED_INT;
                    if (n === FloatType)
                        return REVISION.FLOAT;
                    if (n === HalfFloatType)
                        return REVISION.HALF_FLOAT;
                    if (1021 === n)
                        return REVISION.ALPHA;
                    if (1022 === n)
                        return REVISION.RGB;
                    if (n === RGBAFormat)
                        return REVISION.RGBA;
                    if (1024 === n)
                        return REVISION.LUMINANCE;
                    if (1025 === n)
                        return REVISION.LUMINANCE_ALPHA;
                    if (n === DepthFormat)
                        return REVISION.DEPTH_COMPONENT;
                    if (n === DepthStencilFormat)
                        return REVISION.DEPTH_STENCIL;
                    if (n === RedFormat)
                        return REVISION.RED;
                    if (n === RedIntegerFormat)
                        return REVISION.RED_INTEGER;
                    if (1030 === n)
                        return REVISION.RG;
                    if (n === RGIntegerFormat)
                        return REVISION.RG_INTEGER;
                    if (n === RGBAIntegerFormat)
                        return REVISION.RGBA_INTEGER;
                    if (n === RGB_S3TC_DXT1_Format || n === RGBA_S3TC_DXT1_Format || n === RGBA_S3TC_DXT3_Format || n === RGBA_S3TC_DXT5_Format)
                        if (AddEquation === SRGBTransfer) {
                            if (r = t.get('WEBGL_compressed_texture_s3tc_srgb'), null === r)
                                return null;
                            if (n === RGB_S3TC_DXT1_Format)
                                return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === RGBA_S3TC_DXT1_Format)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === RGBA_S3TC_DXT3_Format)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === RGBA_S3TC_DXT5_Format)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                        } else {
                            if (r = t.get('WEBGL_compressed_texture_s3tc'), null === r)
                                return null;
                            if (n === RGB_S3TC_DXT1_Format)
                                return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === RGBA_S3TC_DXT1_Format)
                                return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === RGBA_S3TC_DXT3_Format)
                                return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === RGBA_S3TC_DXT5_Format)
                                return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        }
                    if (n === RGB_PVRTC_4BPPV1_Format || n === RGB_PVRTC_2BPPV1_Format || n === RGBA_PVRTC_4BPPV1_Format || n === RGBA_PVRTC_2BPPV1_Format) {
                        if (r = t.get('WEBGL_compressed_texture_pvrtc'), null === r)
                            return null;
                        if (n === RGB_PVRTC_4BPPV1_Format)
                            return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (n === RGB_PVRTC_2BPPV1_Format)
                            return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === RGBA_PVRTC_4BPPV1_Format)
                            return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (n === RGBA_PVRTC_2BPPV1_Format)
                            return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    }
                    if (n === RGB_ETC1_Format || n === RGB_ETC2_Format || n === RGBA_ETC2_EAC_Format) {
                        if (r = t.get('WEBGL_compressed_texture_etc'), null === r)
                            return null;
                        if (n === RGB_ETC1_Format || n === RGB_ETC2_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                        if (n === RGBA_ETC2_EAC_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
                    }
                    if (n === RGBA_ASTC_4x4_Format || n === RGBA_ASTC_5x4_Format || n === RGBA_ASTC_5x5_Format || n === RGBA_ASTC_6x5_Format || n === RGBA_ASTC_6x6_Format || n === RGBA_ASTC_8x5_Format || n === RGBA_ASTC_8x6_Format || n === RGBA_ASTC_8x8_Format || n === RGBA_ASTC_10x5_Format || n === RGBA_ASTC_10x6_Format || n === RGBA_ASTC_10x8_Format || n === RGBA_ASTC_10x10_Format || n === RGBA_ASTC_12x10_Format || n === RGBA_ASTC_12x12_Format) {
                        if (r = t.get('WEBGL_compressed_texture_astc'), null === r)
                            return null;
                        if (n === RGBA_ASTC_4x4_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (n === RGBA_ASTC_5x4_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (n === RGBA_ASTC_5x5_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (n === RGBA_ASTC_6x5_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === RGBA_ASTC_6x6_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (n === RGBA_ASTC_8x5_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (n === RGBA_ASTC_8x6_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (n === RGBA_ASTC_8x8_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (n === RGBA_ASTC_10x5_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (n === RGBA_ASTC_10x6_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (n === RGBA_ASTC_10x8_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (n === RGBA_ASTC_10x10_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (n === RGBA_ASTC_12x10_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (n === RGBA_ASTC_12x12_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    }
                    if (n === RGBA_BPTC_Format || n === RGB_BPTC_SIGNED_Format || n === RGB_BPTC_UNSIGNED_Format) {
                        if (r = t.get('EXT_texture_compression_bptc'), null === r)
                            return null;
                        if (n === RGBA_BPTC_Format)
                            return AddEquation === SRGBTransfer ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (n === RGB_BPTC_SIGNED_Format)
                            return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (n === RGB_BPTC_UNSIGNED_Format)
                            return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
                    }
                    if (36283 === n || n === SIGNED_RED_RGTC1_Format || n === RED_GREEN_RGTC2_Format || n === SIGNED_RED_GREEN_RGTC2_Format) {
                        if (r = t.get('EXT_texture_compression_rgtc'), null === r)
                            return null;
                        if (n === RGBA_BPTC_Format)
                            return r.COMPRESSED_RED_RGTC1_EXT;
                        if (n === SIGNED_RED_RGTC1_Format)
                            return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (n === RED_GREEN_RGTC2_Format)
                            return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (n === SIGNED_RED_GREEN_RGTC2_Format)
                            return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
                    }
                    return n === UnsignedInt248Type ? REVISION.UNSIGNED_INT_24_8 : void 0 !== REVISION[n] ? REVISION[n] : null;
                }
            };
        }
        class Gp {
            constructor() {
                this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
            }
            init(REVISION, t, n) {
                if (null === this.texture) {
                    const i = new Texture();
                    REVISION.properties.get(i).__webglTexture = t.texture, t.depthNear === n.depthNear && t.depthFar === n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
                }
            }
            getMesh(REVISION) {
                if (null !== this.texture && null === this.mesh) {
                    const t = REVISION.cameras[0].viewport, n = new rr({
                            vertexShader: '\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}',
                            fragmentShader: '\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}',
                            uniforms: {
                                depthColor: { value: this.texture },
                                depthWidth: { value: t.z },
                                depthHeight: { value: t.w }
                            }
                        });
                    this.mesh = new Mesh(new TorusKnotGeometry(20, 20), n);
                }
                return this.mesh;
            }
            reset() {
                this.texture = null, this.mesh = null;
            }
            getDepthTexture() {
                return this.texture;
            }
        }
        class Qp extends EventDispatcher {
            constructor(REVISION, t) {
                super();
                const n = this;
                let i = null, r = 1, AddEquation = null, SubtractEquation = 'local-floor', ReverseSubtractEquation = 1, ZeroFactor = null, OneFactor = null, SrcColorFactor = null, OneMinusSrcColorFactor = null, SrcAlphaFactor = null, OneMinusSrcAlphaFactor = null;
                const DstAlphaFactor = new Gp(), OneMinusDstAlphaFactor = t.getContextAttributes();
                let DstColorFactor = null, OneMinusDstColorFactor = null;
                const SrcAlphaSaturateFactor = [], ConstantColorFactor = [], OneMinusConstantColorFactor = new Vector2();
                let ConstantAlphaFactor = null;
                const OneMinusConstantAlphaFactor = new PerspectiveCamera();
                OneMinusConstantAlphaFactor.viewport = new Vector4();
                const b = new PerspectiveCamera();
                b.viewport = new Vector4();
                const aspect = [
                        OneMinusConstantAlphaFactor,
                        b
                    ], CullFaceFront = new _s();
                let LessEqualDepth = null, MultiplyBlending = null;
                function CustomBlending(REVISION) {
                    const t = ConstantColorFactor.indexOf(REVISION.inputSource);
                    if (-1 === t)
                        return;
                    const n = SrcAlphaSaturateFactor[t];
                    void 0 !== n && (n.update(REVISION.inputSource, REVISION.frame, ZeroFactor || AddEquation), n.dispatchEvent({
                        type: REVISION.type,
                        data: REVISION.inputSource
                    }));
                }
                function GreaterDepth() {
                    i.removeEventListener('select', CustomBlending), i.removeEventListener('selectstart', CustomBlending), i.removeEventListener('selectend', CustomBlending), i.removeEventListener('squeeze', CustomBlending), i.removeEventListener('squeezestart', CustomBlending), i.removeEventListener('squeezeend', CustomBlending), i.removeEventListener('end', GreaterDepth), i.removeEventListener('inputsourceschange', NotEqualDepth);
                    for (let REVISION = 0; REVISION < SrcAlphaSaturateFactor.length; REVISION++) {
                        const t = ConstantColorFactor[REVISION];
                        null !== t && (ConstantColorFactor[REVISION] = null, SrcAlphaSaturateFactor[REVISION].disconnect(t));
                    }
                    LessEqualDepth = null, MultiplyBlending = null, DstAlphaFactor.reset(), REVISION.setRenderTarget(DstColorFactor), SrcAlphaFactor = null, OneMinusSrcColorFactor = null, SrcColorFactor = null, i = null, OneMinusDstColorFactor = null, EquirectangularRefractionMapping.stop(), n.isPresenting = !1, REVISION.setPixelRatio(ConstantAlphaFactor), REVISION.setSize(OneMinusConstantColorFactor.width, OneMinusConstantColorFactor.height, !1), n.dispatchEvent({ type: 'sessionend' });
                }
                function NotEqualDepth(REVISION) {
                    for (let t = 0; t < REVISION.removed.length; t++) {
                        const n = REVISION.removed[t], i = ConstantColorFactor.indexOf(n);
                        i >= 0 && (ConstantColorFactor[i] = null, SrcAlphaSaturateFactor[i].disconnect(n));
                    }
                    for (let t = 0; t < REVISION.added.length; t++) {
                        const n = REVISION.added[t];
                        let i = ConstantColorFactor.indexOf(n);
                        if (-1 === i) {
                            for (let REVISION = 0; REVISION < SrcAlphaSaturateFactor.length; REVISION++) {
                                if (REVISION >= ConstantColorFactor.length) {
                                    ConstantColorFactor.push(n), i = REVISION;
                                    break;
                                }
                                if (null === ConstantColorFactor[REVISION]) {
                                    ConstantColorFactor[REVISION] = n, i = REVISION;
                                    break;
                                }
                            }
                            if (-1 === i)
                                break;
                        }
                        const r = SrcAlphaSaturateFactor[i];
                        r && r.connect(n);
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (REVISION) {
                    let t = SrcAlphaSaturateFactor[REVISION];
                    return void 0 === t && (t = new WebXRController(), SrcAlphaSaturateFactor[REVISION] = t), t.getTargetRaySpace();
                }, this.getControllerGrip = function (REVISION) {
                    let t = SrcAlphaSaturateFactor[REVISION];
                    return void 0 === t && (t = new WebXRController(), SrcAlphaSaturateFactor[REVISION] = t), t.getGripSpace();
                }, this.getHand = function (REVISION) {
                    let t = SrcAlphaSaturateFactor[REVISION];
                    return void 0 === t && (t = new WebXRController(), SrcAlphaSaturateFactor[REVISION] = t), t.getHandSpace();
                }, this.setFramebufferScaleFactor = function (REVISION) {
                    r = REVISION, !0 === n.isPresenting && console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
                }, this.setReferenceSpaceType = function (REVISION) {
                    SubtractEquation = REVISION, !0 === n.isPresenting && console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
                }, this.getReferenceSpace = function () {
                    return ZeroFactor || AddEquation;
                }, this.setReferenceSpace = function (REVISION) {
                    ZeroFactor = REVISION;
                }, this.getBaseLayer = function () {
                    return null !== OneMinusSrcColorFactor ? OneMinusSrcColorFactor : SrcAlphaFactor;
                }, this.getBinding = function () {
                    return SrcColorFactor;
                }, this.getFrame = function () {
                    return OneMinusSrcAlphaFactor;
                }, this.getSession = function () {
                    return i;
                }, this.setSession = async function (OneFactor) {
                    if (i = OneFactor, null !== i) {
                        DstColorFactor = REVISION.getRenderTarget(), i.addEventListener('select', CustomBlending), i.addEventListener('selectstart', CustomBlending), i.addEventListener('selectend', CustomBlending), i.addEventListener('squeeze', CustomBlending), i.addEventListener('squeezestart', CustomBlending), i.addEventListener('squeezeend', CustomBlending), i.addEventListener('end', GreaterDepth), i.addEventListener('inputsourceschange', NotEqualDepth), !0 !== OneMinusDstAlphaFactor.xrCompatible && await t.makeXRCompatible(), ConstantAlphaFactor = REVISION.getPixelRatio(), REVISION.getSize(OneMinusConstantColorFactor);
                        if ('undefined' != typeof XRWebGLBinding && 'createProjectionLayer' in XRWebGLBinding.prototype) {
                            let n = null, AddEquation = null, SubtractEquation = null;
                            OneMinusDstAlphaFactor.depth && (SubtractEquation = OneMinusDstAlphaFactor.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = OneMinusDstAlphaFactor.stencil ? DepthStencilFormat : DepthFormat, AddEquation = OneMinusDstAlphaFactor.stencil ? UnsignedInt248Type : UnsignedIntType);
                            const ReverseSubtractEquation = {
                                colorFormat: t.RGBA8,
                                depthFormat: SubtractEquation,
                                scaleFactor: r
                            };
                            SrcColorFactor = new XRWebGLBinding(i, t), OneMinusSrcColorFactor = SrcColorFactor.createProjectionLayer(ReverseSubtractEquation), i.updateRenderState({ layers: [OneMinusSrcColorFactor] }), REVISION.setPixelRatio(1), REVISION.setSize(OneMinusSrcColorFactor.textureWidth, OneMinusSrcColorFactor.textureHeight, !1), OneMinusDstColorFactor = new jt(OneMinusSrcColorFactor.textureWidth, OneMinusSrcColorFactor.textureHeight, {
                                format: RGBAFormat,
                                type: UnsignedByteType,
                                depthTexture: new InstancedBufferGeometry(OneMinusSrcColorFactor.textureWidth, OneMinusSrcColorFactor.textureHeight, AddEquation, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: OneMinusDstAlphaFactor.stencil,
                                colorSpace: REVISION.outputColorSpace,
                                samples: OneMinusDstAlphaFactor.antialias ? 4 : 0,
                                resolveDepthBuffer: !1 === OneMinusSrcColorFactor.ignoreDepthValues,
                                resolveStencilBuffer: !1 === OneMinusSrcColorFactor.ignoreDepthValues
                            });
                        } else {
                            const n = {
                                antialias: OneMinusDstAlphaFactor.antialias,
                                alpha: !0,
                                depth: OneMinusDstAlphaFactor.depth,
                                stencil: OneMinusDstAlphaFactor.stencil,
                                framebufferScaleFactor: r
                            };
                            SrcAlphaFactor = new XRWebGLLayer(i, t, n), i.updateRenderState({ baseLayer: SrcAlphaFactor }), REVISION.setPixelRatio(1), REVISION.setSize(SrcAlphaFactor.framebufferWidth, SrcAlphaFactor.framebufferHeight, !1), OneMinusDstColorFactor = new jt(SrcAlphaFactor.framebufferWidth, SrcAlphaFactor.framebufferHeight, {
                                format: RGBAFormat,
                                type: UnsignedByteType,
                                colorSpace: REVISION.outputColorSpace,
                                stencilBuffer: OneMinusDstAlphaFactor.stencil,
                                resolveDepthBuffer: !1 === SrcAlphaFactor.ignoreDepthValues,
                                resolveStencilBuffer: !1 === SrcAlphaFactor.ignoreDepthValues
                            });
                        }
                        OneMinusDstColorFactor.isXRRenderTarget = !0, this.setFoveation(ReverseSubtractEquation), ZeroFactor = null, AddEquation = await i.requestReferenceSpace(SubtractEquation), EquirectangularRefractionMapping.setContext(i), EquirectangularRefractionMapping.start(), n.isPresenting = !0, n.dispatchEvent({ type: 'sessionstart' });
                    }
                }, this.getEnvironmentBlendMode = function () {
                    if (null !== i)
                        return i.environmentBlendMode;
                }, this.getDepthTexture = function () {
                    return DstAlphaFactor.getDepthTexture();
                };
                const AttachedBindMode = new Vector3(), CubeReflectionMapping = new Vector3();
                function CubeRefractionMapping(REVISION, t) {
                    null === t ? REVISION.matrixWorld.copy(REVISION.matrix) : REVISION.matrixWorld.multiplyMatrices(t.matrixWorld, REVISION.matrix), REVISION.matrixWorldInverse.copy(REVISION.matrixWorld).invert();
                }
                this.updateCamera = function (REVISION) {
                    if (null === i)
                        return;
                    let t = REVISION.near, n = REVISION.far;
                    null !== DstAlphaFactor.texture && (DstAlphaFactor.depthNear > 0 && (t = DstAlphaFactor.depthNear), DstAlphaFactor.depthFar > 0 && (n = DstAlphaFactor.depthFar)), CullFaceFront.near = b.near = OneMinusConstantAlphaFactor.near = t, CullFaceFront.far = b.far = OneMinusConstantAlphaFactor.far = n, LessEqualDepth === CullFaceFront.near && MultiplyBlending === CullFaceFront.far || (i.updateRenderState({
                        depthNear: CullFaceFront.near,
                        depthFar: CullFaceFront.far
                    }), LessEqualDepth = CullFaceFront.near, MultiplyBlending = CullFaceFront.far), OneMinusConstantAlphaFactor.layers.mask = 2 | REVISION.layers.mask, b.layers.mask = 4 | REVISION.layers.mask, CullFaceFront.layers.mask = OneMinusConstantAlphaFactor.layers.mask | b.layers.mask;
                    const r = REVISION.parent, AddEquation = CullFaceFront.cameras;
                    CubeRefractionMapping(CullFaceFront, r);
                    for (let REVISION = 0; REVISION < AddEquation.length; REVISION++)
                        CubeRefractionMapping(AddEquation[REVISION], r);
                    2 === AddEquation.length ? function (REVISION, t, n) {
                        AttachedBindMode.setFromMatrixPosition(t.matrixWorld), CubeReflectionMapping.setFromMatrixPosition(n.matrixWorld);
                        const i = AttachedBindMode.distanceTo(CubeReflectionMapping), r = t.projectionMatrix.elements, AddEquation = n.projectionMatrix.elements, SubtractEquation = r[14] / (r[10] - 1), ReverseSubtractEquation = r[14] / (r[10] + 1), ZeroFactor = (r[9] + 1) / r[5], OneFactor = (r[9] - 1) / r[5], SrcColorFactor = (r[8] - 1) / r[0], OneMinusSrcColorFactor = (AddEquation[8] + 1) / AddEquation[0], SrcAlphaFactor = SubtractEquation * SrcColorFactor, OneMinusSrcAlphaFactor = SubtractEquation * OneMinusSrcColorFactor, DstAlphaFactor = i / (-SrcColorFactor + OneMinusSrcColorFactor), OneMinusDstAlphaFactor = DstAlphaFactor * -SrcColorFactor;
                        if (t.matrixWorld.decompose(REVISION.position, REVISION.quaternion, REVISION.scale), REVISION.translateX(OneMinusDstAlphaFactor), REVISION.translateZ(DstAlphaFactor), REVISION.matrixWorld.compose(REVISION.position, REVISION.quaternion, REVISION.scale), REVISION.matrixWorldInverse.copy(REVISION.matrixWorld).invert(), -1 === r[10])
                            REVISION.projectionMatrix.copy(t.projectionMatrix), REVISION.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                        else {
                            const t = SubtractEquation + DstAlphaFactor, n = ReverseSubtractEquation + DstAlphaFactor, r = SrcAlphaFactor - OneMinusDstAlphaFactor, AddEquation = OneMinusSrcAlphaFactor + (i - OneMinusDstAlphaFactor), SrcColorFactor = ZeroFactor * ReverseSubtractEquation / n * t, OneMinusSrcColorFactor = OneFactor * ReverseSubtractEquation / n * t;
                            REVISION.projectionMatrix.makePerspective(r, AddEquation, SrcColorFactor, OneMinusSrcColorFactor, t, n), REVISION.projectionMatrixInverse.copy(REVISION.projectionMatrix).invert();
                        }
                    }(CullFaceFront, OneMinusConstantAlphaFactor, b) : CullFaceFront.projectionMatrix.copy(OneMinusConstantAlphaFactor.projectionMatrix), function (REVISION, t, n) {
                        null === n ? REVISION.matrix.copy(t.matrixWorld) : (REVISION.matrix.copy(n.matrixWorld), REVISION.matrix.invert(), REVISION.matrix.multiply(t.matrixWorld));
                        REVISION.matrix.decompose(REVISION.position, REVISION.quaternion, REVISION.scale), REVISION.updateMatrixWorld(!0), REVISION.projectionMatrix.copy(t.projectionMatrix), REVISION.projectionMatrixInverse.copy(t.projectionMatrixInverse), REVISION.isPerspectiveCamera && (REVISION.fov = 2 * RAD2DEG * Math.atan(1 / REVISION.projectionMatrix.elements[5]), REVISION.zoom = 1);
                    }(REVISION, CullFaceFront, r);
                }, this.getCamera = function () {
                    return CullFaceFront;
                }, this.getFoveation = function () {
                    if (null !== OneMinusSrcColorFactor || null !== SrcAlphaFactor)
                        return ReverseSubtractEquation;
                }, this.setFoveation = function (REVISION) {
                    ReverseSubtractEquation = REVISION, null !== OneMinusSrcColorFactor && (OneMinusSrcColorFactor.fixedFoveation = REVISION), null !== SrcAlphaFactor && void 0 !== SrcAlphaFactor.fixedFoveation && (SrcAlphaFactor.fixedFoveation = REVISION);
                }, this.hasDepthSensing = function () {
                    return null !== DstAlphaFactor.texture;
                }, this.getDepthSensingMesh = function () {
                    return DstAlphaFactor.getMesh(CullFaceFront);
                };
                let EquirectangularReflectionMapping = null;
                const EquirectangularRefractionMapping = new fu();
                EquirectangularRefractionMapping.setAnimationLoop(function (t, r) {
                    if (OneFactor = r.getViewerPose(ZeroFactor || AddEquation), OneMinusSrcAlphaFactor = r, null !== OneFactor) {
                        const t = OneFactor.views;
                        null !== SrcAlphaFactor && (REVISION.setRenderTargetFramebuffer(OneMinusDstColorFactor, SrcAlphaFactor.framebuffer), REVISION.setRenderTarget(OneMinusDstColorFactor));
                        let n = !1;
                        t.length !== CullFaceFront.cameras.length && (CullFaceFront.cameras.length = 0, n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            let AddEquation = null;
                            if (null !== SrcAlphaFactor)
                                AddEquation = SrcAlphaFactor.getViewport(r);
                            else {
                                const t = SrcColorFactor.getViewSubImage(OneMinusSrcColorFactor, r);
                                AddEquation = t.viewport, 0 === i && (REVISION.setRenderTargetTextures(OneMinusDstColorFactor, t.colorTexture, OneMinusSrcColorFactor.ignoreDepthValues ? void 0 : t.depthStencilTexture), REVISION.setRenderTarget(OneMinusDstColorFactor));
                            }
                            let SubtractEquation = aspect[i];
                            void 0 === SubtractEquation && (SubtractEquation = new PerspectiveCamera(), SubtractEquation.layers.enable(i), SubtractEquation.viewport = new Vector4(), aspect[i] = SubtractEquation), SubtractEquation.matrix.fromArray(r.transform.matrix), SubtractEquation.matrix.decompose(SubtractEquation.position, SubtractEquation.quaternion, SubtractEquation.scale), SubtractEquation.projectionMatrix.fromArray(r.projectionMatrix), SubtractEquation.projectionMatrixInverse.copy(SubtractEquation.projectionMatrix).invert(), SubtractEquation.viewport.set(AddEquation.x, AddEquation.y, AddEquation.width, AddEquation.height), 0 === i && (CullFaceFront.matrix.copy(SubtractEquation.matrix), CullFaceFront.matrix.decompose(CullFaceFront.position, CullFaceFront.quaternion, CullFaceFront.scale)), !0 === n && CullFaceFront.cameras.push(SubtractEquation);
                        }
                        const r = i.enabledFeatures;
                        if (r && r.includes('depth-sensing') && 'gpu-optimized' == i.depthUsage && SrcColorFactor) {
                            const n = SrcColorFactor.getDepthInformation(t[0]);
                            n && n.isValid && n.texture && DstAlphaFactor.init(REVISION, n, i.renderState);
                        }
                    }
                    for (let REVISION = 0; REVISION < SrcAlphaSaturateFactor.length; REVISION++) {
                        const t = ConstantColorFactor[REVISION], n = SrcAlphaSaturateFactor[REVISION];
                        null !== t && void 0 !== n && n.update(t, r, ZeroFactor || AddEquation);
                    }
                    EquirectangularReflectionMapping && EquirectangularReflectionMapping(t, r), r.detectedPlanes && n.dispatchEvent({
                        type: 'planesdetected',
                        data: r
                    }), OneMinusSrcAlphaFactor = null;
                }), this.setAnimationLoop = function (REVISION) {
                    EquirectangularReflectionMapping = REVISION;
                }, this.dispose = function () {
                };
            }
        }
        const Xp = new Euler(), jp = new Matrix4();
        function qp(REVISION, t) {
            function n(REVISION, t) {
                !0 === REVISION.matrixAutoUpdate && REVISION.updateMatrix(), t.value.copy(REVISION.matrix);
            }
            function i(REVISION, i) {
                REVISION.opacity.value = i.opacity, i.color && REVISION.diffuse.value.copy(i.color), i.emissive && REVISION.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (REVISION.map.value = i.map, n(i.map, REVISION.mapTransform)), i.alphaMap && (REVISION.alphaMap.value = i.alphaMap, n(i.alphaMap, REVISION.alphaMapTransform)), i.bumpMap && (REVISION.bumpMap.value = i.bumpMap, n(i.bumpMap, REVISION.bumpMapTransform), REVISION.bumpScale.value = i.bumpScale, 1 === i.side && (REVISION.bumpScale.value *= -1)), i.normalMap && (REVISION.normalMap.value = i.normalMap, n(i.normalMap, REVISION.normalMapTransform), REVISION.normalScale.value.copy(i.normalScale), 1 === i.side && REVISION.normalScale.value.negate()), i.displacementMap && (REVISION.displacementMap.value = i.displacementMap, n(i.displacementMap, REVISION.displacementMapTransform), REVISION.displacementScale.value = i.displacementScale, REVISION.displacementBias.value = i.displacementBias), i.emissiveMap && (REVISION.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, REVISION.emissiveMapTransform)), i.specularMap && (REVISION.specularMap.value = i.specularMap, n(i.specularMap, REVISION.specularMapTransform)), i.alphaTest > 0 && (REVISION.alphaTest.value = i.alphaTest);
                const r = t.get(i), AddEquation = r.envMap, SubtractEquation = r.envMapRotation;
                AddEquation && (REVISION.envMap.value = AddEquation, Xp.copy(SubtractEquation), Xp.x *= -1, Xp.y *= -1, Xp.z *= -1, AddEquation.isCubeTexture && !1 === AddEquation.isRenderTargetTexture && (Xp.y *= -1, Xp.z *= -1), REVISION.envMapRotation.value.setFromMatrix4(jp.makeRotationFromEuler(Xp)), REVISION.flipEnvMap.value = AddEquation.isCubeTexture && !1 === AddEquation.isRenderTargetTexture ? -1 : 1, REVISION.reflectivity.value = i.reflectivity, REVISION.ior.value = i.ior, REVISION.refractionRatio.value = i.refractionRatio), i.lightMap && (REVISION.lightMap.value = i.lightMap, REVISION.lightMapIntensity.value = i.lightMapIntensity, n(i.lightMap, REVISION.lightMapTransform)), i.aoMap && (REVISION.aoMap.value = i.aoMap, REVISION.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, REVISION.aoMapTransform));
            }
            return {
                refreshFogUniforms: function (t, n) {
                    n.color.getRGB(t.fogColor.value, nr(REVISION)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density);
                },
                refreshMaterialUniforms: function (REVISION, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(REVISION, r) : r.isMeshToonMaterial ? (i(REVISION, r), function (REVISION, t) {
                        t.gradientMap && (REVISION.gradientMap.value = t.gradientMap);
                    }(REVISION, r)) : r.isMeshPhongMaterial ? (i(REVISION, r), function (REVISION, t) {
                        REVISION.specular.value.copy(t.specular), REVISION.shininess.value = Math.max(t.shininess, 0.0001);
                    }(REVISION, r)) : r.isMeshStandardMaterial ? (i(REVISION, r), function (REVISION, t) {
                        REVISION.metalness.value = t.metalness, t.metalnessMap && (REVISION.metalnessMap.value = t.metalnessMap, n(t.metalnessMap, REVISION.metalnessMapTransform));
                        REVISION.roughness.value = t.roughness, t.roughnessMap && (REVISION.roughnessMap.value = t.roughnessMap, n(t.roughnessMap, REVISION.roughnessMapTransform));
                        t.envMap && (REVISION.envMapIntensity.value = t.envMapIntensity);
                    }(REVISION, r), r.isMeshPhysicalMaterial && function (REVISION, t, i) {
                        REVISION.ior.value = t.ior, t.sheen > 0 && (REVISION.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), REVISION.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (REVISION.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, REVISION.sheenColorMapTransform)), t.sheenRoughnessMap && (REVISION.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, REVISION.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (REVISION.clearcoat.value = t.clearcoat, REVISION.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (REVISION.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, REVISION.clearcoatMapTransform)), t.clearcoatRoughnessMap && (REVISION.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, REVISION.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (REVISION.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, REVISION.clearcoatNormalMapTransform), REVISION.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), 1 === t.side && REVISION.clearcoatNormalScale.value.negate()));
                        t.dispersion > 0 && (REVISION.dispersion.value = t.dispersion);
                        t.iridescence > 0 && (REVISION.iridescence.value = t.iridescence, REVISION.iridescenceIOR.value = t.iridescenceIOR, REVISION.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], REVISION.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (REVISION.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, REVISION.iridescenceMapTransform)), t.iridescenceThicknessMap && (REVISION.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, REVISION.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (REVISION.transmission.value = t.transmission, REVISION.transmissionSamplerMap.value = i.texture, REVISION.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (REVISION.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, REVISION.transmissionMapTransform)), REVISION.thickness.value = t.thickness, t.thicknessMap && (REVISION.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, REVISION.thicknessMapTransform)), REVISION.attenuationDistance.value = t.attenuationDistance, REVISION.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (REVISION.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (REVISION.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, REVISION.anisotropyMapTransform)));
                        REVISION.specularIntensity.value = t.specularIntensity, REVISION.specularColor.value.copy(t.specularColor), t.specularColorMap && (REVISION.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, REVISION.specularColorMapTransform));
                        t.specularIntensityMap && (REVISION.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, REVISION.specularIntensityMapTransform));
                    }(REVISION, r, ReverseSubtractEquation)) : r.isMeshMatcapMaterial ? (i(REVISION, r), function (REVISION, t) {
                        t.matcap && (REVISION.matcap.value = t.matcap);
                    }(REVISION, r)) : r.isMeshDepthMaterial ? i(REVISION, r) : r.isMeshDistanceMaterial ? (i(REVISION, r), function (REVISION, n) {
                        const i = t.get(n).light;
                        REVISION.referencePosition.value.setFromMatrixPosition(i.matrixWorld), REVISION.nearDistance.value = i.shadow.camera.near, REVISION.farDistance.value = i.shadow.camera.far;
                    }(REVISION, r)) : r.isMeshNormalMaterial ? i(REVISION, r) : r.isLineBasicMaterial ? (function (REVISION, t) {
                        REVISION.diffuse.value.copy(t.color), REVISION.opacity.value = t.opacity, t.map && (REVISION.map.value = t.map, n(t.map, REVISION.mapTransform));
                    }(REVISION, r), r.isLineDashedMaterial && function (REVISION, t) {
                        REVISION.dashSize.value = t.dashSize, REVISION.totalSize.value = t.dashSize + t.gapSize, REVISION.scale.value = t.scale;
                    }(REVISION, r)) : r.isPointsMaterial ? function (REVISION, t, i, r) {
                        REVISION.diffuse.value.copy(t.color), REVISION.opacity.value = t.opacity, REVISION.size.value = t.size * i, REVISION.scale.value = 0.5 * r, t.map && (REVISION.map.value = t.map, n(t.map, REVISION.uvTransform));
                        t.alphaMap && (REVISION.alphaMap.value = t.alphaMap, n(t.alphaMap, REVISION.alphaMapTransform));
                        t.alphaTest > 0 && (REVISION.alphaTest.value = t.alphaTest);
                    }(REVISION, r, AddEquation, SubtractEquation) : r.isSpriteMaterial ? function (REVISION, t) {
                        REVISION.diffuse.value.copy(t.color), REVISION.opacity.value = t.opacity, REVISION.rotation.value = t.rotation, t.map && (REVISION.map.value = t.map, n(t.map, REVISION.mapTransform));
                        t.alphaMap && (REVISION.alphaMap.value = t.alphaMap, n(t.alphaMap, REVISION.alphaMapTransform));
                        t.alphaTest > 0 && (REVISION.alphaTest.value = t.alphaTest);
                    }(REVISION, r) : r.isShadowMaterial ? (REVISION.color.value.copy(r.color), REVISION.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
                }
            };
        }
        function Yp(REVISION, t, n, i) {
            let r = {}, AddEquation = {}, SubtractEquation = [];
            const ReverseSubtractEquation = REVISION.getParameter(REVISION.MAX_UNIFORM_BUFFER_BINDINGS);
            function ZeroFactor(REVISION, t, n, i) {
                const r = REVISION.value, AddEquation = t + '_' + n;
                if (void 0 === i[AddEquation])
                    return i[AddEquation] = 'number' == typeof r || 'boolean' == typeof r ? r : r.clone(), !0;
                {
                    const REVISION = i[AddEquation];
                    if ('number' == typeof r || 'boolean' == typeof r) {
                        if (REVISION !== r)
                            return i[AddEquation] = r, !0;
                    } else if (!1 === REVISION.equals(r))
                        return REVISION.copy(r), !0;
                }
                return !1;
            }
            function OneFactor(REVISION) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return 'number' == typeof REVISION || 'boolean' == typeof REVISION ? (t.boundary = 4, t.storage = 4) : REVISION.isVector2 ? (t.boundary = 8, t.storage = 8) : REVISION.isVector3 || REVISION.isColor ? (t.boundary = 16, t.storage = 12) : REVISION.isVector4 ? (t.boundary = 16, t.storage = 16) : REVISION.isMatrix3 ? (t.boundary = 48, t.storage = 48) : REVISION.isMatrix4 ? (t.boundary = 64, t.storage = 64) : REVISION.isTexture ? console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.') : console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', REVISION), t;
            }
            function SrcColorFactor(t) {
                const n = t.target;
                n.removeEventListener('dispose', SrcColorFactor);
                const i = SubtractEquation.indexOf(n.__bindingPointIndex);
                SubtractEquation.splice(i, 1), REVISION.deleteBuffer(r[n.id]), delete r[n.id], delete AddEquation[n.id];
            }
            return {
                bind: function (REVISION, t) {
                    const n = t.program;
                    i.uniformBlockBinding(REVISION, n);
                },
                update: function (n, OneMinusSrcColorFactor) {
                    let SrcAlphaFactor = r[n.id];
                    void 0 === SrcAlphaFactor && (!function (REVISION) {
                        const t = REVISION.uniforms;
                        let n = 0;
                        const i = 16;
                        for (let REVISION = 0, r = t.length; REVISION < r; REVISION++) {
                            const r = Array.isArray(t[REVISION]) ? t[REVISION] : [t[REVISION]];
                            for (let REVISION = 0, t = r.length; REVISION < t; REVISION++) {
                                const t = r[REVISION], AddEquation = Array.isArray(t.value) ? t.value : [t.value];
                                for (let REVISION = 0, r = AddEquation.length; REVISION < r; REVISION++) {
                                    const r = OneFactor(AddEquation[REVISION]), SubtractEquation = n % i, ReverseSubtractEquation = SubtractEquation % r.boundary, ZeroFactor = SubtractEquation + ReverseSubtractEquation;
                                    n += ReverseSubtractEquation, 0 !== ZeroFactor && i - ZeroFactor < r.storage && (n += i - ZeroFactor), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += r.storage;
                                }
                            }
                        }
                        const r = n % i;
                        r > 0 && (n += i - r);
                        REVISION.__size = n, REVISION.__cache = {};
                    }(n), SrcAlphaFactor = function (t) {
                        const n = function () {
                            for (let REVISION = 0; REVISION < ReverseSubtractEquation; REVISION++)
                                if (-1 === SubtractEquation.indexOf(REVISION))
                                    return SubtractEquation.push(REVISION), REVISION;
                            return console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'), 0;
                        }();
                        t.__bindingPointIndex = n;
                        const i = REVISION.createBuffer(), r = t.__size, AddEquation = t.usage;
                        return REVISION.bindBuffer(REVISION.UNIFORM_BUFFER, i), REVISION.bufferData(REVISION.UNIFORM_BUFFER, r, AddEquation), REVISION.bindBuffer(REVISION.UNIFORM_BUFFER, null), REVISION.bindBufferBase(REVISION.UNIFORM_BUFFER, n, i), i;
                    }(n), r[n.id] = SrcAlphaFactor, n.addEventListener('dispose', SrcColorFactor));
                    const OneMinusSrcAlphaFactor = OneMinusSrcColorFactor.program;
                    i.updateUBOMapping(n, OneMinusSrcAlphaFactor);
                    const DstAlphaFactor = t.render.frame;
                    AddEquation[n.id] !== DstAlphaFactor && (!function (t) {
                        const n = r[t.id], i = t.uniforms, AddEquation = t.__cache;
                        REVISION.bindBuffer(REVISION.UNIFORM_BUFFER, n);
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                            for (let i = 0, r = n.length; i < r; i++) {
                                const r = n[i];
                                if (!0 === ZeroFactor(r, t, i, AddEquation)) {
                                    const t = r.__offset, n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let AddEquation = 0; AddEquation < n.length; AddEquation++) {
                                        const SubtractEquation = n[AddEquation], ReverseSubtractEquation = OneFactor(SubtractEquation);
                                        'number' == typeof SubtractEquation || 'boolean' == typeof SubtractEquation ? (r.__data[0] = SubtractEquation, REVISION.bufferSubData(REVISION.UNIFORM_BUFFER, t + i, r.__data)) : SubtractEquation.isMatrix3 ? (r.__data[0] = SubtractEquation.elements[0], r.__data[1] = SubtractEquation.elements[1], r.__data[2] = SubtractEquation.elements[2], r.__data[3] = 0, r.__data[4] = SubtractEquation.elements[3], r.__data[5] = SubtractEquation.elements[4], r.__data[6] = SubtractEquation.elements[5], r.__data[7] = 0, r.__data[8] = SubtractEquation.elements[6], r.__data[9] = SubtractEquation.elements[7], r.__data[10] = SubtractEquation.elements[8], r.__data[11] = 0) : (SubtractEquation.toArray(r.__data, i), i += ReverseSubtractEquation.storage / Float32Array.BYTES_PER_ELEMENT);
                                    }
                                    REVISION.bufferSubData(REVISION.UNIFORM_BUFFER, t, r.__data);
                                }
                            }
                        }
                        REVISION.bindBuffer(REVISION.UNIFORM_BUFFER, null);
                    }(n), AddEquation[n.id] = DstAlphaFactor);
                },
                dispose: function () {
                    for (const t in r)
                        REVISION.deleteBuffer(r[t]);
                    SubtractEquation = [], r = {}, AddEquation = {};
                }
            };
        }
        class Kp {
            constructor(t = {}) {
                const {
                    canvas: n = It(),
                    context: i = null,
                    depth: r = !0,
                    stencil: AddEquation = !1,
                    alpha: SubtractEquation = !1,
                    antialias: ReverseSubtractEquation = !1,
                    premultipliedAlpha: ZeroFactor = !0,
                    preserveDrawingBuffer: OneFactor = !1,
                    powerPreference: SrcColorFactor = 'default',
                    failIfMajorPerformanceCaveat: OneMinusSrcColorFactor = !1,
                    reverseDepthBuffer: SrcAlphaFactor = !1
                } = t;
                let OneMinusSrcAlphaFactor;
                if (this.isWebGLRenderer = !0, null !== i) {
                    if ('undefined' != typeof WebGLRenderingContext && i instanceof WebGLRenderingContext)
                        throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');
                    OneMinusSrcAlphaFactor = i.getContextAttributes().alpha;
                } else
                    OneMinusSrcAlphaFactor = SubtractEquation;
                const DstAlphaFactor = new Uint32Array(4), OneMinusDstAlphaFactor = new Int32Array(4);
                let DstColorFactor = null, OneMinusDstColorFactor = null;
                const SrcAlphaSaturateFactor = [], ConstantColorFactor = [];
                this.domElement = n, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Ye, this.toneMapping = 0, this.toneMappingExposure = 1;
                const OneMinusConstantColorFactor = this;
                let ConstantAlphaFactor = !1, OneMinusConstantAlphaFactor = 0, b = 0, aspect = null, CullFaceFront = -1, LessEqualDepth = null;
                const MultiplyBlending = new Vector4(), CustomBlending = new Vector4();
                let GreaterDepth = null;
                const NotEqualDepth = new Color(0);
                let AttachedBindMode = 0, CubeReflectionMapping = n.width, CubeRefractionMapping = n.height, EquirectangularReflectionMapping = 1, EquirectangularRefractionMapping = null, CubeUVReflectionMapping = null;
                const RepeatWrapping = new Vector4(0, 0, CubeReflectionMapping, CubeRefractionMapping), ClampToEdgeWrapping = new Vector4(0, 0, CubeReflectionMapping, CubeRefractionMapping);
                let MirroredRepeatWrapping = !1;
                const NearestFilter = new Frustum();
                let NearestMipMapNearestFilter = !1, NearestMipMapLinearFilter = !1;
                this.transmissionResolutionScale = 1;
                const LinearFilter = new Matrix4(), LinearMipMapNearestFilter = new Matrix4(), ByteType = new Vector3(), ShortType = new Vector4(), IntType = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };
                let FloatType = !1;
                function UnsignedInt5999Type() {
                    return null === aspect ? EquirectangularReflectionMapping : 1;
                }
                let RGBAFormat, DepthFormat, DepthStencilFormat, RedFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format = i;
                function RGBA_ASTC_10x8_Format(REVISION, t) {
                    return n.getContext(REVISION, t);
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: r,
                        stencil: AddEquation,
                        antialias: ReverseSubtractEquation,
                        premultipliedAlpha: ZeroFactor,
                        preserveDrawingBuffer: OneFactor,
                        powerPreference: SrcColorFactor,
                        failIfMajorPerformanceCaveat: OneMinusSrcColorFactor
                    };
                    if ('setAttribute' in n && n.setAttribute('data-engine', `three.js r${ REVISION }`), n.addEventListener('webglcontextlost', RGBA_ASTC_12x12_Format, !1), n.addEventListener('webglcontextrestored', RGBA_BPTC_Format, !1), n.addEventListener('webglcontextcreationerror', RGB_BPTC_SIGNED_Format, !1), null === RGBA_ASTC_10x6_Format) {
                        const REVISION = 'webgl2';
                        if (RGBA_ASTC_10x6_Format = RGBA_ASTC_10x8_Format(REVISION, t), null === RGBA_ASTC_10x6_Format)
                            throw RGBA_ASTC_10x8_Format(REVISION) ? new Error('Error creating WebGL context with your selected attributes.') : new Error('Error creating WebGL context.');
                    }
                } catch (REVISION) {
                    throw console.error('THREE.WebGLRenderer: ' + REVISION.message), REVISION;
                }
                function RGBA_ASTC_10x10_Format() {
                    RGBAFormat = new Xu(RGBA_ASTC_10x6_Format), RGBAFormat.init(), RGBA_ASTC_8x6_Format = new Vp(RGBA_ASTC_10x6_Format, RGBAFormat), DepthFormat = new Su(RGBA_ASTC_10x6_Format, RGBAFormat, t, RGBA_ASTC_8x6_Format), DepthStencilFormat = new Hp(RGBA_ASTC_10x6_Format, RGBAFormat), DepthFormat.reverseDepthBuffer && SrcAlphaFactor && DepthStencilFormat.buffers.depth.setReversed(!0), RedFormat = new Yu(RGBA_ASTC_10x6_Format), RGB_S3TC_DXT1_Format = new Cp(), RGBA_S3TC_DXT1_Format = new Wp(RGBA_ASTC_10x6_Format, RGBAFormat, DepthStencilFormat, RGB_S3TC_DXT1_Format, DepthFormat, RGBA_ASTC_8x6_Format, RedFormat), RGBA_S3TC_DXT3_Format = new Mu(OneMinusConstantColorFactor), RGBA_S3TC_DXT5_Format = new Qu(OneMinusConstantColorFactor), RGB_PVRTC_4BPPV1_Format = new pu(RGBA_ASTC_10x6_Format), RGBA_ASTC_8x8_Format = new xu(RGBA_ASTC_10x6_Format, RGB_PVRTC_4BPPV1_Format), RGB_PVRTC_2BPPV1_Format = new ju(RGBA_ASTC_10x6_Format, RGB_PVRTC_4BPPV1_Format, RedFormat, RGBA_ASTC_8x8_Format), RGBA_PVRTC_4BPPV1_Format = new Zu(RGBA_ASTC_10x6_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RedFormat), RGBA_ASTC_6x5_Format = new Ku(RGBA_ASTC_10x6_Format, DepthFormat, RGBA_S3TC_DXT1_Format), RGBA_ASTC_4x4_Format = new Eu(RGB_S3TC_DXT1_Format), RGBA_PVRTC_2BPPV1_Format = new Tp(OneMinusConstantColorFactor, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBAFormat, DepthFormat, RGBA_ASTC_8x8_Format, RGBA_ASTC_4x4_Format), RGB_ETC1_Format = new qp(OneMinusConstantColorFactor, RGB_S3TC_DXT1_Format), RGB_ETC2_Format = new Bp(), RGBA_ETC2_EAC_Format = new Fp(RGBAFormat), RGBA_ASTC_5x5_Format = new yu(OneMinusConstantColorFactor, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, DepthStencilFormat, RGBA_PVRTC_4BPPV1_Format, OneMinusSrcAlphaFactor, ZeroFactor), RGBA_ASTC_5x4_Format = new Op(OneMinusConstantColorFactor, RGBA_PVRTC_4BPPV1_Format, DepthFormat), RGBA_ASTC_10x5_Format = new Yp(RGBA_ASTC_10x6_Format, RedFormat, DepthFormat, DepthStencilFormat), RGBA_ASTC_6x6_Format = new bu(RGBA_ASTC_10x6_Format, RGBAFormat, RedFormat), RGBA_ASTC_8x5_Format = new qu(RGBA_ASTC_10x6_Format, RGBAFormat, RedFormat), RedFormat.programs = RGBA_PVRTC_2BPPV1_Format.programs, OneMinusConstantColorFactor.capabilities = DepthFormat, OneMinusConstantColorFactor.extensions = RGBAFormat, OneMinusConstantColorFactor.properties = RGB_S3TC_DXT1_Format, OneMinusConstantColorFactor.renderLists = RGB_ETC2_Format, OneMinusConstantColorFactor.shadowMap = RGBA_ASTC_5x4_Format, OneMinusConstantColorFactor.state = DepthStencilFormat, OneMinusConstantColorFactor.info = RedFormat;
                }
                RGBA_ASTC_10x10_Format();
                const RGBA_ASTC_12x10_Format = new Qp(OneMinusConstantColorFactor, RGBA_ASTC_10x6_Format);
                function RGBA_ASTC_12x12_Format(REVISION) {
                    REVISION.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), ConstantAlphaFactor = !0;
                }
                function RGBA_BPTC_Format() {
                    console.log('THREE.WebGLRenderer: Context Restored.'), ConstantAlphaFactor = !1;
                    const REVISION = RedFormat.autoReset, t = RGBA_ASTC_5x4_Format.enabled, n = RGBA_ASTC_5x4_Format.autoUpdate, i = RGBA_ASTC_5x4_Format.needsUpdate, r = RGBA_ASTC_5x4_Format.type;
                    RGBA_ASTC_10x10_Format(), RedFormat.autoReset = REVISION, RGBA_ASTC_5x4_Format.enabled = t, RGBA_ASTC_5x4_Format.autoUpdate = n, RGBA_ASTC_5x4_Format.needsUpdate = i, RGBA_ASTC_5x4_Format.type = r;
                }
                function RGB_BPTC_SIGNED_Format(REVISION) {
                    console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', REVISION.statusMessage);
                }
                function RGB_BPTC_UNSIGNED_Format(REVISION) {
                    const t = REVISION.target;
                    t.removeEventListener('dispose', RGB_BPTC_UNSIGNED_Format), function (REVISION) {
                        (function (REVISION) {
                            const t = RGB_S3TC_DXT1_Format.get(REVISION).programs;
                            void 0 !== t && (t.forEach(function (REVISION) {
                                RGBA_PVRTC_2BPPV1_Format.releaseProgram(REVISION);
                            }), REVISION.isShaderMaterial && RGBA_PVRTC_2BPPV1_Format.releaseShaderCache(REVISION));
                        }(REVISION), RGB_S3TC_DXT1_Format.remove(REVISION));
                    }(t);
                }
                function SIGNED_RED_RGTC1_Format(REVISION, t, n) {
                    !0 === REVISION.transparent && 2 === REVISION.side && !1 === REVISION.forceSinglePass ? (REVISION.side = 1, REVISION.needsUpdate = !0, LinearTransfer(REVISION, t, n), REVISION.side = 0, REVISION.needsUpdate = !0, LinearTransfer(REVISION, t, n), REVISION.side = 2) : LinearTransfer(REVISION, t, n);
                }
                this.xr = RGBA_ASTC_12x10_Format, this.getContext = function () {
                    return RGBA_ASTC_10x6_Format;
                }, this.getContextAttributes = function () {
                    return RGBA_ASTC_10x6_Format.getContextAttributes();
                }, this.forceContextLoss = function () {
                    const REVISION = RGBAFormat.get('WEBGL_lose_context');
                    REVISION && REVISION.loseContext();
                }, this.forceContextRestore = function () {
                    const REVISION = RGBAFormat.get('WEBGL_lose_context');
                    REVISION && REVISION.restoreContext();
                }, this.getPixelRatio = function () {
                    return EquirectangularReflectionMapping;
                }, this.setPixelRatio = function (REVISION) {
                    void 0 !== REVISION && (EquirectangularReflectionMapping = REVISION, this.setSize(CubeReflectionMapping, CubeRefractionMapping, !1));
                }, this.getSize = function (REVISION) {
                    return REVISION.set(CubeReflectionMapping, CubeRefractionMapping);
                }, this.setSize = function (REVISION, t, i = !0) {
                    RGBA_ASTC_12x10_Format.isPresenting ? console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.') : (CubeReflectionMapping = REVISION, CubeRefractionMapping = t, n.width = Math.floor(REVISION * EquirectangularReflectionMapping), n.height = Math.floor(t * EquirectangularReflectionMapping), !0 === i && (n.style.width = REVISION + 'px', n.style.height = t + 'px'), this.setViewport(0, 0, REVISION, t));
                }, this.getDrawingBufferSize = function (REVISION) {
                    return REVISION.set(CubeReflectionMapping * EquirectangularReflectionMapping, CubeRefractionMapping * EquirectangularReflectionMapping).floor();
                }, this.setDrawingBufferSize = function (REVISION, t, i) {
                    CubeReflectionMapping = REVISION, CubeRefractionMapping = t, EquirectangularReflectionMapping = i, n.width = Math.floor(REVISION * i), n.height = Math.floor(t * i), this.setViewport(0, 0, REVISION, t);
                }, this.getCurrentViewport = function (REVISION) {
                    return REVISION.copy(MultiplyBlending);
                }, this.getViewport = function (REVISION) {
                    return REVISION.copy(RepeatWrapping);
                }, this.setViewport = function (REVISION, t, n, i) {
                    REVISION.isVector4 ? RepeatWrapping.set(REVISION.x, REVISION.y, REVISION.z, REVISION.w) : RepeatWrapping.set(REVISION, t, n, i), DepthStencilFormat.viewport(MultiplyBlending.copy(RepeatWrapping).multiplyScalar(EquirectangularReflectionMapping).round());
                }, this.getScissor = function (REVISION) {
                    return REVISION.copy(ClampToEdgeWrapping);
                }, this.setScissor = function (REVISION, t, n, i) {
                    REVISION.isVector4 ? ClampToEdgeWrapping.set(REVISION.x, REVISION.y, REVISION.z, REVISION.w) : ClampToEdgeWrapping.set(REVISION, t, n, i), DepthStencilFormat.scissor(CustomBlending.copy(ClampToEdgeWrapping).multiplyScalar(EquirectangularReflectionMapping).round());
                }, this.getScissorTest = function () {
                    return MirroredRepeatWrapping;
                }, this.setScissorTest = function (REVISION) {
                    DepthStencilFormat.setScissorTest(MirroredRepeatWrapping = REVISION);
                }, this.setOpaqueSort = function (REVISION) {
                    EquirectangularRefractionMapping = REVISION;
                }, this.setTransparentSort = function (REVISION) {
                    CubeUVReflectionMapping = REVISION;
                }, this.getClearColor = function (REVISION) {
                    return REVISION.copy(RGBA_ASTC_5x5_Format.getClearColor());
                }, this.setClearColor = function () {
                    RGBA_ASTC_5x5_Format.setClearColor(...arguments);
                }, this.getClearAlpha = function () {
                    return RGBA_ASTC_5x5_Format.getClearAlpha();
                }, this.setClearAlpha = function () {
                    RGBA_ASTC_5x5_Format.setClearAlpha(...arguments);
                }, this.clear = function (REVISION = !0, t = !0, n = !0) {
                    let i = 0;
                    if (REVISION) {
                        let REVISION = !1;
                        if (null !== aspect) {
                            const t = aspect.texture.format;
                            REVISION = t === RGBAIntegerFormat || t === RGIntegerFormat || t === RedIntegerFormat;
                        }
                        if (REVISION) {
                            const REVISION = aspect.texture.type, t = REVISION === UnsignedByteType || REVISION === UnsignedIntType || REVISION === UnsignedShortType || REVISION === UnsignedInt248Type || REVISION === UnsignedShort4444Type || REVISION === UnsignedShort5551Type, n = RGBA_ASTC_5x5_Format.getClearColor(), i = RGBA_ASTC_5x5_Format.getClearAlpha(), r = n.r, AddEquation = n.g, SubtractEquation = n.b;
                            t ? (DstAlphaFactor[0] = r, DstAlphaFactor[1] = AddEquation, DstAlphaFactor[2] = SubtractEquation, DstAlphaFactor[3] = i, RGBA_ASTC_10x6_Format.clearBufferuiv(RGBA_ASTC_10x6_Format.COLOR, 0, DstAlphaFactor)) : (OneMinusDstAlphaFactor[0] = r, OneMinusDstAlphaFactor[1] = AddEquation, OneMinusDstAlphaFactor[2] = SubtractEquation, OneMinusDstAlphaFactor[3] = i, RGBA_ASTC_10x6_Format.clearBufferiv(RGBA_ASTC_10x6_Format.COLOR, 0, OneMinusDstAlphaFactor));
                        } else
                            i |= RGBA_ASTC_10x6_Format.COLOR_BUFFER_BIT;
                    }
                    t && (i |= RGBA_ASTC_10x6_Format.DEPTH_BUFFER_BIT), n && (i |= RGBA_ASTC_10x6_Format.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), RGBA_ASTC_10x6_Format.clear(i);
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1);
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1);
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0);
                }, this.dispose = function () {
                    n.removeEventListener('webglcontextlost', RGBA_ASTC_12x12_Format, !1), n.removeEventListener('webglcontextrestored', RGBA_BPTC_Format, !1), n.removeEventListener('webglcontextcreationerror', RGB_BPTC_SIGNED_Format, !1), RGBA_ASTC_5x5_Format.dispose(), RGB_ETC2_Format.dispose(), RGBA_ETC2_EAC_Format.dispose(), RGB_S3TC_DXT1_Format.dispose(), RGBA_S3TC_DXT3_Format.dispose(), RGBA_S3TC_DXT5_Format.dispose(), RGBA_PVRTC_4BPPV1_Format.dispose(), RGBA_ASTC_8x8_Format.dispose(), RGBA_ASTC_10x5_Format.dispose(), RGBA_PVRTC_2BPPV1_Format.dispose(), RGBA_ASTC_12x10_Format.dispose(), RGBA_ASTC_12x10_Format.removeEventListener('sessionstart', SIGNED_RED_GREEN_RGTC2_Format), RGBA_ASTC_12x10_Format.removeEventListener('sessionend', InterpolateDiscrete), InterpolateLinear.stop();
                }, this.renderBufferDirect = function (REVISION, t, n, i, r, AddEquation) {
                    null === t && (t = IntType);
                    const SubtractEquation = r.isMesh && r.matrixWorld.determinant() < 0, ReverseSubtractEquation = function (REVISION, t, n, i, r) {
                            !0 !== t.isScene && (t = IntType);
                            RGBA_S3TC_DXT1_Format.resetTextureUnits();
                            const AddEquation = t.fog, SubtractEquation = i.isMeshStandardMaterial ? t.environment : null, ReverseSubtractEquation = null === aspect ? OneMinusConstantColorFactor.outputColorSpace : !0 === aspect.isXRRenderTarget ? aspect.texture.colorSpace : LinearSRGBColorSpace, ZeroFactor = (i.isMeshStandardMaterial ? RGBA_S3TC_DXT5_Format : RGBA_S3TC_DXT3_Format).get(i.envMap || SubtractEquation), OneFactor = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize, SrcColorFactor = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0), OneMinusSrcColorFactor = !!n.morphAttributes.position, SrcAlphaFactor = !!n.morphAttributes.normal, OneMinusSrcAlphaFactor = !!n.morphAttributes.color;
                            let DstAlphaFactor = 0;
                            i.toneMapped && (null !== aspect && !0 !== aspect.isXRRenderTarget || (DstAlphaFactor = OneMinusConstantColorFactor.toneMapping));
                            const OneMinusDstAlphaFactor = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color, DstColorFactor = void 0 !== OneMinusDstAlphaFactor ? OneMinusDstAlphaFactor.length : 0, SrcAlphaSaturateFactor = RGB_S3TC_DXT1_Format.get(i), ConstantColorFactor = OneMinusDstColorFactor.state.lights;
                            if (!0 === NearestMipMapNearestFilter && (!0 === NearestMipMapLinearFilter || REVISION !== LessEqualDepth)) {
                                const t = REVISION === LessEqualDepth && i.id === CullFaceFront;
                                RGBA_ASTC_4x4_Format.setState(i, REVISION, t);
                            }
                            let ConstantAlphaFactor = !1;
                            i.version === SrcAlphaSaturateFactor.__version ? SrcAlphaSaturateFactor.needsLights && SrcAlphaSaturateFactor.lightsStateVersion !== ConstantColorFactor.state.version || SrcAlphaSaturateFactor.outputColorSpace !== ReverseSubtractEquation || r.isBatchedMesh && !1 === SrcAlphaSaturateFactor.batching ? ConstantAlphaFactor = !0 : r.isBatchedMesh || !0 !== SrcAlphaSaturateFactor.batching ? r.isBatchedMesh && !0 === SrcAlphaSaturateFactor.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === SrcAlphaSaturateFactor.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === SrcAlphaSaturateFactor.instancing ? ConstantAlphaFactor = !0 : r.isInstancedMesh || !0 !== SrcAlphaSaturateFactor.instancing ? r.isSkinnedMesh && !1 === SrcAlphaSaturateFactor.skinning ? ConstantAlphaFactor = !0 : r.isSkinnedMesh || !0 !== SrcAlphaSaturateFactor.skinning ? r.isInstancedMesh && !0 === SrcAlphaSaturateFactor.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === SrcAlphaSaturateFactor.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === SrcAlphaSaturateFactor.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === SrcAlphaSaturateFactor.instancingMorph && null !== r.morphTexture || SrcAlphaSaturateFactor.envMap !== ZeroFactor || !0 === i.fog && SrcAlphaSaturateFactor.fog !== AddEquation ? ConstantAlphaFactor = !0 : void 0 === SrcAlphaSaturateFactor.numClippingPlanes || SrcAlphaSaturateFactor.numClippingPlanes === RGBA_ASTC_4x4_Format.numPlanes && SrcAlphaSaturateFactor.numIntersection === RGBA_ASTC_4x4_Format.numIntersection ? (SrcAlphaSaturateFactor.vertexAlphas !== OneFactor || SrcAlphaSaturateFactor.vertexTangents !== SrcColorFactor || SrcAlphaSaturateFactor.morphTargets !== OneMinusSrcColorFactor || SrcAlphaSaturateFactor.morphNormals !== SrcAlphaFactor || SrcAlphaSaturateFactor.morphColors !== OneMinusSrcAlphaFactor || SrcAlphaSaturateFactor.toneMapping !== DstAlphaFactor || SrcAlphaSaturateFactor.morphTargetsCount !== DstColorFactor) && (ConstantAlphaFactor = !0) : ConstantAlphaFactor = !0 : ConstantAlphaFactor = !0 : ConstantAlphaFactor = !0 : ConstantAlphaFactor = !0 : (ConstantAlphaFactor = !0, SrcAlphaSaturateFactor.__version = i.version);
                            let OneMinusConstantAlphaFactor = SrcAlphaSaturateFactor.currentProgram;
                            !0 === ConstantAlphaFactor && (OneMinusConstantAlphaFactor = LinearTransfer(i, t, r));
                            let b = !1, MultiplyBlending = !1, CustomBlending = !1;
                            const GreaterDepth = OneMinusConstantAlphaFactor.getUniforms(), NotEqualDepth = SrcAlphaSaturateFactor.uniforms;
                            DepthStencilFormat.useProgram(OneMinusConstantAlphaFactor.program) && (b = !0, MultiplyBlending = !0, CustomBlending = !0);
                            i.id !== CullFaceFront && (CullFaceFront = i.id, MultiplyBlending = !0);
                            if (b || LessEqualDepth !== REVISION) {
                                DepthStencilFormat.buffers.depth.getReversed() ? (LinearFilter.copy(REVISION.projectionMatrix), function (REVISION) {
                                    const t = REVISION.elements;
                                    t[2] = 0.5 * t[2] + 0.5 * t[3], t[6] = 0.5 * t[6] + 0.5 * t[7], t[10] = 0.5 * t[10] + 0.5 * t[11], t[14] = 0.5 * t[14] + 0.5 * t[15];
                                }(LinearFilter), function (REVISION) {
                                    const t = REVISION.elements;
                                    -1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = 1 - t[14]);
                                }(LinearFilter), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'projectionMatrix', LinearFilter)) : GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'projectionMatrix', REVISION.projectionMatrix), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'viewMatrix', REVISION.matrixWorldInverse);
                                const t = GreaterDepth.map.cameraPosition;
                                void 0 !== t && t.setValue(RGBA_ASTC_10x6_Format, ByteType.setFromMatrixPosition(REVISION.matrixWorld)), DepthFormat.logarithmicDepthBuffer && GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'logDepthBufFC', 2 / (Math.log(REVISION.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'isOrthographic', !0 === REVISION.isOrthographicCamera), LessEqualDepth !== REVISION && (LessEqualDepth = REVISION, MultiplyBlending = !0, CustomBlending = !0);
                            }
                            if (r.isSkinnedMesh) {
                                GreaterDepth.setOptional(RGBA_ASTC_10x6_Format, r, 'bindMatrix'), GreaterDepth.setOptional(RGBA_ASTC_10x6_Format, r, 'bindMatrixInverse');
                                const REVISION = r.skeleton;
                                REVISION && (null === REVISION.boneTexture && REVISION.computeBoneTexture(), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'boneTexture', REVISION.boneTexture, RGBA_S3TC_DXT1_Format));
                            }
                            r.isBatchedMesh && (GreaterDepth.setOptional(RGBA_ASTC_10x6_Format, r, 'batchingTexture'), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'batchingTexture', r._matricesTexture, RGBA_S3TC_DXT1_Format), GreaterDepth.setOptional(RGBA_ASTC_10x6_Format, r, 'batchingIdTexture'), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'batchingIdTexture', r._indirectTexture, RGBA_S3TC_DXT1_Format), GreaterDepth.setOptional(RGBA_ASTC_10x6_Format, r, 'batchingColorTexture'), null !== r._colorsTexture && GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'batchingColorTexture', r._colorsTexture, RGBA_S3TC_DXT1_Format));
                            const AttachedBindMode = n.morphAttributes;
                            void 0 === AttachedBindMode.position && void 0 === AttachedBindMode.normal && void 0 === AttachedBindMode.color || RGBA_ASTC_6x5_Format.update(r, n, OneMinusConstantAlphaFactor);
                            (MultiplyBlending || SrcAlphaSaturateFactor.receiveShadow !== r.receiveShadow) && (SrcAlphaSaturateFactor.receiveShadow = r.receiveShadow, GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'receiveShadow', r.receiveShadow));
                            i.isMeshGouraudMaterial && null !== i.envMap && (NotEqualDepth.envMap.value = ZeroFactor, NotEqualDepth.flipEnvMap.value = ZeroFactor.isCubeTexture && !1 === ZeroFactor.isRenderTargetTexture ? -1 : 1);
                            i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (NotEqualDepth.envMapIntensity.value = t.environmentIntensity);
                            MultiplyBlending && (GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'toneMappingExposure', OneMinusConstantColorFactor.toneMappingExposure), SrcAlphaSaturateFactor.needsLights && (EquirectangularRefractionMapping = CustomBlending, (CubeReflectionMapping = NotEqualDepth).ambientLightColor.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.lightProbe.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.directionalLights.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.directionalLightShadows.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.pointLights.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.pointLightShadows.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.spotLights.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.spotLightShadows.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.rectAreaLights.needsUpdate = EquirectangularRefractionMapping, CubeReflectionMapping.hemisphereLights.needsUpdate = EquirectangularRefractionMapping), AddEquation && !0 === i.fog && RGB_ETC1_Format.refreshFogUniforms(NotEqualDepth, AddEquation), RGB_ETC1_Format.refreshMaterialUniforms(NotEqualDepth, i, EquirectangularReflectionMapping, CubeRefractionMapping, OneMinusDstColorFactor.state.transmissionRenderTarget[REVISION.id]), ip.upload(RGBA_ASTC_10x6_Format, SRGBTransfer(SrcAlphaSaturateFactor), NotEqualDepth, RGBA_S3TC_DXT1_Format));
                            var CubeReflectionMapping, EquirectangularRefractionMapping;
                            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ip.upload(RGBA_ASTC_10x6_Format, SRGBTransfer(SrcAlphaSaturateFactor), NotEqualDepth, RGBA_S3TC_DXT1_Format), i.uniformsNeedUpdate = !1);
                            i.isSpriteMaterial && GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'center', r.center);
                            if (GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'modelViewMatrix', r.modelViewMatrix), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'normalMatrix', r.normalMatrix), GreaterDepth.setValue(RGBA_ASTC_10x6_Format, 'modelMatrix', r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                                const REVISION = i.uniformsGroups;
                                for (let t = 0, n = REVISION.length; t < n; t++) {
                                    const n = REVISION[t];
                                    RGBA_ASTC_10x5_Format.update(n, OneMinusConstantAlphaFactor), RGBA_ASTC_10x5_Format.bind(n, OneMinusConstantAlphaFactor);
                                }
                            }
                            return OneMinusConstantAlphaFactor;
                        }(REVISION, t, n, i, r);
                    DepthStencilFormat.setMaterial(i, SubtractEquation);
                    let ZeroFactor = n.index, OneFactor = 1;
                    if (!0 === i.wireframe) {
                        if (ZeroFactor = RGB_PVRTC_2BPPV1_Format.getWireframeAttribute(n), void 0 === ZeroFactor)
                            return;
                        OneFactor = 2;
                    }
                    const SrcColorFactor = n.drawRange, OneMinusSrcColorFactor = n.attributes.position;
                    let SrcAlphaFactor = SrcColorFactor.start * OneFactor, OneMinusSrcAlphaFactor = (SrcColorFactor.start + SrcColorFactor.count) * OneFactor;
                    null !== AddEquation && (SrcAlphaFactor = Math.max(SrcAlphaFactor, AddEquation.start * OneFactor), OneMinusSrcAlphaFactor = Math.min(OneMinusSrcAlphaFactor, (AddEquation.start + AddEquation.count) * OneFactor)), null !== ZeroFactor ? (SrcAlphaFactor = Math.max(SrcAlphaFactor, 0), OneMinusSrcAlphaFactor = Math.min(OneMinusSrcAlphaFactor, ZeroFactor.count)) : null != OneMinusSrcColorFactor && (SrcAlphaFactor = Math.max(SrcAlphaFactor, 0), OneMinusSrcAlphaFactor = Math.min(OneMinusSrcAlphaFactor, OneMinusSrcColorFactor.count));
                    const DstAlphaFactor = OneMinusSrcAlphaFactor - SrcAlphaFactor;
                    if (DstAlphaFactor < 0 || DstAlphaFactor === 1 / 0)
                        return;
                    let OneMinusDstAlphaFactor;
                    RGBA_ASTC_8x8_Format.setup(r, i, ReverseSubtractEquation, n, ZeroFactor);
                    let DstColorFactor = RGBA_ASTC_6x6_Format;
                    if (null !== ZeroFactor && (OneMinusDstAlphaFactor = RGB_PVRTC_4BPPV1_Format.get(ZeroFactor), DstColorFactor = RGBA_ASTC_8x5_Format, DstColorFactor.setIndex(OneMinusDstAlphaFactor)), r.isMesh)
                        !0 === i.wireframe ? (DepthStencilFormat.setLineWidth(i.wireframeLinewidth * UnsignedInt5999Type()), DstColorFactor.setMode(RGBA_ASTC_10x6_Format.LINES)) : DstColorFactor.setMode(RGBA_ASTC_10x6_Format.TRIANGLES);
                    else if (r.isLine) {
                        let REVISION = i.linewidth;
                        void 0 === REVISION && (REVISION = 1), DepthStencilFormat.setLineWidth(REVISION * UnsignedInt5999Type()), r.isLineSegments ? DstColorFactor.setMode(RGBA_ASTC_10x6_Format.LINES) : r.isLineLoop ? DstColorFactor.setMode(RGBA_ASTC_10x6_Format.LINE_LOOP) : DstColorFactor.setMode(RGBA_ASTC_10x6_Format.LINE_STRIP);
                    } else
                        r.isPoints ? DstColorFactor.setMode(RGBA_ASTC_10x6_Format.POINTS) : r.isSprite && DstColorFactor.setMode(RGBA_ASTC_10x6_Format.TRIANGLES);
                    if (r.isBatchedMesh)
                        if (null !== r._multiDrawInstances)
                            Pt('THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.'), DstColorFactor.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                        else if (RGBAFormat.get('WEBGL_multi_draw'))
                            DstColorFactor.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                        else {
                            const REVISION = r._multiDrawStarts, t = r._multiDrawCounts, n = r._multiDrawCount, AddEquation = ZeroFactor ? RGB_PVRTC_4BPPV1_Format.get(ZeroFactor).bytesPerElement : 1, SubtractEquation = RGB_S3TC_DXT1_Format.get(i).currentProgram.getUniforms();
                            for (let i = 0; i < n; i++)
                                SubtractEquation.setValue(RGBA_ASTC_10x6_Format, '_gl_DrawID', i), DstColorFactor.render(REVISION[i] / AddEquation, t[i]);
                        }
                    else if (r.isInstancedMesh)
                        DstColorFactor.renderInstances(SrcAlphaFactor, DstAlphaFactor, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const REVISION = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0, t = Math.min(n.instanceCount, REVISION);
                        DstColorFactor.renderInstances(SrcAlphaFactor, DstAlphaFactor, t);
                    } else
                        DstColorFactor.render(SrcAlphaFactor, DstAlphaFactor);
                }, this.compile = function (REVISION, t, n = null) {
                    null === n && (n = REVISION), OneMinusDstColorFactor = RGBA_ETC2_EAC_Format.get(n), OneMinusDstColorFactor.init(t), ConstantColorFactor.push(OneMinusDstColorFactor), n.traverseVisible(function (REVISION) {
                        REVISION.isLight && REVISION.layers.test(t.layers) && (OneMinusDstColorFactor.pushLight(REVISION), REVISION.castShadow && OneMinusDstColorFactor.pushShadow(REVISION));
                    }), REVISION !== n && REVISION.traverseVisible(function (REVISION) {
                        REVISION.isLight && REVISION.layers.test(t.layers) && (OneMinusDstColorFactor.pushLight(REVISION), REVISION.castShadow && OneMinusDstColorFactor.pushShadow(REVISION));
                    }), OneMinusDstColorFactor.setupLights();
                    const i = new Set();
                    return REVISION.traverse(function (REVISION) {
                        if (!(REVISION.isMesh || REVISION.isPoints || REVISION.isLine || REVISION.isSprite))
                            return;
                        const t = REVISION.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let r = 0; r < t.length; r++) {
                                    const AddEquation = t[r];
                                    SIGNED_RED_RGTC1_Format(AddEquation, n, REVISION), i.add(AddEquation);
                                }
                            else
                                SIGNED_RED_RGTC1_Format(t, n, REVISION), i.add(t);
                    }), OneMinusDstColorFactor = ConstantColorFactor.pop(), i;
                }, this.compileAsync = function (REVISION, t, n = null) {
                    const i = this.compile(REVISION, t, n);
                    return new Promise(t => {
                        function n() {
                            i.forEach(function (REVISION) {
                                RGB_S3TC_DXT1_Format.get(REVISION).currentProgram.isReady() && i.delete(REVISION);
                            }), 0 !== i.size ? setTimeout(n, 10) : t(REVISION);
                        }
                        null !== RGBAFormat.get('KHR_parallel_shader_compile') ? n() : setTimeout(n, 10);
                    });
                };
                let RED_GREEN_RGTC2_Format = null;
                function SIGNED_RED_GREEN_RGTC2_Format() {
                    InterpolateLinear.stop();
                }
                function InterpolateDiscrete() {
                    InterpolateLinear.start();
                }
                const InterpolateLinear = new fu();
                function InterpolateSmooth(REVISION, t, n, i) {
                    if (!1 === REVISION.visible)
                        return;
                    if (REVISION.layers.test(t.layers))
                        if (REVISION.isGroup)
                            n = REVISION.renderOrder;
                        else if (REVISION.isLOD)
                            !0 === REVISION.autoUpdate && REVISION.update(t);
                        else if (REVISION.isLight)
                            OneMinusDstColorFactor.pushLight(REVISION), REVISION.castShadow && OneMinusDstColorFactor.pushShadow(REVISION);
                        else if (REVISION.isSprite) {
                            if (!REVISION.frustumCulled || NearestFilter.intersectsSprite(REVISION)) {
                                i && ShortType.setFromMatrixPosition(REVISION.matrixWorld).applyMatrix4(LinearMipMapNearestFilter);
                                const t = RGBA_PVRTC_4BPPV1_Format.update(REVISION), r = REVISION.material;
                                r.visible && DstColorFactor.push(REVISION, t, r, n, ShortType.z, null);
                            }
                        } else if ((REVISION.isMesh || REVISION.isLine || REVISION.isPoints) && (!REVISION.frustumCulled || NearestFilter.intersectsObject(REVISION))) {
                            const t = RGBA_PVRTC_4BPPV1_Format.update(REVISION), r = REVISION.material;
                            if (i && (void 0 !== REVISION.boundingSphere ? (null === REVISION.boundingSphere && REVISION.computeBoundingSphere(), ShortType.copy(REVISION.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), ShortType.copy(t.boundingSphere.center)), ShortType.applyMatrix4(REVISION.matrixWorld).applyMatrix4(LinearMipMapNearestFilter)), Array.isArray(r)) {
                                const i = t.groups;
                                for (let AddEquation = 0, SubtractEquation = i.length; AddEquation < SubtractEquation; AddEquation++) {
                                    const SubtractEquation = i[AddEquation], ReverseSubtractEquation = r[SubtractEquation.materialIndex];
                                    ReverseSubtractEquation && ReverseSubtractEquation.visible && DstColorFactor.push(REVISION, t, ReverseSubtractEquation, n, ShortType.z, SubtractEquation);
                                }
                            } else
                                r.visible && DstColorFactor.push(REVISION, t, r, n, ShortType.z, null);
                        }
                    const r = REVISION.children;
                    for (let REVISION = 0, AddEquation = r.length; REVISION < AddEquation; REVISION++)
                        InterpolateSmooth(r[REVISION], t, n, i);
                }
                function ZeroCurvatureEnding(REVISION, t, n, i) {
                    const r = REVISION.opaque, AddEquation = REVISION.transmissive, SubtractEquation = REVISION.transparent;
                    OneMinusDstColorFactor.setupLightsView(n), !0 === NearestMipMapNearestFilter && RGBA_ASTC_4x4_Format.setGlobalState(OneMinusConstantColorFactor.clippingPlanes, n), i && DepthStencilFormat.viewport(MultiplyBlending.copy(i)), r.length > 0 && WrapAroundEnding(r, t, n), AddEquation.length > 0 && WrapAroundEnding(AddEquation, t, n), SubtractEquation.length > 0 && WrapAroundEnding(SubtractEquation, t, n), DepthStencilFormat.buffers.depth.setTest(!0), DepthStencilFormat.buffers.depth.setMask(!0), DepthStencilFormat.buffers.color.setMask(!0), DepthStencilFormat.setPolygonOffset(!1);
                }
                function ZeroSlopeEnding(REVISION, t, n, i) {
                    if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                        return;
                    void 0 === OneMinusDstColorFactor.state.transmissionRenderTarget[i.id] && (OneMinusDstColorFactor.state.transmissionRenderTarget[i.id] = new jt(1, 1, {
                        generateMipmaps: !0,
                        type: RGBAFormat.has('EXT_color_buffer_half_float') || RGBAFormat.has('EXT_color_buffer_float') ? HalfFloatType : UnsignedByteType,
                        minFilter: LinearMipMapLinearFilter,
                        samples: 4,
                        stencilBuffer: AddEquation,
                        resolveDepthBuffer: !1,
                        resolveStencilBuffer: !1,
                        colorSpace: _tables.workingColorSpace
                    }));
                    const r = OneMinusDstColorFactor.state.transmissionRenderTarget[i.id], SubtractEquation = i.viewport || MultiplyBlending;
                    r.setSize(SubtractEquation.z * OneMinusConstantColorFactor.transmissionResolutionScale, SubtractEquation.w * OneMinusConstantColorFactor.transmissionResolutionScale);
                    const ReverseSubtractEquation = OneMinusConstantColorFactor.getRenderTarget();
                    OneMinusConstantColorFactor.setRenderTarget(r), OneMinusConstantColorFactor.getClearColor(NotEqualDepth), AttachedBindMode = OneMinusConstantColorFactor.getClearAlpha(), AttachedBindMode < 1 && OneMinusConstantColorFactor.setClearColor(16777215, 0.5), OneMinusConstantColorFactor.clear(), FloatType && RGBA_ASTC_5x5_Format.render(n);
                    const ZeroFactor = OneMinusConstantColorFactor.toneMapping;
                    OneMinusConstantColorFactor.toneMapping = 0;
                    const OneFactor = i.viewport;
                    if (void 0 !== i.viewport && (i.viewport = void 0), OneMinusDstColorFactor.setupLightsView(i), !0 === NearestMipMapNearestFilter && RGBA_ASTC_4x4_Format.setGlobalState(OneMinusConstantColorFactor.clippingPlanes, i), WrapAroundEnding(REVISION, n, i), RGBA_S3TC_DXT1_Format.updateMultisampleRenderTarget(r), RGBA_S3TC_DXT1_Format.updateRenderTargetMipmap(r), !1 === RGBAFormat.has('WEBGL_multisampled_render_to_texture')) {
                        let REVISION = !1;
                        for (let r = 0, AddEquation = t.length; r < AddEquation; r++) {
                            const AddEquation = t[r], SubtractEquation = AddEquation.object, ReverseSubtractEquation = AddEquation.geometry, ZeroFactor = AddEquation.material, OneFactor = AddEquation.group;
                            if (2 === ZeroFactor.side && SubtractEquation.layers.test(i.layers)) {
                                const t = ZeroFactor.side;
                                ZeroFactor.side = 1, ZeroFactor.needsUpdate = !0, qe(SubtractEquation, n, i, ReverseSubtractEquation, ZeroFactor, OneFactor), ZeroFactor.side = t, ZeroFactor.needsUpdate = !0, REVISION = !0;
                            }
                        }
                        !0 === REVISION && (RGBA_S3TC_DXT1_Format.updateMultisampleRenderTarget(r), RGBA_S3TC_DXT1_Format.updateRenderTargetMipmap(r));
                    }
                    OneMinusConstantColorFactor.setRenderTarget(ReverseSubtractEquation), OneMinusConstantColorFactor.setClearColor(NotEqualDepth, AttachedBindMode), void 0 !== OneFactor && (i.viewport = OneFactor), OneMinusConstantColorFactor.toneMapping = ZeroFactor;
                }
                function WrapAroundEnding(REVISION, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, AddEquation = REVISION.length; r < AddEquation; r++) {
                        const AddEquation = REVISION[r], SubtractEquation = AddEquation.object, ReverseSubtractEquation = AddEquation.geometry, ZeroFactor = null === i ? AddEquation.material : i, OneFactor = AddEquation.group;
                        SubtractEquation.layers.test(n.layers) && qe(SubtractEquation, t, n, ReverseSubtractEquation, ZeroFactor, OneFactor);
                    }
                }
                function qe(REVISION, t, n, i, r, AddEquation) {
                    REVISION.onBeforeRender(OneMinusConstantColorFactor, t, n, i, r, AddEquation), REVISION.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, REVISION.matrixWorld), REVISION.normalMatrix.getNormalMatrix(REVISION.modelViewMatrix), r.onBeforeRender(OneMinusConstantColorFactor, t, n, i, REVISION, AddEquation), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, OneMinusConstantColorFactor.renderBufferDirect(n, t, i, r, REVISION, AddEquation), r.side = 0, r.needsUpdate = !0, OneMinusConstantColorFactor.renderBufferDirect(n, t, i, r, REVISION, AddEquation), r.side = 2) : OneMinusConstantColorFactor.renderBufferDirect(n, t, i, r, REVISION, AddEquation), REVISION.onAfterRender(OneMinusConstantColorFactor, t, n, i, r, AddEquation);
                }
                function LinearTransfer(REVISION, t, n) {
                    !0 !== t.isScene && (t = IntType);
                    const i = RGB_S3TC_DXT1_Format.get(REVISION), r = OneMinusDstColorFactor.state.lights, AddEquation = OneMinusDstColorFactor.state.shadowsArray, SubtractEquation = r.state.version, ReverseSubtractEquation = RGBA_PVRTC_2BPPV1_Format.getParameters(REVISION, r.state, AddEquation, t, n), ZeroFactor = RGBA_PVRTC_2BPPV1_Format.getProgramCacheKey(ReverseSubtractEquation);
                    let OneFactor = i.programs;
                    i.environment = REVISION.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (REVISION.isMeshStandardMaterial ? RGBA_S3TC_DXT5_Format : RGBA_S3TC_DXT3_Format).get(REVISION.envMap || i.environment), i.envMapRotation = null !== i.environment && null === REVISION.envMap ? t.environmentRotation : REVISION.envMapRotation, void 0 === OneFactor && (REVISION.addEventListener('dispose', RGB_BPTC_UNSIGNED_Format), OneFactor = new Map(), i.programs = OneFactor);
                    let SrcColorFactor = OneFactor.get(ZeroFactor);
                    if (void 0 !== SrcColorFactor) {
                        if (i.currentProgram === SrcColorFactor && i.lightsStateVersion === SubtractEquation)
                            return KeepStencilOp(REVISION, ReverseSubtractEquation), SrcColorFactor;
                    } else
                        ReverseSubtractEquation.uniforms = RGBA_PVRTC_2BPPV1_Format.getUniforms(REVISION), REVISION.onBeforeCompile(ReverseSubtractEquation, OneMinusConstantColorFactor), SrcColorFactor = RGBA_PVRTC_2BPPV1_Format.acquireProgram(ReverseSubtractEquation, ZeroFactor), OneFactor.set(ZeroFactor, SrcColorFactor), i.uniforms = ReverseSubtractEquation.uniforms;
                    const OneMinusSrcColorFactor = i.uniforms;
                    return (REVISION.isShaderMaterial || REVISION.isRawShaderMaterial) && !0 !== REVISION.clipping || (OneMinusSrcColorFactor.clippingPlanes = RGBA_ASTC_4x4_Format.uniform), KeepStencilOp(REVISION, ReverseSubtractEquation), i.needsLights = function (REVISION) {
                        return REVISION.isMeshLambertMaterial || REVISION.isMeshToonMaterial || REVISION.isMeshPhongMaterial || REVISION.isMeshStandardMaterial || REVISION.isShadowMaterial || REVISION.isShaderMaterial && !0 === REVISION.lights;
                    }(REVISION), i.lightsStateVersion = SubtractEquation, i.needsLights && (OneMinusSrcColorFactor.ambientLightColor.value = r.state.ambient, OneMinusSrcColorFactor.lightProbe.value = r.state.probe, OneMinusSrcColorFactor.directionalLights.value = r.state.directional, OneMinusSrcColorFactor.directionalLightShadows.value = r.state.directionalShadow, OneMinusSrcColorFactor.spotLights.value = r.state.spot, OneMinusSrcColorFactor.spotLightShadows.value = r.state.spotShadow, OneMinusSrcColorFactor.rectAreaLights.value = r.state.rectArea, OneMinusSrcColorFactor.ltc_1.value = r.state.rectAreaLTC1, OneMinusSrcColorFactor.ltc_2.value = r.state.rectAreaLTC2, OneMinusSrcColorFactor.pointLights.value = r.state.point, OneMinusSrcColorFactor.pointLightShadows.value = r.state.pointShadow, OneMinusSrcColorFactor.hemisphereLights.value = r.state.hemi, OneMinusSrcColorFactor.directionalShadowMap.value = r.state.directionalShadowMap, OneMinusSrcColorFactor.directionalShadowMatrix.value = r.state.directionalShadowMatrix, OneMinusSrcColorFactor.spotShadowMap.value = r.state.spotShadowMap, OneMinusSrcColorFactor.spotLightMatrix.value = r.state.spotLightMatrix, OneMinusSrcColorFactor.spotLightMap.value = r.state.spotLightMap, OneMinusSrcColorFactor.pointShadowMap.value = r.state.pointShadowMap, OneMinusSrcColorFactor.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = SrcColorFactor, i.uniformsList = null, SrcColorFactor;
                }
                function SRGBTransfer(REVISION) {
                    if (null === REVISION.uniformsList) {
                        const t = REVISION.currentProgram.getUniforms();
                        REVISION.uniformsList = ip.seqWithValue(t.seq, REVISION.uniforms);
                    }
                    return REVISION.uniformsList;
                }
                function KeepStencilOp(REVISION, t) {
                    const n = RGB_S3TC_DXT1_Format.get(REVISION);
                    n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.batchingColor = t.batchingColor, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping;
                }
                InterpolateLinear.setAnimationLoop(function (REVISION) {
                    RED_GREEN_RGTC2_Format && RED_GREEN_RGTC2_Format(REVISION);
                }), 'undefined' != typeof self && InterpolateLinear.setContext(self), this.setAnimationLoop = function (REVISION) {
                    RED_GREEN_RGTC2_Format = REVISION, RGBA_ASTC_12x10_Format.setAnimationLoop(REVISION), null === REVISION ? InterpolateLinear.stop() : InterpolateLinear.start();
                }, RGBA_ASTC_12x10_Format.addEventListener('sessionstart', SIGNED_RED_GREEN_RGTC2_Format), RGBA_ASTC_12x10_Format.addEventListener('sessionend', InterpolateDiscrete), this.render = function (REVISION, t) {
                    if (void 0 !== t && !0 !== t.isCamera)
                        return void console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                    if (!0 === ConstantAlphaFactor)
                        return;
                    if (!0 === REVISION.matrixWorldAutoUpdate && REVISION.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === RGBA_ASTC_12x10_Format.enabled && !0 === RGBA_ASTC_12x10_Format.isPresenting && (!0 === RGBA_ASTC_12x10_Format.cameraAutoUpdate && RGBA_ASTC_12x10_Format.updateCamera(t), t = RGBA_ASTC_12x10_Format.getCamera()), !0 === REVISION.isScene && REVISION.onBeforeRender(OneMinusConstantColorFactor, REVISION, t, aspect), OneMinusDstColorFactor = RGBA_ETC2_EAC_Format.get(REVISION, ConstantColorFactor.length), OneMinusDstColorFactor.init(t), ConstantColorFactor.push(OneMinusDstColorFactor), LinearMipMapNearestFilter.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), NearestFilter.setFromProjectionMatrix(LinearMipMapNearestFilter), NearestMipMapLinearFilter = this.localClippingEnabled, NearestMipMapNearestFilter = RGBA_ASTC_4x4_Format.init(this.clippingPlanes, NearestMipMapLinearFilter), DstColorFactor = RGB_ETC2_Format.get(REVISION, SrcAlphaSaturateFactor.length), DstColorFactor.init(), SrcAlphaSaturateFactor.push(DstColorFactor), !0 === RGBA_ASTC_12x10_Format.enabled && !0 === RGBA_ASTC_12x10_Format.isPresenting) {
                        const REVISION = OneMinusConstantColorFactor.xr.getDepthSensingMesh();
                        null !== REVISION && InterpolateSmooth(REVISION, t, -1 / 0, OneMinusConstantColorFactor.sortObjects);
                    }
                    InterpolateSmooth(REVISION, t, 0, OneMinusConstantColorFactor.sortObjects), DstColorFactor.finish(), !0 === OneMinusConstantColorFactor.sortObjects && DstColorFactor.sort(EquirectangularRefractionMapping, CubeUVReflectionMapping), FloatType = !1 === RGBA_ASTC_12x10_Format.enabled || !1 === RGBA_ASTC_12x10_Format.isPresenting || !1 === RGBA_ASTC_12x10_Format.hasDepthSensing(), FloatType && RGBA_ASTC_5x5_Format.addToRenderList(DstColorFactor, REVISION), this.info.render.frame++, !0 === NearestMipMapNearestFilter && RGBA_ASTC_4x4_Format.beginShadows();
                    const n = OneMinusDstColorFactor.state.shadowsArray;
                    RGBA_ASTC_5x4_Format.render(n, REVISION, t), !0 === NearestMipMapNearestFilter && RGBA_ASTC_4x4_Format.endShadows(), !0 === this.info.autoReset && this.info.reset();
                    const i = DstColorFactor.opaque, r = DstColorFactor.transmissive;
                    if (OneMinusDstColorFactor.setupLights(), t.isArrayCamera) {
                        const n = t.cameras;
                        if (r.length > 0)
                            for (let t = 0, AddEquation = n.length; t < AddEquation; t++) {
                                ZeroSlopeEnding(i, r, REVISION, n[t]);
                            }
                        FloatType && RGBA_ASTC_5x5_Format.render(REVISION);
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            ZeroCurvatureEnding(DstColorFactor, REVISION, i, i.viewport);
                        }
                    } else
                        r.length > 0 && ZeroSlopeEnding(i, r, REVISION, t), FloatType && RGBA_ASTC_5x5_Format.render(REVISION), ZeroCurvatureEnding(DstColorFactor, REVISION, t);
                    null !== aspect && 0 === b && (RGBA_S3TC_DXT1_Format.updateMultisampleRenderTarget(aspect), RGBA_S3TC_DXT1_Format.updateRenderTargetMipmap(aspect)), !0 === REVISION.isScene && REVISION.onAfterRender(OneMinusConstantColorFactor, REVISION, t), RGBA_ASTC_8x8_Format.resetDefaultState(), CullFaceFront = -1, LessEqualDepth = null, ConstantColorFactor.pop(), ConstantColorFactor.length > 0 ? (OneMinusDstColorFactor = ConstantColorFactor[ConstantColorFactor.length - 1], !0 === NearestMipMapNearestFilter && RGBA_ASTC_4x4_Format.setGlobalState(OneMinusConstantColorFactor.clippingPlanes, OneMinusDstColorFactor.state.camera)) : OneMinusDstColorFactor = null, SrcAlphaSaturateFactor.pop(), DstColorFactor = SrcAlphaSaturateFactor.length > 0 ? SrcAlphaSaturateFactor[SrcAlphaSaturateFactor.length - 1] : null;
                }, this.getActiveCubeFace = function () {
                    return OneMinusConstantAlphaFactor;
                }, this.getActiveMipmapLevel = function () {
                    return b;
                }, this.getRenderTarget = function () {
                    return aspect;
                }, this.setRenderTargetTextures = function (REVISION, t, n) {
                    RGB_S3TC_DXT1_Format.get(REVISION.texture).__webglTexture = t, RGB_S3TC_DXT1_Format.get(REVISION.depthTexture).__webglTexture = n;
                    const i = RGB_S3TC_DXT1_Format.get(REVISION);
                    i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === RGBAFormat.has('WEBGL_multisampled_render_to_texture') && (console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'), i.__useRenderToTexture = !1);
                }, this.setRenderTargetFramebuffer = function (REVISION, t) {
                    const n = RGB_S3TC_DXT1_Format.get(REVISION);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t;
                };
                const NeverStencilFunc = RGBA_ASTC_10x6_Format.createFramebuffer();
                this.setRenderTarget = function (REVISION, t = 0, n = 0) {
                    aspect = REVISION, OneMinusConstantAlphaFactor = t, b = n;
                    let i = !0, r = null, AddEquation = !1, SubtractEquation = !1;
                    if (REVISION) {
                        const ReverseSubtractEquation = RGB_S3TC_DXT1_Format.get(REVISION);
                        if (void 0 !== ReverseSubtractEquation.__useDefaultFramebuffer)
                            DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, null), i = !1;
                        else if (void 0 === ReverseSubtractEquation.__webglFramebuffer)
                            RGBA_S3TC_DXT1_Format.setupRenderTarget(REVISION);
                        else if (ReverseSubtractEquation.__hasExternalTextures)
                            RGBA_S3TC_DXT1_Format.rebindTextures(REVISION, RGB_S3TC_DXT1_Format.get(REVISION.texture).__webglTexture, RGB_S3TC_DXT1_Format.get(REVISION.depthTexture).__webglTexture);
                        else if (REVISION.depthBuffer) {
                            const t = REVISION.depthTexture;
                            if (ReverseSubtractEquation.__boundDepthTexture !== t) {
                                if (null !== t && RGB_S3TC_DXT1_Format.has(t) && (REVISION.width !== t.image.width || REVISION.height !== t.image.height))
                                    throw new Error('WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.');
                                RGBA_S3TC_DXT1_Format.setupDepthRenderbuffer(REVISION);
                            }
                        }
                        const ZeroFactor = REVISION.texture;
                        (ZeroFactor.isData3DTexture || ZeroFactor.isDataArrayTexture || ZeroFactor.isCompressedArrayTexture) && (SubtractEquation = !0);
                        const OneFactor = RGB_S3TC_DXT1_Format.get(REVISION).__webglFramebuffer;
                        REVISION.isWebGLCubeRenderTarget ? (r = Array.isArray(OneFactor[t]) ? OneFactor[t][n] : OneFactor[t], AddEquation = !0) : r = REVISION.samples > 0 && !1 === RGBA_S3TC_DXT1_Format.useMultisampledRTT(REVISION) ? RGB_S3TC_DXT1_Format.get(REVISION).__webglMultisampledFramebuffer : Array.isArray(OneFactor) ? OneFactor[n] : OneFactor, MultiplyBlending.copy(REVISION.viewport), CustomBlending.copy(REVISION.scissor), GreaterDepth = REVISION.scissorTest;
                    } else
                        MultiplyBlending.copy(RepeatWrapping).multiplyScalar(EquirectangularReflectionMapping).floor(), CustomBlending.copy(ClampToEdgeWrapping).multiplyScalar(EquirectangularReflectionMapping).floor(), GreaterDepth = MirroredRepeatWrapping;
                    0 !== n && (r = NeverStencilFunc);
                    if (DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, r) && i && DepthStencilFormat.drawBuffers(REVISION, r), DepthStencilFormat.viewport(MultiplyBlending), DepthStencilFormat.scissor(CustomBlending), DepthStencilFormat.setScissorTest(GreaterDepth), AddEquation) {
                        const i = RGB_S3TC_DXT1_Format.get(REVISION.texture);
                        RGBA_ASTC_10x6_Format.framebufferTexture2D(RGBA_ASTC_10x6_Format.FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, RGBA_ASTC_10x6_Format.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n);
                    } else if (SubtractEquation) {
                        const i = RGB_S3TC_DXT1_Format.get(REVISION.texture), r = t;
                        RGBA_ASTC_10x6_Format.framebufferTextureLayer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, i.__webglTexture, n, r);
                    } else if (null !== REVISION && 0 !== n) {
                        const t = RGB_S3TC_DXT1_Format.get(REVISION.texture);
                        RGBA_ASTC_10x6_Format.framebufferTexture2D(RGBA_ASTC_10x6_Format.FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, RGBA_ASTC_10x6_Format.TEXTURE_2D, t.__webglTexture, n);
                    }
                    CullFaceFront = -1;
                }, this.readRenderTargetPixels = function (REVISION, t, n, i, r, AddEquation, SubtractEquation) {
                    if (!REVISION || !REVISION.isWebGLRenderTarget)
                        return void console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                    let ReverseSubtractEquation = RGB_S3TC_DXT1_Format.get(REVISION).__webglFramebuffer;
                    if (REVISION.isWebGLCubeRenderTarget && void 0 !== SubtractEquation && (ReverseSubtractEquation = ReverseSubtractEquation[SubtractEquation]), ReverseSubtractEquation) {
                        DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, ReverseSubtractEquation);
                        try {
                            const SubtractEquation = REVISION.texture, ReverseSubtractEquation = SubtractEquation.format, ZeroFactor = SubtractEquation.type;
                            if (!DepthFormat.textureFormatReadable(ReverseSubtractEquation))
                                return void console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                            if (!DepthFormat.textureTypeReadable(ZeroFactor))
                                return void console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                            t >= 0 && t <= REVISION.width - i && n >= 0 && n <= REVISION.height - r && RGBA_ASTC_10x6_Format.readPixels(t, n, i, r, RGBA_ASTC_8x6_Format.convert(ReverseSubtractEquation), RGBA_ASTC_8x6_Format.convert(ZeroFactor), AddEquation);
                        } finally {
                            const REVISION = null !== aspect ? RGB_S3TC_DXT1_Format.get(aspect).__webglFramebuffer : null;
                            DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, REVISION);
                        }
                    }
                }, this.readRenderTargetPixelsAsync = async function (REVISION, t, n, i, r, AddEquation, SubtractEquation) {
                    if (!REVISION || !REVISION.isWebGLRenderTarget)
                        throw new Error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                    let ReverseSubtractEquation = RGB_S3TC_DXT1_Format.get(REVISION).__webglFramebuffer;
                    if (REVISION.isWebGLCubeRenderTarget && void 0 !== SubtractEquation && (ReverseSubtractEquation = ReverseSubtractEquation[SubtractEquation]), ReverseSubtractEquation) {
                        const SubtractEquation = REVISION.texture, ZeroFactor = SubtractEquation.format, OneFactor = SubtractEquation.type;
                        if (!DepthFormat.textureFormatReadable(ZeroFactor))
                            throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.');
                        if (!DepthFormat.textureTypeReadable(OneFactor))
                            throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.');
                        if (t >= 0 && t <= REVISION.width - i && n >= 0 && n <= REVISION.height - r) {
                            DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, ReverseSubtractEquation);
                            const REVISION = RGBA_ASTC_10x6_Format.createBuffer();
                            RGBA_ASTC_10x6_Format.bindBuffer(RGBA_ASTC_10x6_Format.PIXEL_PACK_BUFFER, REVISION), RGBA_ASTC_10x6_Format.bufferData(RGBA_ASTC_10x6_Format.PIXEL_PACK_BUFFER, AddEquation.byteLength, RGBA_ASTC_10x6_Format.STREAM_READ), RGBA_ASTC_10x6_Format.readPixels(t, n, i, r, RGBA_ASTC_8x6_Format.convert(ZeroFactor), RGBA_ASTC_8x6_Format.convert(OneFactor), 0);
                            const SubtractEquation = null !== aspect ? RGB_S3TC_DXT1_Format.get(aspect).__webglFramebuffer : null;
                            DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.FRAMEBUFFER, SubtractEquation);
                            const SrcColorFactor = RGBA_ASTC_10x6_Format.fenceSync(RGBA_ASTC_10x6_Format.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            return RGBA_ASTC_10x6_Format.flush(), await function (REVISION, t, n) {
                                return new Promise(function (i, r) {
                                    setTimeout(function AddEquation() {
                                        switch (REVISION.clientWaitSync(t, REVISION.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                        case REVISION.WAIT_FAILED:
                                            r();
                                            break;
                                        case REVISION.TIMEOUT_EXPIRED:
                                            setTimeout(AddEquation, n);
                                            break;
                                        default:
                                            i();
                                        }
                                    }, n);
                                });
                            }(RGBA_ASTC_10x6_Format, SrcColorFactor, 4), RGBA_ASTC_10x6_Format.bindBuffer(RGBA_ASTC_10x6_Format.PIXEL_PACK_BUFFER, REVISION), RGBA_ASTC_10x6_Format.getBufferSubData(RGBA_ASTC_10x6_Format.PIXEL_PACK_BUFFER, 0, AddEquation), RGBA_ASTC_10x6_Format.deleteBuffer(REVISION), RGBA_ASTC_10x6_Format.deleteSync(SrcColorFactor), AddEquation;
                        }
                        throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.');
                    }
                }, this.copyFramebufferToTexture = function (REVISION, t = null, n = 0) {
                    !0 !== REVISION.isTexture && (Pt('WebGLRenderer: copyFramebufferToTexture function signature has changed.'), t = arguments[0] || null, REVISION = arguments[1]);
                    const i = Math.pow(2, -n), r = Math.floor(REVISION.image.width * i), AddEquation = Math.floor(REVISION.image.height * i), SubtractEquation = null !== t ? t.x : 0, ReverseSubtractEquation = null !== t ? t.y : 0;
                    RGBA_S3TC_DXT1_Format.setTexture2D(REVISION, 0), RGBA_ASTC_10x6_Format.copyTexSubImage2D(RGBA_ASTC_10x6_Format.TEXTURE_2D, n, 0, 0, SubtractEquation, ReverseSubtractEquation, r, AddEquation), DepthStencilFormat.unbindTexture();
                };
                const LessStencilFunc = RGBA_ASTC_10x6_Format.createFramebuffer(), EqualStencilFunc = RGBA_ASTC_10x6_Format.createFramebuffer();
                this.copyTextureToTexture = function (REVISION, t, n = null, i = null, r = 0, AddEquation = null) {
                    let SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor;
                    !0 !== REVISION.isTexture && (Pt('WebGLRenderer: copyTextureToTexture function signature has changed.'), i = arguments[0] || null, REVISION = arguments[1], t = arguments[2], AddEquation = arguments[3] || 0, n = null), null === AddEquation && (0 !== r ? (Pt('WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.'), AddEquation = r, r = 0) : AddEquation = 0);
                    const OneMinusDstAlphaFactor = REVISION.isCompressedTexture ? REVISION.mipmaps[AddEquation] : REVISION.image;
                    if (null !== n)
                        SubtractEquation = n.max.x - n.min.x, ReverseSubtractEquation = n.max.y - n.min.y, ZeroFactor = n.isBox3 ? n.max.z - n.min.z : 1, OneFactor = n.min.x, SrcColorFactor = n.min.y, OneMinusSrcColorFactor = n.isBox3 ? n.min.z : 0;
                    else {
                        const t = Math.pow(2, -r);
                        SubtractEquation = Math.floor(OneMinusDstAlphaFactor.width * t), ReverseSubtractEquation = Math.floor(OneMinusDstAlphaFactor.height * t), ZeroFactor = REVISION.isDataArrayTexture ? OneMinusDstAlphaFactor.depth : REVISION.isData3DTexture ? Math.floor(OneMinusDstAlphaFactor.depth * t) : 1, OneFactor = 0, SrcColorFactor = 0, OneMinusSrcColorFactor = 0;
                    }
                    null !== i ? (SrcAlphaFactor = i.x, OneMinusSrcAlphaFactor = i.y, DstAlphaFactor = i.z) : (SrcAlphaFactor = 0, OneMinusSrcAlphaFactor = 0, DstAlphaFactor = 0);
                    const DstColorFactor = RGBA_ASTC_8x6_Format.convert(t.format), OneMinusDstColorFactor = RGBA_ASTC_8x6_Format.convert(t.type);
                    let SrcAlphaSaturateFactor;
                    t.isData3DTexture ? (RGBA_S3TC_DXT1_Format.setTexture3D(t, 0), SrcAlphaSaturateFactor = RGBA_ASTC_10x6_Format.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (RGBA_S3TC_DXT1_Format.setTexture2DArray(t, 0), SrcAlphaSaturateFactor = RGBA_ASTC_10x6_Format.TEXTURE_2D_ARRAY) : (RGBA_S3TC_DXT1_Format.setTexture2D(t, 0), SrcAlphaSaturateFactor = RGBA_ASTC_10x6_Format.TEXTURE_2D), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_FLIP_Y_WEBGL, t.flipY), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_ALIGNMENT, t.unpackAlignment);
                    const ConstantColorFactor = RGBA_ASTC_10x6_Format.getParameter(RGBA_ASTC_10x6_Format.UNPACK_ROW_LENGTH), OneMinusConstantColorFactor = RGBA_ASTC_10x6_Format.getParameter(RGBA_ASTC_10x6_Format.UNPACK_IMAGE_HEIGHT), ConstantAlphaFactor = RGBA_ASTC_10x6_Format.getParameter(RGBA_ASTC_10x6_Format.UNPACK_SKIP_PIXELS), OneMinusConstantAlphaFactor = RGBA_ASTC_10x6_Format.getParameter(RGBA_ASTC_10x6_Format.UNPACK_SKIP_ROWS), b = RGBA_ASTC_10x6_Format.getParameter(RGBA_ASTC_10x6_Format.UNPACK_SKIP_IMAGES);
                    RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_ROW_LENGTH, OneMinusDstAlphaFactor.width), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_IMAGE_HEIGHT, OneMinusDstAlphaFactor.height), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_SKIP_PIXELS, OneFactor), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_SKIP_ROWS, SrcColorFactor), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_SKIP_IMAGES, OneMinusSrcColorFactor);
                    const aspect = REVISION.isDataArrayTexture || REVISION.isData3DTexture, CullFaceFront = t.isDataArrayTexture || t.isData3DTexture;
                    if (REVISION.isDepthTexture) {
                        const n = RGB_S3TC_DXT1_Format.get(REVISION), i = RGB_S3TC_DXT1_Format.get(t), OneMinusDstAlphaFactor = RGB_S3TC_DXT1_Format.get(n.__renderTarget), DstColorFactor = RGB_S3TC_DXT1_Format.get(i.__renderTarget);
                        DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, OneMinusDstAlphaFactor.__webglFramebuffer), DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, DstColorFactor.__webglFramebuffer);
                        for (let n = 0; n < ZeroFactor; n++)
                            aspect && (RGBA_ASTC_10x6_Format.framebufferTextureLayer(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, RGB_S3TC_DXT1_Format.get(REVISION).__webglTexture, r, OneMinusSrcColorFactor + n), RGBA_ASTC_10x6_Format.framebufferTextureLayer(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, RGB_S3TC_DXT1_Format.get(t).__webglTexture, AddEquation, DstAlphaFactor + n)), RGBA_ASTC_10x6_Format.blitFramebuffer(OneFactor, SrcColorFactor, SubtractEquation, ReverseSubtractEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, SubtractEquation, ReverseSubtractEquation, RGBA_ASTC_10x6_Format.DEPTH_BUFFER_BIT, RGBA_ASTC_10x6_Format.NEAREST);
                        DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, null), DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, null);
                    } else if (0 !== r || REVISION.isRenderTargetTexture || RGB_S3TC_DXT1_Format.has(REVISION)) {
                        const n = RGB_S3TC_DXT1_Format.get(REVISION), i = RGB_S3TC_DXT1_Format.get(t);
                        DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, LessStencilFunc), DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, EqualStencilFunc);
                        for (let REVISION = 0; REVISION < ZeroFactor; REVISION++)
                            aspect ? RGBA_ASTC_10x6_Format.framebufferTextureLayer(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, n.__webglTexture, r, OneMinusSrcColorFactor + REVISION) : RGBA_ASTC_10x6_Format.framebufferTexture2D(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, RGBA_ASTC_10x6_Format.TEXTURE_2D, n.__webglTexture, r), CullFaceFront ? RGBA_ASTC_10x6_Format.framebufferTextureLayer(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, i.__webglTexture, AddEquation, DstAlphaFactor + REVISION) : RGBA_ASTC_10x6_Format.framebufferTexture2D(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, RGBA_ASTC_10x6_Format.COLOR_ATTACHMENT0, RGBA_ASTC_10x6_Format.TEXTURE_2D, i.__webglTexture, AddEquation), 0 !== r ? RGBA_ASTC_10x6_Format.blitFramebuffer(OneFactor, SrcColorFactor, SubtractEquation, ReverseSubtractEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, SubtractEquation, ReverseSubtractEquation, RGBA_ASTC_10x6_Format.COLOR_BUFFER_BIT, RGBA_ASTC_10x6_Format.NEAREST) : CullFaceFront ? RGBA_ASTC_10x6_Format.copyTexSubImage3D(SrcAlphaSaturateFactor, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor + REVISION, OneFactor, SrcColorFactor, SubtractEquation, ReverseSubtractEquation) : RGBA_ASTC_10x6_Format.copyTexSubImage2D(SrcAlphaSaturateFactor, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, OneFactor, SrcColorFactor, SubtractEquation, ReverseSubtractEquation);
                        DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.READ_FRAMEBUFFER, null), DepthStencilFormat.bindFramebuffer(RGBA_ASTC_10x6_Format.DRAW_FRAMEBUFFER, null);
                    } else
                        CullFaceFront ? REVISION.isDataTexture || REVISION.isData3DTexture ? RGBA_ASTC_10x6_Format.texSubImage3D(SrcAlphaSaturateFactor, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, SubtractEquation, ReverseSubtractEquation, ZeroFactor, DstColorFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor.data) : t.isCompressedArrayTexture ? RGBA_ASTC_10x6_Format.compressedTexSubImage3D(SrcAlphaSaturateFactor, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, SubtractEquation, ReverseSubtractEquation, ZeroFactor, DstColorFactor, OneMinusDstAlphaFactor.data) : RGBA_ASTC_10x6_Format.texSubImage3D(SrcAlphaSaturateFactor, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, SubtractEquation, ReverseSubtractEquation, ZeroFactor, DstColorFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor) : REVISION.isDataTexture ? RGBA_ASTC_10x6_Format.texSubImage2D(RGBA_ASTC_10x6_Format.TEXTURE_2D, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, SubtractEquation, ReverseSubtractEquation, DstColorFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor.data) : REVISION.isCompressedTexture ? RGBA_ASTC_10x6_Format.compressedTexSubImage2D(RGBA_ASTC_10x6_Format.TEXTURE_2D, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, OneMinusDstAlphaFactor.width, OneMinusDstAlphaFactor.height, DstColorFactor, OneMinusDstAlphaFactor.data) : RGBA_ASTC_10x6_Format.texSubImage2D(RGBA_ASTC_10x6_Format.TEXTURE_2D, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, SubtractEquation, ReverseSubtractEquation, DstColorFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor);
                    RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_ROW_LENGTH, ConstantColorFactor), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_IMAGE_HEIGHT, OneMinusConstantColorFactor), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_SKIP_PIXELS, ConstantAlphaFactor), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_SKIP_ROWS, OneMinusConstantAlphaFactor), RGBA_ASTC_10x6_Format.pixelStorei(RGBA_ASTC_10x6_Format.UNPACK_SKIP_IMAGES, b), 0 === AddEquation && t.generateMipmaps && RGBA_ASTC_10x6_Format.generateMipmap(SrcAlphaSaturateFactor), DepthStencilFormat.unbindTexture();
                }, this.copyTextureToTexture3D = function (REVISION, t, n = null, i = null, r = 0) {
                    return !0 !== REVISION.isTexture && (Pt('WebGLRenderer: copyTextureToTexture3D function signature has changed.'), n = arguments[0] || null, i = arguments[1] || null, REVISION = arguments[2], t = arguments[3], r = arguments[4] || 0), Pt('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(REVISION, t, n, i, r);
                }, this.initRenderTarget = function (REVISION) {
                    void 0 === RGB_S3TC_DXT1_Format.get(REVISION).__webglFramebuffer && RGBA_S3TC_DXT1_Format.setupRenderTarget(REVISION);
                }, this.initTexture = function (REVISION) {
                    REVISION.isCubeTexture ? RGBA_S3TC_DXT1_Format.setTextureCube(REVISION, 0) : REVISION.isData3DTexture ? RGBA_S3TC_DXT1_Format.setTexture3D(REVISION, 0) : REVISION.isDataArrayTexture || REVISION.isCompressedArrayTexture ? RGBA_S3TC_DXT1_Format.setTexture2DArray(REVISION, 0) : RGBA_S3TC_DXT1_Format.setTexture2D(REVISION, 0), DepthStencilFormat.unbindTexture();
                }, this.resetState = function () {
                    OneMinusConstantAlphaFactor = 0, b = 0, aspect = null, DepthStencilFormat.reset(), RGBA_ASTC_8x8_Format.reset();
                }, 'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
            }
            get coordinateSystem() {
                return WebGLCoordinateSystem;
            }
            get outputColorSpace() {
                return this._outputColorSpace;
            }
            set outputColorSpace(REVISION) {
                this._outputColorSpace = REVISION;
                const t = this.getContext();
                t.drawingBufferColorspace = _tables._getDrawingBufferColorSpace(REVISION), t.unpackColorSpace = _tables._getUnpackColorSpace();
            }
        }
        const _matrixWorldInv = new Matrix4();
        class Jp {
            constructor(REVISION) {
                REVISION = REVISION || {}, this.zNear = !0 === REVISION.webGL ? -1 : 0, this.vertices = {
                    near: [
                        new Vector3(),
                        new Vector3(),
                        new Vector3(),
                        new Vector3()
                    ],
                    far: [
                        new Vector3(),
                        new Vector3(),
                        new Vector3(),
                        new Vector3()
                    ]
                }, void 0 !== REVISION.projectionMatrix && this.setFromProjectionMatrix(REVISION.projectionMatrix, REVISION.maxFar || 10000);
            }
            setFromProjectionMatrix(REVISION, t) {
                const n = this.zNear, i = 0 === REVISION.elements[11];
                return _matrixWorldInv.copy(REVISION).invert(), this.vertices.near[0].set(1, 1, n), this.vertices.near[1].set(1, -1, n), this.vertices.near[2].set(-1, -1, n), this.vertices.near[3].set(-1, 1, n), this.vertices.near.forEach(function (REVISION) {
                    REVISION.applyMatrix4(_matrixWorldInv);
                }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function (REVISION) {
                    REVISION.applyMatrix4(_matrixWorldInv);
                    const n = Math.abs(REVISION.z);
                    i ? REVISION.z *= Math.min(t / n, 1) : REVISION.multiplyScalar(Math.min(t / n, 1));
                }), this.vertices;
            }
            split(REVISION, t) {
                for (; REVISION.length > t.length;)
                    t.push(new Jp());
                t.length = REVISION.length;
                for (let n = 0; n < REVISION.length; n++) {
                    const i = t[n];
                    if (0 === n)
                        for (let REVISION = 0; REVISION < 4; REVISION++)
                            i.vertices.near[REVISION].copy(this.vertices.near[REVISION]);
                    else
                        for (let t = 0; t < 4; t++)
                            i.vertices.near[t].lerpVectors(this.vertices.near[t], this.vertices.far[t], REVISION[n - 1]);
                    if (n === REVISION.length - 1)
                        for (let REVISION = 0; REVISION < 4; REVISION++)
                            i.vertices.far[REVISION].copy(this.vertices.far[REVISION]);
                    else
                        for (let t = 0; t < 4; t++)
                            i.vertices.far[t].lerpVectors(this.vertices.near[t], this.vertices.far[t], REVISION[n]);
                }
            }
            toSpace(REVISION, t) {
                for (let n = 0; n < 4; n++)
                    t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(REVISION), t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(REVISION);
            }
        }
        const $p = {
                lights_fragment_begin: '\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometryClearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n \tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\n  \t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\t\tvec2 cascade;\n\t\tfloat cascadeCenter;\n\t\tfloat closestEdge;\n\t\tfloat margin;\n\t\tfloat csmx;\n\t\tfloat csmy;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\t\tcascade = CSM_cascades[ i ];\n\t\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#elif defined (USE_SHADOWMAP)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\n\t\t// note: no loop here - all CSM lights are in fact one light only\n\t\tgetDirectionalLightInfo( directionalLights[0], directLight );\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if defined( USE_LIGHT_PROBES )\n\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t#endif\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n',
                lights_pars_begin: '\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t' + mu.lights_pars_begin
            }, em = new Matrix4(), tm = new Jp({ webGL: !0 }), nm = new Vector3(), im = new Box3(), rm = [], am = [], sm = new Matrix4(), _vector$4 = new Matrix4(), lm = new Vector3(0, 1, 0);
        class cm {
            constructor(REVISION) {
                this.camera = REVISION.camera, this.parent = REVISION.parent, this.cascades = REVISION.cascades || 3, this.maxFar = REVISION.maxFar || 100000, this.mode = REVISION.mode || 'practical', this.shadowMapSize = REVISION.shadowMapSize || 2048, this.shadowBias = REVISION.shadowBias || 0.000001, this.lightDirection = REVISION.lightDirection || new Vector3(1, -1, 1).normalize(), this.lightIntensity = REVISION.lightIntensity || 3, this.lightNear = REVISION.lightNear || 1, this.lightFar = REVISION.lightFar || 2000, this.lightMargin = REVISION.lightMargin || 200, this.customSplitsCallback = REVISION.customSplitsCallback, this.fade = !1, this.mainFrustum = new Jp({ webGL: !0 }), this.frustums = [], this.breaks = [], this.lights = [], this.shaders = new Map(), this.createLights(), this.updateFrustums(), this.injectInclude();
            }
            createLights() {
                for (let REVISION = 0; REVISION < this.cascades; REVISION++) {
                    const REVISION = new DirectionalLight(16777215, this.lightIntensity);
                    REVISION.castShadow = !0, REVISION.shadow.mapSize.width = this.shadowMapSize, REVISION.shadow.mapSize.height = this.shadowMapSize, REVISION.shadow.camera.near = this.lightNear, REVISION.shadow.camera.far = this.lightFar, REVISION.shadow.bias = this.shadowBias, this.parent.add(REVISION), this.parent.add(REVISION.target), this.lights.push(REVISION);
                }
            }
            initCascades() {
                const REVISION = this.camera;
                REVISION.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(REVISION.projectionMatrix, this.maxFar), this.mainFrustum.split(this.breaks, this.frustums);
            }
            updateShadowBounds() {
                const REVISION = this.frustums;
                for (let t = 0; t < REVISION.length; t++) {
                    const REVISION = this.lights[t].shadow.camera, n = this.frustums[t], i = n.vertices.near, r = n.vertices.far, AddEquation = r[0];
                    let SubtractEquation;
                    SubtractEquation = AddEquation.distanceTo(r[2]) > AddEquation.distanceTo(i[2]) ? r[2] : i[2];
                    let ReverseSubtractEquation = AddEquation.distanceTo(SubtractEquation);
                    if (this.fade) {
                        const REVISION = this.camera, t = Math.max(REVISION.far, this.maxFar), i = n.vertices.far[0].z / (t - REVISION.near);
                        ReverseSubtractEquation += 0.25 * Math.pow(i, 2) * (t - REVISION.near);
                    }
                    REVISION.left = -ReverseSubtractEquation / 2, REVISION.right = ReverseSubtractEquation / 2, REVISION.top = ReverseSubtractEquation / 2, REVISION.bottom = -ReverseSubtractEquation / 2, REVISION.updateProjectionMatrix();
                }
            }
            getBreaks() {
                const REVISION = this.camera, t = Math.min(REVISION.far, this.maxFar);
                switch (this.breaks.length = 0, this.mode) {
                case 'uniform':
                    n(this.cascades, REVISION.near, t, this.breaks);
                    break;
                case 'logarithmic':
                    i(this.cascades, REVISION.near, t, this.breaks);
                    break;
                case 'practical':
                    !function (REVISION, t, r, AddEquation, SubtractEquation) {
                        rm.length = 0, am.length = 0, i(REVISION, t, r, am), n(REVISION, t, r, rm);
                        for (let t = 1; t < REVISION; t++)
                            SubtractEquation.push(bt.lerp(rm[t - 1], am[t - 1], AddEquation));
                        SubtractEquation.push(1);
                    }(this.cascades, REVISION.near, t, 0.5, this.breaks);
                    break;
                case 'custom':
                    void 0 === this.customSplitsCallback && console.error('CSM: Custom split scheme callback not defined.'), this.customSplitsCallback(this.cascades, REVISION.near, t, this.breaks);
                }
                function n(REVISION, t, n, i) {
                    for (let r = 1; r < REVISION; r++)
                        i.push((t + (n - t) * r / REVISION) / n);
                    i.push(1);
                }
                function i(REVISION, t, n, i) {
                    for (let r = 1; r < REVISION; r++)
                        i.push(t * (n / t) ** (r / REVISION) / n);
                    i.push(1);
                }
            }
            update() {
                const REVISION = this.camera, t = this.frustums;
                sm.lookAt(new Vector3(), this.lightDirection, lm), _vector$4.copy(sm).invert();
                for (let n = 0; n < t.length; n++) {
                    const i = this.lights[n], r = i.shadow.camera, AddEquation = (r.right - r.left) / this.shadowMapSize, SubtractEquation = (r.top - r.bottom) / this.shadowMapSize;
                    em.multiplyMatrices(_vector$4, REVISION.matrixWorld), t[n].toSpace(em, tm);
                    const ReverseSubtractEquation = tm.vertices.near, ZeroFactor = tm.vertices.far;
                    im.makeEmpty();
                    for (let REVISION = 0; REVISION < 4; REVISION++)
                        im.expandByPoint(ReverseSubtractEquation[REVISION]), im.expandByPoint(ZeroFactor[REVISION]);
                    im.getCenter(nm), nm.z = im.max.z + this.lightMargin, nm.x = Math.floor(nm.x / AddEquation) * AddEquation, nm.y = Math.floor(nm.y / SubtractEquation) * SubtractEquation, nm.applyMatrix4(sm), i.position.copy(nm), i.target.position.copy(nm), i.target.position.x += this.lightDirection.x, i.target.position.y += this.lightDirection.y, i.target.position.z += this.lightDirection.z;
                }
            }
            injectInclude() {
                mu.lights_fragment_begin = $p.lights_fragment_begin, mu.lights_pars_begin = $p.lights_pars_begin;
            }
            setupMaterial(REVISION) {
                REVISION.defines = REVISION.defines || {}, REVISION.defines.USE_CSM = 1, REVISION.defines.CSM_CASCADES = this.cascades, this.fade && (REVISION.defines.CSM_FADE = '');
                const t = [], n = this, i = this.shaders;
                REVISION.onBeforeCompile = function (r) {
                    const AddEquation = Math.min(n.camera.far, n.maxFar);
                    n.getExtendedBreaks(t), r.uniforms.CSM_cascades = { value: t }, r.uniforms.cameraNear = { value: n.camera.near }, r.uniforms.shadowFar = { value: AddEquation }, i.set(REVISION, r);
                }, i.set(REVISION, null);
            }
            updateUniforms() {
                const REVISION = Math.min(this.camera.far, this.maxFar);
                this.shaders.forEach(function (t, n) {
                    if (null !== t) {
                        const n = t.uniforms;
                        this.getExtendedBreaks(n.CSM_cascades.value), n.cameraNear.value = this.camera.near, n.shadowFar.value = REVISION;
                    }
                    !this.fade && 'CSM_FADE' in n.defines ? (delete n.defines.CSM_FADE, n.needsUpdate = !0) : this.fade && !('CSM_FADE' in n.defines) && (n.defines.CSM_FADE = '', n.needsUpdate = !0);
                }, this);
            }
            getExtendedBreaks(REVISION) {
                for (; REVISION.length < this.breaks.length;)
                    REVISION.push(new Vector2());
                REVISION.length = this.breaks.length;
                for (let t = 0; t < this.cascades; t++) {
                    const n = this.breaks[t], i = this.breaks[t - 1] || 0;
                    REVISION[t].x = i, REVISION[t].y = n;
                }
            }
            updateFrustums() {
                this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
            }
            remove() {
                for (let REVISION = 0; REVISION < this.lights.length; REVISION++)
                    this.parent.remove(this.lights[REVISION].target), this.parent.remove(this.lights[REVISION]);
            }
            dispose() {
                const REVISION = this.shaders;
                REVISION.forEach(function (REVISION, t) {
                    delete t.onBeforeCompile, delete t.defines.USE_CSM, delete t.defines.CSM_CASCADES, delete t.defines.CSM_FADE, null !== REVISION && (delete REVISION.uniforms.CSM_cascades, delete REVISION.uniforms.cameraNear, delete REVISION.uniforms.shadowFar), t.needsUpdate = !0;
                }), REVISION.clear();
            }
        }
        var hm;
        !function (REVISION) {
            REVISION[REVISION.ImperialUnitsEnabled = 0] = 'ImperialUnitsEnabled', REVISION[REVISION.ResetHintEnabled = 1] = 'ResetHintEnabled', REVISION[REVISION.GhostCarEnabled = 2] = 'GhostCarEnabled', REVISION[REVISION.DefaultCameraMode = 3] = 'DefaultCameraMode', REVISION[REVISION.CockpitCameraToggle = 4] = 'CockpitCameraToggle', REVISION[REVISION.Checkpoints = 5] = 'Checkpoints', REVISION[REVISION.Timer = 6] = 'Timer', REVISION[REVISION.Speedometer = 7] = 'Speedometer', REVISION[REVISION.Language = 8] = 'Language', REVISION[REVISION.ShadowQuality = 9] = 'ShadowQuality', REVISION[REVISION.CloudsEnabled = 10] = 'CloudsEnabled', REVISION[REVISION.ParticlesEnabled = 11] = 'ParticlesEnabled', REVISION[REVISION.SkidmarksEnabled = 12] = 'SkidmarksEnabled', REVISION[REVISION.RenderScale = 13] = 'RenderScale', REVISION[REVISION.Antialiasing = 14] = 'Antialiasing', REVISION[REVISION.SoundEffectVolume = 15] = 'SoundEffectVolume', REVISION[REVISION.MusicVolume = 16] = 'MusicVolume', REVISION[REVISION.CheckpointVolume = 17] = 'CheckpointVolume', REVISION[REVISION.VibrationEnabled = 18] = 'VibrationEnabled', REVISION[REVISION.TouchSteeringSide = 19] = 'TouchSteeringSide';
        }(hm || (hm = {}));
        const dm = hm, um = JSON.parse('{"rE":"0.5.1","l$":{"r":2,"M":4}}');
        const fm = !1, pm = um.l$.r;
        if (!Number.isSafeInteger(pm) || pm < 1)
            throw new Error('package.json beta version property must be a positive integer');
        let NoColorSpace = '';
        um.rE;
        const gm = um.l$.M;
        if (!Number.isSafeInteger(gm) || gm < 1)
            throw new Error('package.json beta physicsVersion property must be a positive integer');
        var Am, _m, vm, wm, ym, xm, bm, Sm, Em, Mm, Tm, Cm, Im, Rm, Pm, Bm, Dm, Lm, Um, Nm = function (REVISION, t, n, i) {
                return new (n || (n = Promise))(function (r, AddEquation) {
                    function SubtractEquation(REVISION) {
                        try {
                            ZeroFactor(i.next(REVISION));
                        } catch (REVISION) {
                            AddEquation(REVISION);
                        }
                    }
                    function ReverseSubtractEquation(REVISION) {
                        try {
                            ZeroFactor(i.throw(REVISION));
                        } catch (REVISION) {
                            AddEquation(REVISION);
                        }
                    }
                    function ZeroFactor(REVISION) {
                        var t;
                        REVISION.done ? r(REVISION.value) : (t = REVISION.value, t instanceof n ? t : new n(function (REVISION) {
                            REVISION(t);
                        })).then(SubtractEquation, ReverseSubtractEquation);
                    }
                    ZeroFactor((i = i.apply(REVISION, t || [])).next());
                });
            }, km = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, Fm = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class Om {
            constructor(REVISION, t, n = !0, i = !1) {
                var r;
                Am.add(this), _m.set(this, void 0), vm.set(this, void 0), wm.set(this, void 0), ym.set(this, void 0), xm.set(this, new PerspectiveCamera()), bm.set(this, null), Sm.set(this, null), Em.set(this, []), Mm.set(this, null), Tm.set(this, new Vector3(8, 10, 10)), Cm.set(this, []), Im.set(this, []), km(this, _m, REVISION, 'f'), km(this, vm, t, 'f'), km(this, wm, new Kp({
                    antialias: null === (r = null == t ? void 0 : t.getSettingBoolean(dm.Antialiasing)) || void 0 === r || r,
                    powerPreference: 'high-performance',
                    canvas: REVISION,
                    alpha: i
                }), 'f'), Fm(this, wm, 'f').outputColorSpace = LinearSRGBColorSpace, Fm(this, wm, 'f').debug.checkShaderErrors = fm, km(this, ym, new _r(), 'f'), n && (Fm(this, ym, 'f').fog = new Fog(10211839, 0, Om.maxViewDistance)), Fm(this, ym, 'f').add(new HemisphereLight(3891597, 11714755, 4.7)), document.addEventListener('fullscreenchange', () => {
                    Fm(this, Am, 'm', Lm).call(this);
                }), Fm(this, _m, 'f').addEventListener('webglcontextrestored', () => {
                    for (const REVISION of Fm(this, Im, 'f'))
                        REVISION();
                }), null != window.electron && window.electron.addFullscreenChangeListener(() => {
                    Fm(this, Am, 'm', Lm).call(this);
                });
            }
            clear() {
                Fm(this, wm, 'f').clear();
            }
            update(REVISION) {
                var t, n, i;
                Fm(this, Tm, 'f').copy(REVISION.getSunPosition());
                let r = null !== (n = null === (t = Fm(this, vm, 'f')) || void 0 === t ? void 0 : t.getSettingInteger(dm.ShadowQuality)) && void 0 !== n ? n : 0;
                if (this.isShadowQualitySupported(r) || (r = 0), !Number.isSafeInteger(r) || r <= 2 || r > 5)
                    if (null != Fm(this, bm, 'f') && (Fm(this, bm, 'f').remove(), Fm(this, bm, 'f').dispose(), km(this, bm, null, 'f'), km(this, Sm, null, 'f')), null == Fm(this, Mm, 'f') && (km(this, Mm, new DirectionalLight(16777215, 4.7), 'f'), Fm(this, Mm, 'f').position.copy(Fm(this, Tm, 'f')), Fm(this, ym, 'f').add(Fm(this, Mm, 'f')), Fm(this, ym, 'f').add(Fm(this, Mm, 'f').target)), 1 == r || 2 == r) {
                        if (!Fm(this, Mm, 'f').castShadow) {
                            const REVISION = Fm(this, Am, 'm', Dm).call(this, r);
                            Fm(this, Mm, 'f').castShadow = !0, Fm(this, Mm, 'f').shadow.camera.top = 10, Fm(this, Mm, 'f').shadow.camera.right = 10, Fm(this, Mm, 'f').shadow.camera.bottom = -10, Fm(this, Mm, 'f').shadow.camera.left = -10, Fm(this, Mm, 'f').shadow.camera.near = 1, Fm(this, Mm, 'f').shadow.camera.far = 50, Fm(this, Mm, 'f').shadow.mapSize.width = REVISION, Fm(this, Mm, 'f').shadow.mapSize.height = REVISION, Fm(this, Mm, 'f').shadow.normalBias = 0.03, Fm(this, Mm, 'f').shadow.intensity = 0.6;
                        }
                        Fm(this, Mm, 'f').position.addVectors(Fm(this, xm, 'f').position, Fm(this, Tm, 'f').multiplyScalar(12.5)), Fm(this, Mm, 'f').target.position.copy(Fm(this, xm, 'f').position), Fm(this, wm, 'f').shadowMap.type = 1, Fm(this, wm, 'f').shadowMap.enabled = !0;
                    } else
                        Fm(this, Mm, 'f').castShadow = !1, null === (i = Fm(this, Mm, 'f').shadow.map) || void 0 === i || i.dispose(), Fm(this, Mm, 'f').shadow.map = null, Fm(this, wm, 'f').shadowMap.enabled = !1;
                else {
                    if (null != Fm(this, bm, 'f') && Fm(this, Sm, 'f') != r && (Fm(this, bm, 'f').remove(), Fm(this, bm, 'f').dispose(), km(this, bm, null, 'f'), km(this, Sm, null, 'f'), Fm(this, wm, 'f').compile(Fm(this, ym, 'f'), Fm(this, xm, 'f'))), null == Fm(this, bm, 'f')) {
                        Fm(this, wm, 'f').shadowMap.enabled = !0, Fm(this, wm, 'f').shadowMap.type = 2, km(this, bm, Fm(this, Am, 'm', Rm).call(this, r), 'f'), km(this, Sm, r, 'f');
                        for (const {
                                    material: REVISION,
                                    onBeforeCompile: t,
                                    customProgramCacheKey: n
                                } of Fm(this, Em, 'f'))
                            Fm(this, Am, 'm', Bm).call(this, REVISION, t, n);
                    }
                    null != Fm(this, Mm, 'f') && (Fm(this, ym, 'f').remove(Fm(this, Mm, 'f')), Fm(this, ym, 'f').remove(Fm(this, Mm, 'f').target), km(this, Mm, null, 'f')), Fm(this, bm, 'f').lightDirection = Fm(this, Tm, 'f').clone().negate().normalize(), Fm(this, bm, 'f').update();
                }
                Fm(this, Am, 'm', Pm).call(this), Fm(this, wm, 'f').render(Fm(this, ym, 'f'), Fm(this, xm, 'f'));
            }
            addMaterial(REVISION) {
                const t = Array.isArray(REVISION) ? REVISION : [REVISION];
                for (const REVISION of t) {
                    const t = REVISION.onBeforeCompile.bind(REVISION), n = REVISION.onBeforeCompile.toString();
                    Fm(this, Em, 'f').push({
                        material: REVISION,
                        onBeforeCompile: t,
                        customProgramCacheKey: n
                    }), null != Fm(this, bm, 'f') && Fm(this, Am, 'm', Bm).call(this, REVISION, t, n);
                }
            }
            removeMaterial(REVISION) {
                if (Array.isArray(REVISION))
                    for (const t of REVISION) {
                        const REVISION = Fm(this, Em, 'f').findIndex(REVISION => REVISION.material == t);
                        REVISION >= 0 && Fm(this, Em, 'f').splice(REVISION, 1);
                    }
                else {
                    const t = Fm(this, Em, 'f').findIndex(t => t.material == REVISION);
                    t >= 0 && Fm(this, Em, 'f').splice(t, 1);
                }
            }
            isTrackShadowsEnabled() {
                var REVISION, t;
                const n = null !== (t = null === (REVISION = Fm(this, vm, 'f')) || void 0 === REVISION ? void 0 : REVISION.getSettingInteger(dm.ShadowQuality)) && void 0 !== t ? t : 0;
                return 3 == n || 4 == n || 5 == n;
            }
            isShadowQualitySupported(REVISION) {
                return !Number.isSafeInteger(REVISION) || REVISION <= 0 || REVISION > 5 || Fm(this, wm, 'f').capabilities.maxTextureSize >= Fm(this, Am, 'm', Dm).call(this, REVISION);
            }
            getMaxAnisotropy() {
                return Fm(this, wm, 'f').capabilities.getMaxAnisotropy();
            }
            get isFullscreen() {
                return null != window.electron ? window.electron.isFullscreen() : null != document.fullscreenElement;
            }
            toggleFullscreen() {
                return Nm(this, void 0, void 0, function* () {
                    this.isFullscreen ? null != window.electron ? window.electron.setFullscreen(!1) : yield document.exitFullscreen() : null != window.electron ? window.electron.setFullscreen(!0) : yield document.body.requestFullscreen();
                });
            }
            addFullscreenChangeListener(REVISION) {
                Fm(this, Cm, 'f').push(REVISION);
            }
            removeFullscreenChangeListener(REVISION) {
                const t = Fm(this, Cm, 'f').indexOf(REVISION);
                t >= 0 && Fm(this, Cm, 'f').splice(t, 1);
            }
            addContextRestoredEventListener(REVISION) {
                Fm(this, Im, 'f').push(REVISION);
            }
            removeContextRestoredEventListener(REVISION) {
                const t = Fm(this, Im, 'f').indexOf(REVISION);
                t >= 0 && Fm(this, Im, 'f').splice(t, 1);
            }
            get csm() {
                return Fm(this, bm, 'f');
            }
            setCamera(REVISION) {
                km(this, xm, REVISION, 'f'), null != Fm(this, bm, 'f') && (Fm(this, bm, 'f').camera = REVISION, Fm(this, Am, 'm', Um).call(this));
            }
            get camera() {
                return Fm(this, xm, 'f');
            }
            get canvas() {
                return Fm(this, _m, 'f');
            }
            setAnimationLoop(REVISION) {
                Fm(this, wm, 'f').setAnimationLoop(REVISION);
            }
            get scene() {
                return Fm(this, ym, 'f');
            }
        }
        _m = new WeakMap(), vm = new WeakMap(), wm = new WeakMap(), ym = new WeakMap(), xm = new WeakMap(), bm = new WeakMap(), Sm = new WeakMap(), Em = new WeakMap(), Mm = new WeakMap(), Tm = new WeakMap(), Cm = new WeakMap(), Im = new WeakMap(), Am = new WeakSet(), Rm = function (REVISION) {
            if (3 != REVISION && 4 != REVISION && 5 != REVISION)
                throw new Error('Unsupported shadow quality: ' + REVISION.toString());
            const t = Fm(this, Am, 'm', Dm).call(this, REVISION);
            let n, i;
            switch (REVISION) {
            case 5:
                n = 2000;
                break;
            case 4:
                n = 1000;
                break;
            case 3:
                n = 500;
            }
            switch (REVISION) {
            case 5:
                i = 5;
                break;
            case 4:
            case 3:
                i = 4;
            }
            const r = new cm({
                maxFar: n,
                lightFar: 15000,
                lightNear: 10,
                lightMargin: 5000,
                cascades: i,
                mode: 'custom',
                customSplitsCallback: (t, n, i, r) => {
                    5 == REVISION ? (r.push((15 - n) / i), r.push((40 - n) / i), r.push((150 - n) / i), r.push((500 - n) / i), r.push(1)) : 4 == REVISION ? (r.push((15 - n) / i), r.push((80 - n) / i), r.push((300 - n) / i), r.push(1)) : (r.push((15 - n) / i), r.push((60 - n) / i), r.push((150 - n) / i), r.push(1));
                },
                parent: Fm(this, ym, 'f'),
                shadowMapSize: t,
                lightDirection: new Vector3(0, 0, -1),
                lightIntensity: 4.7,
                camera: Fm(this, xm, 'f')
            });
            r.fade = !0, 5 == REVISION ? (r.lights[0].shadow.normalBias = 0.025, r.lights[1].shadow.normalBias = 0.04, r.lights[2].shadow.normalBias = 0.11, r.lights[3].shadow.normalBias = 0.32, r.lights[4].shadow.normalBias = 1.25) : 4 == REVISION ? (r.lights[0].shadow.normalBias = 0.041, r.lights[1].shadow.normalBias = 0.13, r.lights[2].shadow.normalBias = 0.48, r.lights[3].shadow.normalBias = 1.25) : (r.lights[0].shadow.normalBias = 0.08, r.lights[1].shadow.normalBias = 0.21, r.lights[2].shadow.normalBias = 0.6, r.lights[3].shadow.normalBias = 1.9);
            for (const REVISION of r.lights)
                REVISION.shadow.intensity = 0.6;
            return r;
        }, Pm = function () {
            var REVISION, t;
            let n = null !== (t = null === (REVISION = Fm(this, vm, 'f')) || void 0 === REVISION ? void 0 : REVISION.getSettingFloat(dm.RenderScale)) && void 0 !== t ? t : 1;
            n = Number.isFinite(n) ? Math.min(Math.max(n, 0.25), 2) : 1;
            const i = window.devicePixelRatio * n;
            if (Fm(this, wm, 'f').getPixelRatio() != i && Fm(this, wm, 'f').setPixelRatio(i), Fm(this, xm, 'f') instanceof PerspectiveCamera) {
                const REVISION = window.innerWidth / window.innerHeight, t = new Vector2();
                Fm(this, wm, 'f').getSize(t);
                const n = Math.max(1, 0.5 * REVISION);
                t.width == window.innerWidth && t.height == window.innerHeight && Fm(this, xm, 'f').aspect == REVISION && Fm(this, xm, 'f').zoom == n || (Fm(this, wm, 'f').setSize(window.innerWidth, window.innerHeight), Fm(this, xm, 'f').aspect = REVISION, Fm(this, xm, 'f').zoom = n, Fm(this, Am, 'm', Um).call(this), Fm(this, xm, 'f').updateProjectionMatrix());
            }
        }, Bm = function (REVISION, t, n) {
            var i;
            const r = Array.isArray(REVISION) ? REVISION : [REVISION];
            for (const REVISION of r) {
                null === (i = Fm(this, bm, 'f')) || void 0 === i || i.setupMaterial(REVISION);
                const r = REVISION.onBeforeCompile.toString(), AddEquation = REVISION.onBeforeCompile.bind(REVISION);
                REVISION.onBeforeCompile = (REVISION, n) => {
                    AddEquation(REVISION, n), t(REVISION, n);
                }, REVISION.customProgramCacheKey = () => r + n, REVISION.needsUpdate = !0;
            }
        }, Dm = function (REVISION) {
            switch (REVISION) {
            case 5:
                return 8192;
            case 4:
                return 4096;
            case 3:
                return 2048;
            case 2:
            case 1:
                return 1024;
            default:
                throw new Error('Unsupported shadow quality: ' + REVISION.toString());
            }
        }, Lm = function () {
            for (const REVISION of Fm(this, Cm, 'f'))
                REVISION();
        }, Um = function () {
            if (null != Fm(this, bm, 'f'))
                if (Fm(this, xm, 'f') instanceof PerspectiveCamera) {
                    const REVISION = Fm(this, xm, 'f').fov;
                    Fm(this, xm, 'f').fov = 100, Fm(this, bm, 'f').updateFrustums(), Fm(this, xm, 'f').fov = REVISION;
                } else
                    Fm(this, bm, 'f').updateFrustums();
        }, Om.maxViewDistance = 10000;
        const zm = Om;
        var Hm, Wm, Vm, Gm, Qm, Xm = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class jm {
            constructor() {
                Hm.add(this), Gm.set(this, new PerspectiveCamera(Xm(Wm, Wm, 'f', Vm), 1, 0.5, zm.maxViewDistance));
            }
            reset(REVISION, t, n) {
                this.update(REVISION, t, 0), Xm(this, Gm, 'f').fov = Xm(this, Hm, 'm', Qm).call(this, null != n ? n : 0), Xm(this, Gm, 'f').updateProjectionMatrix();
            }
            update(REVISION, t, n) {
                Xm(this, Gm, 'f').fov = Xm(this, Hm, 'm', Qm).call(this, n), Xm(this, Gm, 'f').updateProjectionMatrix();
                const i = new Vector3(0, 1.1 + 0.46 / Xm(this, Gm, 'f').zoom - 0.46, 0.4);
                Xm(this, Gm, 'f').position.addVectors(REVISION, i.applyQuaternion(t)), Xm(this, Gm, 'f').quaternion.copy(t), Xm(this, Gm, 'f').quaternion.multiply(new Quaternion().setFromEuler(new Euler(0, Math.PI, 0))), Xm(this, Gm, 'f').updateMatrix();
            }
            get camera() {
                return Xm(this, Gm, 'f');
            }
        }
        Wm = jm, Gm = new WeakMap(), Hm = new WeakSet(), Qm = function (REVISION) {
            return Xm(Wm, Wm, 'f', Vm) + (80 - Xm(Wm, Wm, 'f', Vm)) * (1 - Math.exp(-Math.abs(REVISION) / 200));
        }, Vm = { value: 70 };
        const qm = jm;
        class Ym {
            constructor(REVISION, t, n, i) {
                this.primary = REVISION, this.secondary = t, this.frame = n, this.rims = i;
            }
            static random() {
                const REVISION = 360 * Math.random(), t = 100 * (1 - Math.pow(Math.random(), 2)), n = 100 * (0.05 + 0.25 * (1 - Math.pow(Math.random(), 2)));
                return new Ym(new Color('hsl(' + REVISION.toString() + ',' + t.toString() + '%,' + n.toString() + '%)'), new Color('#ffffff'), new Color('#131313'), new Color('#666666'));
            }
            serialize() {
                return this.primary.getHexString() + this.secondary.getHexString() + this.frame.getHexString() + this.rims.getHexString();
            }
            static deserialize(REVISION) {
                const t = [];
                for (let n = 0; n < 4; n++) {
                    const i = REVISION.substring(6 * n, 6 * (n + 1));
                    /^[0-9a-f]{6}$/i.test(i) ? t.push(new Color('#' + i)) : t.push(new Color('#555'));
                }
                return new Ym(t[0], t[1], t[2], t[3]);
            }
        }
        const Km = Ym;
        var Zm, Jm, $m, eg, tg, ng, ig, rg = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, ag = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class sg {
            constructor() {
                Zm.add(this), eg.set(this, new PerspectiveCamera(ag(Jm, Jm, 'f', $m), 1, 0.5, 10000)), tg.set(this, new Vector3()), ng.set(this, new Vector3(0, 1, 0));
            }
            reset(REVISION, t, n) {
                rg(this, tg, new Vector3(0.00001, 0, -1), 'f'), ag(this, tg, 'f').applyQuaternion(t), ag(this, tg, 'f').add(REVISION), rg(this, ng, new Vector3(0, 1, 0), 'f'), ag(this, ng, 'f').applyQuaternion(t), this.update(0, REVISION, t, 0), ag(this, eg, 'f').fov = ag(this, Zm, 'm', ig).call(this, null != n ? n : 0), ag(this, eg, 'f').updateProjectionMatrix();
            }
            update(REVISION, t, n, i) {
                ag(this, eg, 'f').fov = ag(this, Zm, 'm', ig).call(this, i), ag(this, eg, 'f').updateProjectionMatrix();
                const r = new Vector3(0, 1, 0);
                r.applyQuaternion(n);
                const AddEquation = Math.min(1, 5 * REVISION);
                ag(this, ng, 'f').set(AddEquation * r.x + (1 - AddEquation) * ag(this, ng, 'f').x, AddEquation * r.y + (1 - AddEquation) * ag(this, ng, 'f').y, AddEquation * r.z + (1 - AddEquation) * ag(this, ng, 'f').z);
                const SubtractEquation = new Vector3().subVectors(t, ag(this, tg, 'f'));
                SubtractEquation.normalize();
                const ReverseSubtractEquation = 5.5, ZeroFactor = 1.8 / Math.min(ag(this, eg, 'f').zoom, 2);
                ag(this, eg, 'f').position.x = t.x - SubtractEquation.x * ReverseSubtractEquation + 2 * ag(this, ng, 'f').x, ag(this, eg, 'f').position.y = Math.max(0.25, t.y - SubtractEquation.y * ReverseSubtractEquation + 2 * ag(this, ng, 'f').y), ag(this, eg, 'f').position.z = t.z - SubtractEquation.z * ReverseSubtractEquation + 2 * ag(this, ng, 'f').z, ag(this, eg, 'f').lookAt(t.x + ag(this, ng, 'f').x * ZeroFactor, t.y + ag(this, ng, 'f').y * ZeroFactor, t.z + ag(this, ng, 'f').z * ZeroFactor), ag(this, eg, 'f').updateMatrix(), ag(this, tg, 'f').set(t.x - SubtractEquation.x * ReverseSubtractEquation, t.y - SubtractEquation.y * ReverseSubtractEquation, t.z - SubtractEquation.z * ReverseSubtractEquation);
            }
            get camera() {
                return ag(this, eg, 'f');
            }
        }
        Jm = sg, eg = new WeakMap(), tg = new WeakMap(), ng = new WeakMap(), Zm = new WeakSet(), ig = function (REVISION) {
            return ag(Jm, Jm, 'f', $m) + (100 - ag(Jm, Jm, 'f', $m)) * (1 - Math.exp(-Math.abs(REVISION) / 200));
        }, $m = { value: 70 };
        const og = sg;
        var lg, cg, hg, dg, ug, fg, pg, mg, gg = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, Ag = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class _g {
            constructor(REVISION) {
                cg.set(this, void 0), hg.set(this, void 0), dg.set(this, []), ug.set(this, 256), fg.set(this, new Vector3(0, 1, 0)), gg(this, cg, REVISION, 'f'), gg(this, hg, new InstancedMesh(Ag(lg, lg, 'f', pg), Ag(lg, lg, 'f', mg), Ag(this, ug, 'f')), 'f'), Ag(this, hg, 'f').frustumCulled = !1, REVISION.scene.add(Ag(this, hg, 'f')), this.clear();
            }
            dispose() {
                Ag(this, hg, 'f').dispose(), Ag(this, cg, 'f').scene.remove(Ag(this, hg, 'f'));
            }
            clear() {
                Ag(this, dg, 'f').length = 0, Ag(this, hg, 'f').count = 0, Ag(this, hg, 'f').instanceMatrix.needsUpdate = !0;
            }
            spawn(REVISION, t, n) {
                Ag(this, dg, 'f').push({
                    x: REVISION + 0.25 * (Math.random() - 0.5),
                    y: t + 0.25 * (Math.random() - 0.5),
                    z: n + 0.25 * (Math.random() - 0.5),
                    vx: 0.5 * (Math.random() - 0.5),
                    vy: 0.5 * (Math.random() - 0.5),
                    vz: 0.5 * (Math.random() - 0.5),
                    rotation: Math.random() * Math.PI * 2,
                    lifetime: 0.5
                });
            }
            update(REVISION) {
                for (let t = Ag(this, dg, 'f').length - 1; t >= 0; --t) {
                    const n = Ag(this, dg, 'f')[t];
                    n.vy += 15 * REVISION, n.x += n.vx * REVISION, n.y += n.vy * REVISION, n.z += n.vz * REVISION, n.lifetime -= REVISION, n.lifetime <= 0 && Ag(this, dg, 'f').splice(t, 1);
                }
                let t = !1;
                Ag(this, hg, 'f').count != Ag(this, dg, 'f').length && (Ag(this, hg, 'f').count = Math.min(Ag(this, dg, 'f').length, Ag(this, ug, 'f')), t = !0);
                for (let REVISION = 0; REVISION < Ag(this, hg, 'f').count; ++REVISION) {
                    const t = Ag(this, dg, 'f')[Ag(this, dg, 'f').length - 1 - REVISION], n = new Matrix4();
                    n.lookAt(new Vector3(t.x, t.y, t.z), Ag(this, cg, 'f').camera.position, Ag(this, fg, 'f')), n.setPosition(t.x, t.y, t.z), n.multiply(new Matrix4().makeRotationZ(t.rotation));
                    const i = 0.5 + 2 * (0.5 - t.lifetime);
                    n.scale(new Vector3(i, i, i)), Ag(this, hg, 'f').setMatrixAt(REVISION, n);
                }
                (t || Ag(this, dg, 'f').length > 0) && (Ag(this, hg, 'f').instanceMatrix.needsUpdate = !0);
            }
            static initResources(REVISION) {
                REVISION.addResource();
                const t = new AudioLoader().load('images/smoke.png', () => {
                    REVISION.loadedResource();
                });
                Ag(this, lg, 'f', mg).map = t;
            }
        }
        lg = _g, cg = new WeakMap(), hg = new WeakMap(), dg = new WeakMap(), ug = new WeakMap(), fg = new WeakMap(), pg = {
            value: (() => {
                const REVISION = new TorusKnotGeometry();
                return REVISION.rotateX(Math.PI), REVISION;
            })()
        }, mg = {
            value: new Si({
                opacity: 0.3,
                depthWrite: !1,
                transparent: !0
            })
        };
        const vg = _g;
        var wg, yg, xg, bg, Sg, Eg, Mg, Tg, Cg, Ig, Rg = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, Pg = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class Bg {
            constructor(REVISION) {
                yg.set(this, void 0), xg.set(this, void 0), bg.set(this, void 0), Sg.set(this, void 0), Eg.set(this, 1000), Mg.set(this, 0), Tg.set(this, null), Cg.set(this, null), Rg(this, yg, REVISION, 'f');
                const t = new BufferGeometry();
                Rg(this, bg, new Float32Array(6 * Pg(this, Eg, 'f') * 3), 'f'), Rg(this, Sg, new BufferAttribute(Pg(this, bg, 'f'), 3), 'f'), t.setAttribute('position', Pg(this, Sg, 'f')), Rg(this, xg, new Mesh(t, Pg(wg, wg, 'f', Ig)), 'f'), Pg(this, xg, 'f').frustumCulled = !1, Pg(this, yg, 'f').scene.add(Pg(this, xg, 'f'));
            }
            dispose() {
                Pg(this, xg, 'f').geometry.dispose(), Pg(this, yg, 'f').scene.remove(Pg(this, xg, 'f'));
            }
            clear() {
                for (let REVISION = 0; REVISION < Pg(this, bg, 'f').length; ++REVISION)
                    Pg(this, bg, 'f')[REVISION] = 0;
                Pg(this, Sg, 'f').needsUpdate = !0, Rg(this, Mg, 0, 'f'), this.break();
            }
            break() {
                Rg(this, Tg, null, 'f'), Rg(this, Cg, null, 'f');
            }
            spawn(REVISION, t, n, i) {
                var r, AddEquation;
                const SubtractEquation = Pg(this, Tg, 'f'), ReverseSubtractEquation = Pg(this, Cg, 'f'), ZeroFactor = new Vector3().addVectors(REVISION, new Vector3(0.172, -0.3, 0).applyQuaternion(t)), OneFactor = new Vector3().addVectors(REVISION, new Vector3(-0.172, -0.3, 0).applyQuaternion(t)), SrcColorFactor = new Vector3().copy(ZeroFactor), OneMinusSrcColorFactor = new Vector3().copy(OneFactor), SrcAlphaFactor = new Vector3().subVectors(ZeroFactor, n).dot(i);
                SrcColorFactor.addScaledVector(i, -SrcAlphaFactor);
                const OneMinusSrcAlphaFactor = new Vector3().subVectors(OneFactor, n).dot(i);
                if (OneMinusSrcColorFactor.addScaledVector(i, -OneMinusSrcAlphaFactor), null != SubtractEquation && null != ReverseSubtractEquation) {
                    const REVISION = (Rg(this, Mg, (AddEquation = Pg(this, Mg, 'f'), r = AddEquation++, AddEquation), 'f'), r);
                    Pg(this, bg, 'f')[6 * REVISION * 3 + 0] = SrcColorFactor.x, Pg(this, bg, 'f')[6 * REVISION * 3 + 1] = SrcColorFactor.y, Pg(this, bg, 'f')[6 * REVISION * 3 + 2] = SrcColorFactor.z, Pg(this, bg, 'f')[6 * REVISION * 3 + 3] = SubtractEquation.x, Pg(this, bg, 'f')[6 * REVISION * 3 + 4] = SubtractEquation.y, Pg(this, bg, 'f')[6 * REVISION * 3 + 5] = SubtractEquation.z, Pg(this, bg, 'f')[6 * REVISION * 3 + 6] = OneMinusSrcColorFactor.x, Pg(this, bg, 'f')[6 * REVISION * 3 + 7] = OneMinusSrcColorFactor.y, Pg(this, bg, 'f')[6 * REVISION * 3 + 8] = OneMinusSrcColorFactor.z, Pg(this, bg, 'f')[6 * REVISION * 3 + 9] = OneMinusSrcColorFactor.x, Pg(this, bg, 'f')[6 * REVISION * 3 + 10] = OneMinusSrcColorFactor.y, Pg(this, bg, 'f')[6 * REVISION * 3 + 11] = OneMinusSrcColorFactor.z, Pg(this, bg, 'f')[6 * REVISION * 3 + 12] = SubtractEquation.x, Pg(this, bg, 'f')[6 * REVISION * 3 + 13] = SubtractEquation.y, Pg(this, bg, 'f')[6 * REVISION * 3 + 14] = SubtractEquation.z, Pg(this, bg, 'f')[6 * REVISION * 3 + 15] = ReverseSubtractEquation.x, Pg(this, bg, 'f')[6 * REVISION * 3 + 16] = ReverseSubtractEquation.y, Pg(this, bg, 'f')[6 * REVISION * 3 + 17] = ReverseSubtractEquation.z, Pg(this, Sg, 'f').needsUpdate = !0, Pg(this, Mg, 'f') >= Pg(this, Eg, 'f') - 1 && Rg(this, Mg, 0, 'f');
                }
                Rg(this, Tg, SrcColorFactor, 'f'), Rg(this, Cg, OneMinusSrcColorFactor, 'f');
            }
        }
        wg = Bg, yg = new WeakMap(), xg = new WeakMap(), bg = new WeakMap(), Sg = new WeakMap(), Eg = new WeakMap(), Mg = new WeakMap(), Tg = new WeakMap(), Cg = new WeakMap(), Ig = {
            value: new Si({
                color: 1118481,
                side: 2,
                polygonOffset: !0,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: 0
            })
        };
        const Dg = Bg;
        var Lg, Ug, Ng, kg, Fg, Og, zg, Hg, Wg, Vg, Gg, Qg, Xg, jg, qg, Yg, Kg, Zg, Jg, $g, eA, tA, nA, iA, rA, aA, sA, oA, lA, cA, hA, dA, uA, fA, pA, mA, gA, AA, _A, vA, wA, yA, xA, bA, SA, EA, MA, TA, CA, IA, RA, PA, BA, DA, LA, UA, NA, kA, FA, OA, zA, HA, WA = function (REVISION, t, n, i) {
                return new (n || (n = Promise))(function (r, AddEquation) {
                    function SubtractEquation(REVISION) {
                        try {
                            ZeroFactor(i.next(REVISION));
                        } catch (REVISION) {
                            AddEquation(REVISION);
                        }
                    }
                    function ReverseSubtractEquation(REVISION) {
                        try {
                            ZeroFactor(i.throw(REVISION));
                        } catch (REVISION) {
                            AddEquation(REVISION);
                        }
                    }
                    function ZeroFactor(REVISION) {
                        var t;
                        REVISION.done ? r(REVISION.value) : (t = REVISION.value, t instanceof n ? t : new n(function (REVISION) {
                            REVISION(t);
                        })).then(SubtractEquation, ReverseSubtractEquation);
                    }
                    ZeroFactor((i = i.apply(REVISION, t || [])).next());
                });
            }, VA = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, GA = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class QA {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor) {
                var OneFactor;
                if (Lg.add(this), Ng.set(this, void 0), kg.set(this, null), Fg.set(this, 1), Og.set(this, null), zg.set(this, []), Hg.set(this, null), Wg.set(this, null), Vg.set(this, null), Gg.set(this, []), this.notificationAudioEnabled = !1, Qg.set(this, void 0), Xg.set(this, void 0), jg.set(this, void 0), qg.set(this, !1), Yg.set(this, void 0), Kg.set(this, void 0), Zg.set(this, void 0), Jg.set(this, void 0), nA.set(this, []), iA.set(this, []), rA.set(this, []), aA.set(this, [
                        0,
                        0,
                        0,
                        0
                    ]), sA.set(this, [
                        0,
                        0,
                        0,
                        0
                    ]), oA.set(this, [
                        0,
                        0,
                        0,
                        0
                    ]), lA.set(this, void 0), cA.set(this, void 0), hA.set(this, null), dA.set(this, null), uA.set(this, []), fA.set(this, null), pA.set(this, void 0), mA.set(this, void 0), gA.set(this, void 0), AA.set(this, void 0), _A.set(this, void 0), vA.set(this, void 0), wA.set(this, []), yA.set(this, null), xA.set(this, [
                        0.075,
                        0.075,
                        0.075,
                        0.075
                    ]), bA.set(this, void 0), SA.set(this, null), EA.set(this, void 0), MA.set(this, !1), VA(this, Ng, AddEquation, 'f'), VA(this, lA, r, 'f'), VA(this, AA, SubtractEquation, 'f'), VA(this, _A, ReverseSubtractEquation, 'f'), VA(this, vA, ZeroFactor, 'f'), VA(this, jg, REVISION, 'f'), (null == ZeroFactor ? void 0 : ZeroFactor.getSettingBoolean(dm.ParticlesEnabled)) ? VA(this, bA, new vg(r), 'f') : VA(this, bA, null, 'f'), null != GA(this, AA, 'f') && null != GA(this, _A, 'f') && VA(this, wA, [
                        new Dg(GA(this, lA, 'f')),
                        new Dg(GA(this, lA, 'f')),
                        new Dg(GA(this, lA, 'f')),
                        new Dg(GA(this, lA, 'f'))
                    ], 'f'), VA(this, Qg, new og(), 'f'), GA(this, Qg, 'f').reset(t.position, t.quaternion), r.scene.add(GA(this, Qg, 'f').camera), VA(this, Xg, new qm(), 'f'), GA(this, Xg, 'f').reset(t.position, t.quaternion), r.scene.add(GA(this, Xg, 'f').camera), null == Ug.models)
                    throw new Error('Car model isn\'t loaded yet');
                if (null != GA(this, jg, 'f') && null != GA(this, AA, 'f') && null != GA(this, _A, 'f'))
                    VA(this, Yg, GA(this, jg, 'f').createCar(t, GA(this, AA, 'f').getMountainVertices(), GA(this, AA, 'f').getMountainOffset(), GA(this, _A, 'f').getTrackData(), n, REVISION => {
                        this.setCarState(REVISION);
                    }), 'f');
                else {
                    const REVISION = [
                            new Vector3(0.627909, 0.27 - Ug.suspensionResetLengthFront, 1.3478).applyQuaternion(t.quaternion).add(t.position),
                            new Vector3(-0.627909, 0.27 - Ug.suspensionResetLengthFront, 1.3478).applyQuaternion(t.quaternion).add(t.position),
                            new Vector3(0.720832, 0.27 - Ug.suspensionResetLengthRear, -1.52686).applyQuaternion(t.quaternion).add(t.position),
                            new Vector3(-0.720832, 0.27 - Ug.suspensionResetLengthRear, -1.52686).applyQuaternion(t.quaternion).add(t.position)
                        ], n = [
                            new Quaternion().setFromEuler(new Euler().set(0, Math.PI, 0)).multiply(t.quaternion),
                            new Quaternion().setFromEuler(new Euler().set(0, Math.PI, 0)).multiply(t.quaternion),
                            new Quaternion().setFromEuler(new Euler().set(0, Math.PI, 0)).multiply(t.quaternion),
                            new Quaternion().setFromEuler(new Euler().set(0, Math.PI, 0)).multiply(t.quaternion)
                        ];
                    VA(this, Yg, {
                        id: 0,
                        frames: 0,
                        speedKmh: 0,
                        hasStarted: !1,
                        finishFrames: null,
                        nextCheckpointIndex: 0,
                        hasCheckpointToRespawnAt: !1,
                        position: {
                            x: t.position.x,
                            y: t.position.y,
                            z: t.position.z
                        },
                        quaternion: {
                            x: t.quaternion.x,
                            y: t.quaternion.y,
                            z: t.quaternion.z,
                            w: t.quaternion.w
                        },
                        collisionImpulses: [],
                        wheelContact: [
                            null,
                            null,
                            null,
                            null
                        ],
                        wheelSuspensionLength: [
                            Ug.suspensionResetLengthFront,
                            Ug.suspensionResetLengthFront,
                            Ug.suspensionResetLengthRear,
                            Ug.suspensionResetLengthRear
                        ],
                        wheelSuspensionVelocity: [
                            0,
                            0,
                            0,
                            0
                        ],
                        wheelRotation: [
                            0,
                            0,
                            0,
                            0
                        ],
                        wheelDeltaRotation: [
                            0,
                            0,
                            0,
                            0
                        ],
                        wheelSkidInfo: [
                            0,
                            0,
                            0,
                            0
                        ],
                        wheelPosition: REVISION,
                        wheelQuaternion: n,
                        brakeLightEnabled: !1,
                        controls: {
                            up: !1,
                            right: !1,
                            down: !1,
                            left: !1,
                            reset: !1
                        }
                    }, 'f');
                }
                if (VA(this, Kg, i, 'f'), null == n)
                    VA(this, Zg, null != GA(this, Kg, 'f'), 'f'), VA(this, Jg, new Sh(), 'f');
                else {
                    if (null != GA(this, Kg, 'f'))
                        throw new Error('Can\'t control car when recording is set');
                    VA(this, Zg, !1, 'f'), VA(this, Jg, n, 'f');
                }
                VA(this, gA, Km.random(), 'f'), VA(this, pA, Ug.createTexture(r), 'f'), VA(this, mA, { value: new Vector3(0, 0, 0) }, 'f'), VA(this, cA, new pr(), 'f'), GA(this, cA, 'f').add(Ug.models.chassis.clone()), GA(this, cA, 'f').add(Ug.models.suspension.clone()), GA(this, cA, 'f').add(Ug.models.wheelFL.clone()), GA(this, cA, 'f').add(Ug.models.wheelFR.clone()), GA(this, cA, 'f').add(Ug.models.wheelBL.clone()), GA(this, cA, 'f').add(Ug.models.wheelBR.clone());
                for (const REVISION of GA(this, cA, 'f').children) {
                    const t = REVISION;
                    let n;
                    Array.isArray(t.material) ? (n = t.material.map(REVISION => REVISION.clone()), t.material = n) : (n = [t.material.clone()], t.material = n[0]);
                    for (const REVISION of n)
                        if ('Main' == REVISION.name)
                            REVISION.onBeforeCompile = REVISION => {
                                REVISION.fragmentShader = 'uniform sampler2D carColorPattern;\nuniform vec3 carColorSecondary;\n' + REVISION.fragmentShader, REVISION.fragmentShader = REVISION.fragmentShader.replace('vec4 diffuseColor = vec4( diffuse, opacity );', 'float colorSource = texture(carColorPattern, vUv).a;\nvec4 diffuseColor = vec4( carColorSecondary * colorSource + diffuse * (1.0 - colorSource), opacity );'), REVISION.uniforms.carColorPattern = { value: GA(this, pA, 'f') }, REVISION.uniforms.carColorSecondary = GA(this, mA, 'f'), null == REVISION.defines && (REVISION.defines = {}), REVISION.defines.USE_UV = !0;
                            }, REVISION.needsUpdate = !0;
                        else if ('Metal' == REVISION.name)
                            REVISION.needsUpdate = !0;
                        else if ('BrakeLight' == REVISION.name) {
                            if (!(REVISION instanceof xa))
                                throw new Error('Brake light material must be MeshStandardMaterial');
                            VA(this, fA, REVISION, 'f');
                        }
                    t.castShadow = !0, t.receiveShadow = !0, t.frustumCulled = !1, r.addMaterial(t.material);
                }
                GA(this, lA, 'f').scene.add(GA(this, cA, 'f')), VA(this, hA, GA(this, cA, 'f').getObjectByName('Body'), 'f'), VA(this, dA, GA(this, cA, 'f').getObjectByName('Suspension'), 'f'), GA(this, dA, 'f').geometry.morphAttributes.position = [];
                const SrcColorFactor = GA(this, dA, 'f'), OneMinusSrcColorFactor = Ug.models.suspensionFL, SrcAlphaFactor = Ug.models.suspensionFR, OneMinusSrcAlphaFactor = Ug.models.suspensionBL, DstAlphaFactor = Ug.models.suspensionBR;
                for (const REVISION of GA(this, cA, 'f').children)
                    if (REVISION != GA(this, hA, 'f') && REVISION != GA(this, dA, 'f')) {
                        const t = REVISION;
                        if (!(OneMinusSrcColorFactor.geometry.attributes.position instanceof BufferAttribute && SrcAlphaFactor.geometry.attributes.position instanceof BufferAttribute && OneMinusSrcAlphaFactor.geometry.attributes.position instanceof BufferAttribute && DstAlphaFactor.geometry.attributes.position instanceof BufferAttribute))
                            throw new Error('Vertices must use BufferAttribute');
                        const n = OneMinusSrcColorFactor.geometry.attributes.position.array, i = SrcAlphaFactor.geometry.attributes.position.array, r = OneMinusSrcAlphaFactor.geometry.attributes.position.array, AddEquation = DstAlphaFactor.geometry.attributes.position.array, SubtractEquation = SrcColorFactor.geometry.morphAttributes.position;
                        if ('WheelFL' == t.name)
                            SubtractEquation.push(new BufferAttribute(n, 3));
                        else if ('WheelFR' == t.name)
                            SubtractEquation.push(new BufferAttribute(i, 3));
                        else if ('WheelBL' == t.name)
                            SubtractEquation.push(new BufferAttribute(r, 3));
                        else {
                            if ('WheelBR' != t.name)
                                throw new Error('Unidentified wheel');
                            SubtractEquation.push(new BufferAttribute(AddEquation, 3));
                        }
                        GA(this, uA, 'f').push(t);
                    }
                GA(this, dA, 'f').updateMorphTargets(), null != GA(this, Kg, 'f') && (null === (OneFactor = GA(this, jg, 'f')) || void 0 === OneFactor || OneFactor.controlCar(GA(this, Yg, 'f').id, GA(this, Kg, 'f').up, GA(this, Kg, 'f').right, GA(this, Kg, 'f').down, GA(this, Kg, 'f').left, GA(this, Kg, 'f').reset), GA(this, Kg, 'f').addChangeCallback(VA(this, SA, REVISION => {
                    var t;
                    null === (t = GA(this, jg, 'f')) || void 0 === t || t.controlCar(GA(this, Yg, 'f').id, REVISION.up, REVISION.right, REVISION.down, REVISION.left, REVISION.reset);
                }, 'f'))), r.addContextRestoredEventListener(VA(this, EA, () => {
                    GA(this, pA, 'f').dispose(), VA(this, pA, Ug.createTexture(r), 'f');
                }, 'f'));
            }
            dispose() {
                var REVISION, t, n;
                VA(this, MA, !0, 'f'), GA(this, Lg, 'm', TA).call(this), GA(this, lA, 'f').scene.remove(GA(this, Qg, 'f').camera), GA(this, lA, 'f').scene.remove(GA(this, Xg, 'f').camera), null === (REVISION = GA(this, bA, 'f')) || void 0 === REVISION || REVISION.dispose();
                for (const REVISION of GA(this, wA, 'f'))
                    REVISION.dispose();
                GA(this, wA, 'f').length = 0, GA(this, lA, 'f').scene.remove(GA(this, cA, 'f')), GA(this, pA, 'f').dispose();
                for (const REVISION of GA(this, cA, 'f').children) {
                    if (!(REVISION instanceof Mesh))
                        throw new Error('Mesh is not a THREE.Mesh');
                    GA(this, lA, 'f').removeMaterial(REVISION.material);
                }
                null === (t = GA(this, jg, 'f')) || void 0 === t || t.deleteCar(GA(this, Yg, 'f').id), null != GA(this, SA, 'f') && (null === (n = GA(this, Kg, 'f')) || void 0 === n || n.removeChangeCallback(GA(this, SA, 'f'))), GA(this, lA, 'f').removeContextRestoredEventListener(GA(this, EA, 'f'));
            }
            addResetCallback(REVISION) {
                GA(this, nA, 'f').push(REVISION);
            }
            addCheckpointCallback(REVISION) {
                GA(this, iA, 'f').push(REVISION);
            }
            addFinishCallback(REVISION) {
                GA(this, rA, 'f').push(REVISION);
            }
            getChassisMatrix() {
                return null != GA(this, hA, 'f') ? GA(this, hA, 'f').matrix : null;
            }
            getSpeedKmh() {
                return GA(this, Yg, 'f').speedKmh;
            }
            start() {
                var REVISION;
                null === (REVISION = GA(this, jg, 'f')) || void 0 === REVISION || REVISION.startCar(GA(this, Yg, 'f').id, null);
            }
            hasStarted() {
                return GA(this, Yg, 'f').hasStarted;
            }
            hasFinished() {
                return null != GA(this, Yg, 'f').finishFrames;
            }
            getFinishTime() {
                return null == GA(this, Yg, 'f').finishFrames ? null : new Xh(GA(this, Yg, 'f').finishFrames);
            }
            getRecording() {
                return GA(this, Jg, 'f');
            }
            getTime() {
                return new Xh(GA(this, Yg, 'f').frames);
            }
            getNextCheckpointIndex() {
                return GA(this, Yg, 'f').nextCheckpointIndex;
            }
            hasCheckpointToRespawnAt() {
                return GA(this, Yg, 'f').hasCheckpointToRespawnAt;
            }
            getPosition() {
                return new Vector3(GA(this, Yg, 'f').position.x, GA(this, Yg, 'f').position.y, GA(this, Yg, 'f').position.z);
            }
            getQuaternion() {
                return new Quaternion(GA(this, Yg, 'f').quaternion.x, GA(this, Yg, 'f').quaternion.y, GA(this, Yg, 'f').quaternion.z, GA(this, Yg, 'f').quaternion.w);
            }
            getMatrix4() {
                const REVISION = this.getPosition(), t = this.getQuaternion(), n = new Matrix4().makeRotationFromQuaternion(t);
                return n.setPosition(REVISION), n;
            }
            get isPaused() {
                return GA(this, qg, 'f');
            }
            set isPaused(REVISION) {
                var t;
                GA(this, qg, 'f') != REVISION && (null === (t = GA(this, jg, 'f')) || void 0 === t || t.pauseCar(GA(this, Yg, 'f').id, REVISION), VA(this, qg, REVISION, 'f'));
            }
            getControls() {
                return null != GA(this, Kg, 'f') ? GA(this, Kg, 'f').getControls() : GA(this, Yg, 'f').controls;
            }
            getColors() {
                return GA(this, gA, 'f');
            }
            setColors(REVISION) {
                if (GA(this, mA, 'f').value = new Vector3().setFromColor(REVISION.secondary), null != GA(this, hA, 'f') && Array.isArray(GA(this, hA, 'f').material))
                    for (const t of GA(this, hA, 'f').material)
                        'Main' == t.name ? t.color.set(REVISION.primary) : 'Metal' == t.name && t.color.set(REVISION.frame);
                if (null != GA(this, dA, 'f') && !Array.isArray(GA(this, dA, 'f').material)) {
                    const t = GA(this, dA, 'f').material;
                    'Metal' == t.name && t.color.set(REVISION.frame);
                }
                for (const t of GA(this, uA, 'f'))
                    if (Array.isArray(t.material))
                        for (const n of t.material)
                            'Metal' == n.name ? n.color.set(REVISION.frame) : 'Rim' == n.name && n.color.set(REVISION.rims);
                VA(this, gA, REVISION, 'f');
            }
            static createTexture(REVISION) {
                if (null == Ug.images)
                    throw new Error('Car images are not loaded yet');
                const t = document.createElement('canvas');
                t.width = 2048, t.height = 2048;
                const n = t.getContext('2d');
                if (null == n)
                    throw new Error('Failed to get context for car texture');
                const i = new Texture(t);
                return i.flipY = !1, i.anisotropy = REVISION.getMaxAnisotropy(), i.needsUpdate = !0, n.clearRect(0, 0, n.canvas.width, n.canvas.height), n.drawImage(Ug.images.stripe, 0, 0, n.canvas.width, n.canvas.height), i.needsUpdate = !0, i;
            }
            setOpacity(REVISION) {
                for (const t of GA(this, cA, 'f').children) {
                    const n = t;
                    let i;
                    i = Array.isArray(n.material) ? n.material : [n.material];
                    for (const t of i) {
                        t.opacity = REVISION;
                        const n = REVISION < 1;
                        t.needsUpdate = n != t.transparent, t.transparent = n;
                    }
                }
            }
            setVisible(REVISION) {
                GA(this, cA, 'f').visible = REVISION;
            }
            getCarState() {
                return GA(this, Yg, 'f');
            }
            setCarState(REVISION) {
                var t;
                if (GA(this, MA, 'f'))
                    return;
                const n = GA(this, Yg, 'f');
                VA(this, Yg, REVISION, 'f');
                const i = GA(this, Yg, 'f').frames != n.frames && GA(this, Yg, 'f').frames != n.frames + 1;
                if (GA(this, Yg, 'f').nextCheckpointIndex > n.nextCheckpointIndex) {
                    this.notificationAudioEnabled && GA(this, Lg, 'm', IA).call(this);
                    for (const REVISION of GA(this, iA, 'f'))
                        REVISION(n.nextCheckpointIndex);
                }
                if (null != GA(this, Yg, 'f').finishFrames && null == n.finishFrames) {
                    this.notificationAudioEnabled && GA(this, Lg, 'm', RA).call(this);
                    for (const REVISION of GA(this, rA, 'f'))
                        REVISION(this);
                }
                const r = 0.001;
                if (i) {
                    null === (t = GA(this, bA, 'f')) || void 0 === t || t.clear();
                    for (const REVISION of GA(this, wA, 'f'))
                        REVISION.clear();
                }
                if (this.getTime().numberOfFrames % 10 == 0 && GA(this, Lg, 'm', PA).call(this, 0.01), i || !n.controls.reset && GA(this, Yg, 'f').controls.reset) {
                    GA(this, Qg, 'f').reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh()), GA(this, Xg, 'f').reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh());
                    for (const REVISION of GA(this, nA, 'f'))
                        REVISION();
                }
                GA(this, Lg, 'm', LA).call(this, r), GA(this, Lg, 'm', NA).call(this, r), GA(this, Zg, 'f') && GA(this, Yg, 'f').hasStarted && null == n.finishFrames && GA(this, Jg, 'f').recordFrame(n.frames, GA(this, Yg, 'f').controls);
            }
            update(REVISION) {
                var t, n;
                if (null != GA(this, hA, 'f') && null != GA(this, dA, 'f')) {
                    GA(this, Lg, 'm', BA).call(this), null === (t = GA(this, bA, 'f')) || void 0 === t || t.update(REVISION);
                    const i = this.getMatrix4(), r = this.getQuaternion();
                    GA(this, hA, 'f').matrixAutoUpdate = !1, GA(this, hA, 'f').matrix.copy(i), GA(this, hA, 'f').matrix.multiply(new Matrix4().makeTranslation(0, Ug.massOffset, 0)), GA(this, dA, 'f').matrixAutoUpdate = !1, GA(this, dA, 'f').matrix.copy(GA(this, hA, 'f').matrix);
                    const AddEquation = 4;
                    for (let t = 0; t < AddEquation; t++) {
                        const i = null != GA(this, Yg, 'f').wheelContact[t], AddEquation = GA(this, Yg, 'f').wheelDeltaRotation[t];
                        if (this.hasStarted()) {
                            if (i)
                                GA(this, aA, 'f')[t] = 1000 * AddEquation, GA(this, sA, 'f')[t] = 1000 * AddEquation;
                            else {
                                const {
                                        up: n,
                                        down: i
                                    } = this.getControls(), r = 2 == t || 3 == t;
                                i ? GA(this, Yg, 'f').brakeLightEnabled ? GA(this, sA, 'f')[t] > 0 ? GA(this, sA, 'f')[t] = Math.max(0, GA(this, sA, 'f')[t] - 50 * REVISION) : GA(this, sA, 'f')[t] < 0 && (GA(this, sA, 'f')[t] = Math.min(0, GA(this, sA, 'f')[t] + 50 * REVISION)) : r && (GA(this, aA, 'f')[t] -= 25 * REVISION, GA(this, sA, 'f')[t] -= 25 * REVISION) : n && r && (GA(this, aA, 'f')[t] += 25 * REVISION, GA(this, sA, 'f')[t] += 50 * REVISION), GA(this, aA, 'f')[t] *= Math.max(0, 1 - REVISION), GA(this, sA, 'f')[t] *= Math.max(0, 1 - REVISION);
                            }
                            GA(this, oA, 'f')[t] += GA(this, sA, 'f')[t] * REVISION;
                        }
                        const SubtractEquation = GA(this, Yg, 'f').wheelPosition[t], ReverseSubtractEquation = new Quaternion(GA(this, Yg, 'f').wheelQuaternion[t].x, GA(this, Yg, 'f').wheelQuaternion[t].y, GA(this, Yg, 'f').wheelQuaternion[t].z, GA(this, Yg, 'f').wheelQuaternion[t].w), ZeroFactor = GA(this, Yg, 'f').wheelRotation[t];
                        ReverseSubtractEquation.multiply(new Quaternion().setFromAxisAngle(new Vector3(-1, 0, 0), GA(this, oA, 'f')[t] - ZeroFactor)), GA(this, uA, 'f')[t].position.set(SubtractEquation.x, SubtractEquation.y, SubtractEquation.z), GA(this, uA, 'f')[t].quaternion.set(ReverseSubtractEquation.x, ReverseSubtractEquation.y, ReverseSubtractEquation.z, ReverseSubtractEquation.w);
                        const OneFactor = GA(this, Yg, 'f').wheelSuspensionLength[t], SrcColorFactor = GA(this, Yg, 'f').wheelSkidInfo[t];
                        if (GA(this, dA, 'f').morphTargetInfluences || (GA(this, dA, 'f').morphTargetInfluences = []), GA(this, dA, 'f').morphTargetInfluences[t] = 2 * OneFactor + 0.06, REVISION > 0 && (null === (n = GA(this, vA, 'f')) || void 0 === n ? void 0 : n.getSettingBoolean(dm.SkidmarksEnabled)) && t < GA(this, wA, 'f').length) {
                            const REVISION = GA(this, Yg, 'f').wheelContact[t], n = Math.min(1, Math.abs(AddEquation) / GA(Ug, Ug, 'f', $g)), i = Math.pow(n, GA(Ug, Ug, 'f', eA)) * GA(Ug, Ug, 'f', tA);
                            null != REVISION && SrcColorFactor < i && 0 == GA(this, xA, 'f')[t] && GA(this, wA, 'f')[t].spawn(new Vector3(SubtractEquation.x, SubtractEquation.y, SubtractEquation.z), r, new Vector3(REVISION.position.x, REVISION.position.y, REVISION.position.z), new Vector3(REVISION.normal.x, REVISION.normal.y, REVISION.normal.z));
                        }
                    }
                    GA(this, Lg, 'm', OA).call(this, GA(this, Yg, 'f').brakeLightEnabled);
                }
            }
            updateCameras(REVISION) {
                if (null == GA(this, Yg, 'f').finishFrames) {
                    const t = this.getPosition(), n = this.getQuaternion(), i = this.getSpeedKmh();
                    GA(this, Qg, 'f').update(REVISION, t, n, i), GA(this, Xg, 'f').update(t, n, i);
                }
            }
            get cameraOrbit() {
                return GA(this, Qg, 'f').camera;
            }
            get cameraCockpit() {
                return GA(this, Xg, 'f').camera;
            }
            set audioVolume(REVISION) {
                VA(this, Fg, REVISION, 'f'), null != GA(this, kg, 'f') && GA(this, kg, 'f').gain.setTargetAtTime(GA(this, Fg, 'f'), 0, 0.01);
            }
            static initResources() {
                return WA(this, void 0, void 0, function* () {
                    const REVISION = yield new Promise((REVISION, t) => {
                        new gd().load('models/car.glb', n => {
                            function i(REVISION) {
                                const t = n.scene.getObjectByName(REVISION);
                                if (null == t)
                                    throw new Error('Mesh "' + REVISION + '" does not exist');
                                if (0 == t.children.length) {
                                    const REVISION = t;
                                    return REVISION.updateMatrixWorld(!0), REVISION.geometry.applyMatrix4(REVISION.matrix.clone()), REVISION.matrix.identity(), REVISION;
                                }
                                const i = function (REVISION, t = !1) {
                                    const n = null !== REVISION[0].index, i = new Set(Object.keys(REVISION[0].attributes)), r = new Set(Object.keys(REVISION[0].morphAttributes)), AddEquation = {}, SubtractEquation = {}, ReverseSubtractEquation = REVISION[0].morphTargetsRelative, ZeroFactor = new BufferGeometry();
                                    let OneFactor = 0;
                                    for (let SrcColorFactor = 0; SrcColorFactor < REVISION.length; ++SrcColorFactor) {
                                        const OneMinusSrcColorFactor = REVISION[SrcColorFactor];
                                        let SrcAlphaFactor = 0;
                                        if (n !== (null !== OneMinusSrcColorFactor.index))
                                            return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + SrcColorFactor + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.'), null;
                                        for (const REVISION in OneMinusSrcColorFactor.attributes) {
                                            if (!i.has(REVISION))
                                                return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + SrcColorFactor + '. All geometries must have compatible attributes; make sure "' + REVISION + '" attribute exists among all geometries, or in none of them.'), null;
                                            void 0 === AddEquation[REVISION] && (AddEquation[REVISION] = []), AddEquation[REVISION].push(OneMinusSrcColorFactor.attributes[REVISION]), SrcAlphaFactor++;
                                        }
                                        if (SrcAlphaFactor !== i.size)
                                            return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + SrcColorFactor + '. Make sure all geometries have the same number of attributes.'), null;
                                        if (ReverseSubtractEquation !== OneMinusSrcColorFactor.morphTargetsRelative)
                                            return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + SrcColorFactor + '. .morphTargetsRelative must be consistent throughout all geometries.'), null;
                                        for (const REVISION in OneMinusSrcColorFactor.morphAttributes) {
                                            if (!r.has(REVISION))
                                                return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + SrcColorFactor + '.  .morphAttributes must be consistent throughout all geometries.'), null;
                                            void 0 === SubtractEquation[REVISION] && (SubtractEquation[REVISION] = []), SubtractEquation[REVISION].push(OneMinusSrcColorFactor.morphAttributes[REVISION]);
                                        }
                                        if (t) {
                                            let REVISION;
                                            if (n)
                                                REVISION = OneMinusSrcColorFactor.index.count;
                                            else {
                                                if (void 0 === OneMinusSrcColorFactor.attributes.position)
                                                    return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + SrcColorFactor + '. The geometry must have either an index or a position attribute'), null;
                                                REVISION = OneMinusSrcColorFactor.attributes.position.count;
                                            }
                                            ZeroFactor.addGroup(OneFactor, REVISION, SrcColorFactor), OneFactor += REVISION;
                                        }
                                    }
                                    if (n) {
                                        let t = 0;
                                        const n = [];
                                        for (let i = 0; i < REVISION.length; ++i) {
                                            const r = REVISION[i].index;
                                            for (let REVISION = 0; REVISION < r.count; ++REVISION)
                                                n.push(r.getX(REVISION) + t);
                                            t += REVISION[i].attributes.position.count;
                                        }
                                        ZeroFactor.setIndex(n);
                                    }
                                    for (const REVISION in AddEquation) {
                                        const t = pd(AddEquation[REVISION]);
                                        if (!t)
                                            return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + REVISION + ' attribute.'), null;
                                        ZeroFactor.setAttribute(REVISION, t);
                                    }
                                    for (const REVISION in SubtractEquation) {
                                        const t = SubtractEquation[REVISION][0].length;
                                        if (0 === t)
                                            break;
                                        ZeroFactor.morphAttributes = ZeroFactor.morphAttributes || {}, ZeroFactor.morphAttributes[REVISION] = [];
                                        for (let n = 0; n < t; ++n) {
                                            const t = [];
                                            for (let i = 0; i < SubtractEquation[REVISION].length; ++i)
                                                t.push(SubtractEquation[REVISION][i][n]);
                                            const i = pd(t);
                                            if (!i)
                                                return console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + REVISION + ' morphAttribute.'), null;
                                            ZeroFactor.morphAttributes[REVISION].push(i);
                                        }
                                    }
                                    return ZeroFactor;
                                }(t.children.map(REVISION => REVISION.geometry), !0);
                                t.updateMatrixWorld(!0), i.applyMatrix4(t.matrix.clone());
                                const r = t.children.map(REVISION => REVISION.material), AddEquation = new Mesh(i, r);
                                return AddEquation.name = REVISION, AddEquation;
                            }
                            function r(REVISION) {
                                let t;
                                t = Array.isArray(REVISION.material) ? REVISION.material : [REVISION.material];
                                for (const REVISION of t)
                                    REVISION.side = 0, REVISION.shadowSide = 0;
                                return REVISION;
                            }
                            Ug.models = {
                                chassis: r(i('Body')),
                                suspension: r(i('Suspension')),
                                suspensionFL: r(i('SuspensionFL')),
                                suspensionFR: r(i('SuspensionFR')),
                                suspensionBL: r(i('SuspensionBL')),
                                suspensionBR: r(i('SuspensionBR')),
                                wheelFL: r(i('WheelFL')),
                                wheelFR: r(i('WheelFR')),
                                wheelBL: r(i('WheelBL')),
                                wheelBR: r(i('WheelBR')),
                                collisionShapeVertices: GA(Ug, Ug, 'm', zA).call(Ug, i('Collision'))
                            }, Ug.models.wheelFL.geometry.translate(-0.627909, 0.218824, -1.3478), Ug.models.wheelFR.geometry.translate(0.627909, 0.218824, -1.3478), Ug.models.wheelBL.geometry.translate(-0.720832, 0.218824, 1.52686), Ug.models.wheelBR.geometry.translate(0.720832, 0.218824, 1.52686), Ug.models.wheelFL.geometry.rotateZ(Math.PI), Ug.models.wheelFR.geometry.rotateZ(Math.PI), Ug.models.wheelBL.geometry.rotateZ(Math.PI), Ug.models.wheelBR.geometry.rotateZ(Math.PI), GA(Ug, Ug, 'm', HA).call(Ug).then(t => {
                                REVISION(t);
                            }).catch(t);
                        }, void 0, t);
                    });
                    return yield new Promise((REVISION, t) => {
                        const n = new Image();
                        n.addEventListener('load', () => {
                            REVISION();
                        }), n.addEventListener('error', () => {
                            t(new Error('Failed to load image'));
                        }), n.src = 'images/car_stripe.svg', Ug.images = { stripe: n };
                    }), REVISION;
                });
            }
        }
        Ug = QA, Ng = new WeakMap(), kg = new WeakMap(), Fg = new WeakMap(), Og = new WeakMap(), zg = new WeakMap(), Hg = new WeakMap(), Wg = new WeakMap(), Vg = new WeakMap(), Gg = new WeakMap(), Qg = new WeakMap(), Xg = new WeakMap(), jg = new WeakMap(), qg = new WeakMap(), Yg = new WeakMap(), Kg = new WeakMap(), Zg = new WeakMap(), Jg = new WeakMap(), nA = new WeakMap(), iA = new WeakMap(), rA = new WeakMap(), aA = new WeakMap(), sA = new WeakMap(), oA = new WeakMap(), lA = new WeakMap(), cA = new WeakMap(), hA = new WeakMap(), dA = new WeakMap(), uA = new WeakMap(), fA = new WeakMap(), pA = new WeakMap(), mA = new WeakMap(), gA = new WeakMap(), AA = new WeakMap(), _A = new WeakMap(), vA = new WeakMap(), wA = new WeakMap(), yA = new WeakMap(), xA = new WeakMap(), bA = new WeakMap(), SA = new WeakMap(), EA = new WeakMap(), MA = new WeakMap(), Lg = new WeakSet(), TA = function () {
            GA(this, Lg, 'm', CA).call(this), setTimeout(() => {
                if (null != GA(this, Og, 'f') && (GA(this, Og, 'f').source.stop(), VA(this, Og, null, 'f')), null != GA(this, Hg, 'f')) {
                    for (const {source: REVISION} of GA(this, Hg, 'f'))
                        REVISION.stop();
                    VA(this, Hg, null, 'f');
                }
            }, 200);
        }, CA = function () {
            if (null != GA(this, Og, 'f') && (GA(this, Og, 'f').source.playbackRate.setTargetAtTime(0.7, 0, 0.15), GA(this, Og, 'f').gain.gain.setTargetAtTime(0, 0, 0.15)), null != GA(this, Hg, 'f'))
                for (const REVISION of GA(this, Hg, 'f'))
                    REVISION.source.playbackRate.setTargetAtTime(0.3, 0, 0.15), REVISION.gain.gain.setTargetAtTime(0, 0, 0.15);
            if (null != GA(this, yA, 'f')) {
                for (const {source: REVISION} of GA(this, yA, 'f'))
                    REVISION.stop();
                VA(this, yA, null, 'f');
            }
        }, IA = function () {
            var REVISION, t;
            const n = null !== (t = null === (REVISION = GA(this, vA, 'f')) || void 0 === REVISION ? void 0 : REVISION.getSettingFloat(dm.CheckpointVolume)) && void 0 !== t ? t : 0;
            let i = Math.min(Math.max(GA(this, Fg, 'f') * n, 0), 1);
            if (Number.isNaN(i) && (i = 0), i > 0 && null != GA(this, Ng, 'f')) {
                const REVISION = GA(this, Ng, 'f').getBuffer('checkpoint');
                if (null != REVISION && null != GA(this, Ng, 'f').context && null != GA(this, Ng, 'f').destinationMaster) {
                    const t = GA(this, Ng, 'f').context.createBufferSource();
                    t.buffer = REVISION, t.playbackRate.value = 1.25;
                    const n = GA(this, Ng, 'f').context.createGain();
                    n.gain.value = 0.03 * i, t.connect(n), n.connect(GA(this, Ng, 'f').destinationMaster), t.start(0);
                }
            }
        }, RA = function () {
            var REVISION, t;
            const n = null !== (t = null === (REVISION = GA(this, vA, 'f')) || void 0 === REVISION ? void 0 : REVISION.getSettingFloat(dm.CheckpointVolume)) && void 0 !== t ? t : 0;
            let i = Math.min(Math.max(GA(this, Fg, 'f') * n, 0), 1);
            if (Number.isNaN(i) && (i = 0), i > 0 && null != GA(this, Ng, 'f')) {
                const REVISION = GA(this, Ng, 'f').getBuffer('finish');
                if (null != REVISION && null != GA(this, Ng, 'f').context && null != GA(this, Ng, 'f').destinationMaster) {
                    const t = GA(this, Ng, 'f').context.createBufferSource();
                    t.buffer = REVISION, t.playbackRate.value = 1.25;
                    const n = GA(this, Ng, 'f').context.createGain();
                    n.gain.value = 0.03, t.connect(n), n.connect(GA(this, Ng, 'f').destinationMaster), t.start(0);
                }
            }
        }, PA = function (REVISION) {
            var t;
            for (let n = 0; n < 4; n++) {
                const i = GA(this, Yg, 'f').wheelPosition[n], r = null != GA(this, Yg, 'f').wheelContact[n], AddEquation = GA(this, Yg, 'f').wheelDeltaRotation[n], SubtractEquation = GA(this, Yg, 'f').wheelSkidInfo[n], ReverseSubtractEquation = Math.min(1, Math.abs(AddEquation) / GA(Ug, Ug, 'f', $g)), ZeroFactor = Math.pow(ReverseSubtractEquation, GA(Ug, Ug, 'f', eA)) * GA(Ug, Ug, 'f', tA);
                r && SubtractEquation < ZeroFactor ? (n < GA(this, wA, 'f').length && (GA(this, xA, 'f')[n] = Math.max(0, GA(this, xA, 'f')[n] - REVISION)), 0 == GA(this, xA, 'f')[n] && null != GA(this, bA, 'f') && GA(this, bA, 'f').spawn(i.x, i.y, i.z)) : (n < GA(this, wA, 'f').length && (null === (t = GA(this, vA, 'f')) || void 0 === t ? void 0 : t.getSettingBoolean(dm.SkidmarksEnabled)) && GA(this, wA, 'f')[n].break(), GA(this, xA, 'f')[n] = 0.075);
            }
        }, BA = function () {
            if (null != GA(this, Ng, 'f') && null != GA(this, Ng, 'f').context && null != GA(this, Ng, 'f').destinationSfx) {
                null == GA(this, kg, 'f') && (VA(this, kg, GA(this, Ng, 'f').context.createGain(), 'f'), GA(this, kg, 'f').gain.value = GA(this, Fg, 'f'), GA(this, kg, 'f').connect(GA(this, Ng, 'f').destinationSfx)), null == GA(this, Vg, 'f') && (VA(this, Vg, GA(this, Ng, 'f').context.createPanner(), 'f'), GA(this, Vg, 'f').refDistance = 5, GA(this, Vg, 'f').connect(GA(this, kg, 'f')));
                const REVISION = this.getPosition();
                GA(this, Vg, 'f').positionX.value = REVISION.x, GA(this, Vg, 'f').positionY.value = REVISION.y, GA(this, Vg, 'f').positionZ.value = REVISION.z;
                const t = 4;
                if (GA(this, Gg, 'f').length < t) {
                    GA(this, Gg, 'f').length = 0;
                    for (let REVISION = 0; REVISION < t; ++REVISION) {
                        const REVISION = GA(this, Ng, 'f').context.createPanner();
                        REVISION.refDistance = 5, REVISION.connect(GA(this, kg, 'f')), GA(this, Gg, 'f').push(REVISION);
                    }
                }
                for (let REVISION = 0; REVISION < t; ++REVISION) {
                    const t = GA(this, Gg, 'f')[REVISION], n = GA(this, Yg, 'f').wheelPosition[REVISION];
                    t.positionX.value = n.x, t.positionY.value = n.y, t.positionZ.value = n.z;
                }
                GA(this, lA, 'f').camera != GA(this, Qg, 'f').camera && GA(this, lA, 'f').camera != GA(this, Xg, 'f').camera || GA(this, Ng, 'f').refreshListener(GA(this, lA, 'f')), GA(this, Lg, 'm', DA).call(this), GA(this, Lg, 'm', UA).call(this), GA(this, Lg, 'm', FA).call(this);
            }
        }, DA = function () {
            if (null == GA(this, Og, 'f') && null != GA(this, Vg, 'f') && null != GA(this, Ng, 'f')) {
                const REVISION = GA(this, Ng, 'f').getBuffer('engine');
                if (null != REVISION && null != GA(this, Ng, 'f').context) {
                    const t = GA(this, Ng, 'f').context.createBufferSource();
                    t.buffer = REVISION, t.loop = !0, t.playbackRate.value = 0.7;
                    const n = GA(this, Ng, 'f').context.createGain();
                    n.gain.value = 0, t.connect(n), n.connect(GA(this, Vg, 'f')), t.start(0, 2 * Math.random()), VA(this, Og, {
                        source: t,
                        gain: n
                    }, 'f');
                }
            }
            if (null != GA(this, Og, 'f')) {
                const REVISION = (GA(this, aA, 'f')[0] + GA(this, aA, 'f')[1] + GA(this, aA, 'f')[2] + GA(this, aA, 'f')[3]) / 4, t = 0.7 + Math.pow(Math.abs(REVISION), 1 / 3) / 3, n = null != GA(this, Yg, 'f').wheelContact[0] || null != GA(this, Yg, 'f').wheelContact[1] || null != GA(this, Yg, 'f').wheelContact[2] || null != GA(this, Yg, 'f').wheelContact[3], {
                        up: i,
                        down: r
                    } = this.getControls(), AddEquation = this.hasStarted() && !this.hasFinished() && (i && !(r && GA(this, Yg, 'f').brakeLightEnabled) || r && !GA(this, Yg, 'f').brakeLightEnabled);
                let SubtractEquation;
                SubtractEquation = n ? AddEquation ? t : Math.max(0.7, t / 2) : AddEquation ? Math.max(0.7, 1.15 * t) : Math.max(0.7, t / 2), GA(this, Og, 'f').source.playbackRate.setTargetAtTime(SubtractEquation, 0, 0.05), GA(this, Og, 'f').gain.gain.setTargetAtTime(Math.min(0.285, SubtractEquation / 14), 0, 0.05);
            }
        }, LA = function (REVISION) {
            if (GA(this, zg, 'f').length < 4) {
                GA(this, zg, 'f').length = 0;
                for (let REVISION = 0; REVISION < 4; ++REVISION)
                    GA(this, zg, 'f').push(0);
            }
            for (let t = 0; t < 4 && t < GA(this, Gg, 'f').length; t++)
                if (GA(this, zg, 'f')[t] -= REVISION, GA(this, zg, 'f')[t] <= 0) {
                    const REVISION = Math.abs(GA(this, Yg, 'f').wheelSuspensionVelocity[t]);
                    if (REVISION > 4 && null != GA(this, Ng, 'f')) {
                        const n = GA(this, Ng, 'f').getBuffer('suspension');
                        if (null != n && null != GA(this, Ng, 'f').context) {
                            const i = GA(this, Ng, 'f').context.createBufferSource();
                            i.buffer = n, i.playbackRate.value = 0.7 + 0.1 * Math.random();
                            const r = GA(this, Ng, 'f').context.createGain();
                            r.gain.value = Math.min(0.285, REVISION / 140), i.connect(r), r.connect(GA(this, Gg, 'f')[t]), i.start(GA(this, Ng, 'f').context.currentTime + 0.02 * Math.random()), GA(this, zg, 'f')[t] = 0.1;
                        }
                    }
                }
        }, UA = function () {
            if (null == GA(this, Hg, 'f') && null != GA(this, Ng, 'f')) {
                const REVISION = GA(this, Ng, 'f').getBuffer('tires');
                if (null != REVISION && null != GA(this, Ng, 'f').context) {
                    VA(this, Hg, [], 'f');
                    const t = 4;
                    for (let n = 0; n < t; n++) {
                        const i = GA(this, Ng, 'f').context.createBufferSource();
                        i.buffer = REVISION, i.loop = !0, i.playbackRate.value = 0.3;
                        const r = GA(this, Ng, 'f').context.createGain();
                        r.gain.value = 0, i.connect(r), r.connect(GA(this, Gg, 'f')[n]), i.start(0, n / t * 3.5 + 0.25 * Math.random()), GA(this, Hg, 'f').push({
                            source: i,
                            gain: r
                        });
                    }
                }
            }
            if (null != GA(this, Hg, 'f'))
                for (let REVISION = 0; REVISION < GA(this, Hg, 'f').length; ++REVISION) {
                    const t = GA(this, Hg, 'f')[REVISION];
                    if (null != GA(this, Yg, 'f').wheelContact[REVISION]) {
                        const REVISION = Math.min(3, Math.abs(this.getSpeedKmh()) / 110);
                        t.gain.gain.setTargetAtTime(REVISION / 10.5, 0, 0.15);
                    } else
                        t.gain.gain.setTargetAtTime(0, 0, 0.15);
                    const n = 0.3 + Math.min(0.4, Math.abs(this.getSpeedKmh()) / 800);
                    t.source.playbackRate.setTargetAtTime(n, 0, 0.15);
                }
        }, NA = function (REVISION) {
            null != GA(this, Wg, 'f') && (GA(this, Wg, 'f').timeout -= REVISION, GA(this, Wg, 'f').timeout <= 0 && VA(this, Wg, null, 'f'));
            const t = GA(this, Yg, 'f').collisionImpulses;
            for (const REVISION of t)
                GA(this, Lg, 'm', kA).call(this, REVISION);
        }, kA = function (REVISION) {
            if (REVISION > 25 && null != GA(this, Vg, 'f') && null != GA(this, Ng, 'f') && (null == GA(this, Wg, 'f') || GA(this, Wg, 'f').impulse + 100 < REVISION)) {
                VA(this, Wg, {
                    timeout: 0.2,
                    impulse: REVISION
                }, 'f');
                const t = GA(this, Ng, 'f').getBuffer('collision');
                if (null != t && null != GA(this, Ng, 'f').context) {
                    const n = GA(this, Ng, 'f').context.createBufferSource();
                    n.buffer = t, n.playbackRate.value = 0.1 + 0.15 * Math.min(REVISION / 4000, 1);
                    const i = GA(this, Ng, 'f').context.createGain();
                    i.gain.value = Math.max(0.3, Math.min(REVISION / 4000, 1)) / 2.5, n.connect(i), i.connect(GA(this, Vg, 'f')), n.start(0);
                }
            }
        }, FA = function () {
            if (null == GA(this, yA, 'f') && null != GA(this, Ng, 'f')) {
                const REVISION = GA(this, Ng, 'f').getBuffer('skidding');
                if (null != REVISION && null != GA(this, Ng, 'f').context) {
                    VA(this, yA, [], 'f');
                    const t = 4;
                    for (let n = 0; n < t; ++n) {
                        const i = GA(this, Ng, 'f').context.createBufferSource();
                        i.buffer = REVISION, i.loop = !0, i.playbackRate.value = 0.5;
                        const r = GA(this, Ng, 'f').context.createGain();
                        r.gain.value = 0, i.connect(r), r.connect(GA(this, Gg, 'f')[n]), i.start(0, n / t * 3.5 + 0.25 * Math.random()), GA(this, yA, 'f').push({
                            source: i,
                            gain: r
                        });
                    }
                }
            }
            if (null != GA(this, yA, 'f'))
                for (let REVISION = 0; REVISION < GA(this, yA, 'f').length; ++REVISION) {
                    const t = GA(this, yA, 'f')[REVISION];
                    0 == GA(this, xA, 'f')[REVISION] ? t.gain.gain.setTargetAtTime(0.75 / 3.5, 0, 0.1) : t.gain.gain.setTargetAtTime(0, 0, 0.1);
                }
        }, OA = function (REVISION) {
            null != GA(this, fA, 'f') && (REVISION ? GA(this, fA, 'f').emissive.setRGB(1, 0.4, 0.3) : GA(this, fA, 'f').emissive.setRGB(0, 0, 0));
        }, zA = function (REVISION) {
            const t = REVISION.geometry.toNonIndexed();
            if (!(t.attributes.position instanceof BufferAttribute))
                throw new Error('Vertices must use BufferAttribute');
            return Array.from(t.attributes.position.array);
        }, HA = function () {
            return WA(this, void 0, void 0, function* () {
                if (null == Ug.models)
                    throw new Error('Car models are not loaded yet');
                const REVISION = new Float32Array(Ug.models.collisionShapeVertices), t = yield window.crypto.subtle.digest('SHA-256', REVISION.buffer), n = Array.from(new Uint8Array(t)).map(REVISION => REVISION.toString(16).padStart(2, '0')).join(''), i = 'dd663fb6330ed93725bf865d5eac2cd29ba19f74dbb3f67ae7f695ea1f68aed0';
                return n == i || console.error('Car collision model checksum mismatch: ' + n + ' != ' + i), n == i;
            });
        }, QA.massOffset = 0.6, QA.detectorBoxCenter = new Vector3(0, 0.48, -0.15), QA.detectorBoxSize = new Vector3(0.89, 0.22, 1.8), QA.suspensionResetLengthFront = 0.07809501004219055, QA.suspensionResetLengthRear = 0.0781289680480957, $g = { value: 0.08 }, eA = { value: 3 }, tA = { value: 0.5 }, QA.models = null, QA.images = null;
        const XA = QA;
        var jA, qA, YA, KA, ZA, JA, $A, e_, t_, n_, i_, r_, a_, s_, o_, l_, c_, h_, d_, u_, f_, p_, m_, g_, A_, __, v_, w_, y_, x_ = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, b_ = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        qA = new WeakMap(), YA = new WeakMap(), KA = new WeakMap(), ZA = new WeakMap(), JA = new WeakMap(), $A = new WeakMap(), e_ = new WeakMap(), t_ = new WeakMap(), n_ = new WeakMap(), i_ = new WeakMap(), r_ = new WeakMap(), a_ = new WeakMap(), s_ = new WeakMap(), o_ = new WeakMap(), l_ = new WeakMap(), c_ = new WeakMap(), h_ = new WeakMap(), d_ = new WeakMap(), u_ = new WeakMap(), f_ = new WeakMap(), p_ = new WeakMap(), m_ = new WeakMap(), jA = new WeakSet(), g_ = function (REVISION) {
            if (REVISION.length % 3 != 0)
                throw new Error('Car collision shape number of vertices is not dividable by 3');
            const t = new Ammo.btConvexHullShape();
            for (let n = 0; n < REVISION.length; n += 3) {
                const i = REVISION[n + 0], r = REVISION[n + 1], AddEquation = REVISION[n + 2], SubtractEquation = new Ammo.btVector3(i, r + b_(this, e_, 'f'), AddEquation);
                t.addPoint(SubtractEquation, !0), Ammo.destroy(SubtractEquation);
            }
            return t.setMargin(0.02), t;
        }, A_ = function () {
            return new Vector3(0, 0, 1).applyQuaternion(this.getQuaternion());
        }, __ = function () {
            return new Vector3(0, -1, 0).applyQuaternion(this.getQuaternion());
        }, v_ = function () {
            const REVISION = b_(this, ZA, 'f').getLinearVelocity();
            return new Vector3(REVISION.x(), REVISION.y(), REVISION.z());
        }, w_ = function () {
            const REVISION = Math.abs(b_(this, jA, 'm', A_).call(this).dot(b_(this, jA, 'm', v_).call(this))), t = b_(this, jA, 'm', __).call(this), n = 0.05;
            b_(this, n_, 'f').setValue(t.x * REVISION * n, t.y * REVISION * n, t.z * REVISION * n), b_(this, ZA, 'f').applyCentralImpulse(b_(this, n_, 'f'));
        }, y_ = function (REVISION, t) {
            var n;
            x_(this, p_, !1, 'f');
            let i = !1, r = !1, AddEquation = !1, SubtractEquation = !1, ReverseSubtractEquation = !1;
            b_(this, c_, 'f') && (this.hasFinished() || ({
                up: i,
                right: r,
                down: AddEquation,
                left: SubtractEquation,
                reset: ReverseSubtractEquation
            } = null !== (n = null == t ? void 0 : t.getControls(b_(this, h_, 'f').numberOfFrames)) && void 0 !== n ? n : {
                up: !1,
                right: !1,
                down: !1,
                left: !1,
                reset: !1
            }), b_(this, h_, 'f').increment());
            const ZeroFactor = this.getWheelInContact(0) || this.getWheelInContact(1) || this.getWheelInContact(2) || this.getWheelInContact(3);
            if (!ZeroFactor && AddEquation && !this.hasFinished() && b_(this, c_, 'f') ? b_(this, ZA, 'f').setDamping(0.1, 0.6) : b_(this, ZA, 'f').setDamping(0.1, 0.1), i && !this.hasFinished() && b_(this, c_, 'f')) {
                const REVISION = 4000;
                b_(this, KA, 'f').applyEngineForce(REVISION, 2), b_(this, KA, 'f').applyEngineForce(REVISION, 3);
            } else
                b_(this, KA, 'f').applyEngineForce(0, 2), b_(this, KA, 'f').applyEngineForce(0, 3);
            if (AddEquation && !this.hasFinished() && b_(this, c_, 'f'))
                if (this.getSpeedKmh() > 1 || !ZeroFactor) {
                    const REVISION = 10;
                    b_(this, KA, 'f').setBrake(REVISION, 0), b_(this, KA, 'f').setBrake(REVISION, 1), b_(this, KA, 'f').setBrake(REVISION, 2), b_(this, KA, 'f').setBrake(REVISION, 3), x_(this, p_, !0, 'f');
                } else {
                    const REVISION = Math.min(0, Math.max(-2000, -2000 * (1 + this.getSpeedKmh() / 100)));
                    b_(this, KA, 'f').applyEngineForce(REVISION, 2), b_(this, KA, 'f').applyEngineForce(REVISION, 3), b_(this, KA, 'f').setBrake(0, 0), b_(this, KA, 'f').setBrake(0, 1), b_(this, KA, 'f').setBrake(0, 2), b_(this, KA, 'f').setBrake(0, 3);
                }
            else
                b_(this, KA, 'f').setBrake(0, 0), b_(this, KA, 'f').setBrake(0, 1), b_(this, KA, 'f').setBrake(0, 2), b_(this, KA, 'f').setBrake(0, 3);
            const OneFactor = b_(this, jA, 'm', v_).call(this).applyQuaternion(this.getQuaternion().invert()), SrcColorFactor = -new Vector2(OneFactor.x, OneFactor.z).normalize().angle() + Math.PI / 2;
            let OneMinusSrcColorFactor = Math.max(0, Math.min(1, this.getSpeedKmh() / 30));
            this.getWheelInContact(0) || this.getWheelInContact(1) || (OneMinusSrcColorFactor = 0);
            const SrcAlphaFactor = 155 / Math.pow(46, 1.55), OneMinusSrcAlphaFactor = Math.max(-SrcAlphaFactor, Math.min(SrcAlphaFactor, SrcColorFactor * OneMinusSrcColorFactor)), DstAlphaFactor = 155 / Math.pow(Math.max(46, Math.abs(this.getSpeedKmh())), 1.55);
            b_(this, c_, 'f') && (SubtractEquation && !this.hasFinished() ? x_(this, o_, Math.min(b_(this, o_, 'f') + 10 * REVISION, 1), 'f') : r && !this.hasFinished() ? x_(this, o_, Math.max(b_(this, o_, 'f') - 10 * REVISION, -1), 'f') : b_(this, o_, 'f') > 0 ? x_(this, o_, Math.max(b_(this, o_, 'f') - 10 * REVISION, 0), 'f') : b_(this, o_, 'f') < 0 && x_(this, o_, Math.min(b_(this, o_, 'f') + 10 * REVISION, 0), 'f'));
            const OneMinusDstAlphaFactor = b_(this, o_, 'f') * DstAlphaFactor;
            let DstColorFactor;
            DstColorFactor = OneMinusSrcAlphaFactor < 0 && OneMinusDstAlphaFactor < 0 ? Math.min(OneMinusSrcAlphaFactor, OneMinusDstAlphaFactor) : OneMinusSrcAlphaFactor > 0 && OneMinusDstAlphaFactor > 0 ? Math.max(OneMinusSrcAlphaFactor, OneMinusDstAlphaFactor) : OneMinusSrcAlphaFactor + OneMinusDstAlphaFactor, b_(this, KA, 'f').setSteeringValue(DstColorFactor, 0), b_(this, KA, 'f').setSteeringValue(DstColorFactor, 1);
            for (let REVISION = 0; REVISION < 4; REVISION++) {
                const t = b_(this, KA, 'f').getWheelInfo(REVISION);
                let n;
                n = t.m_raycastInfo.m_suspensionLength < -0.2 ? 200 : 50, n != t.m_suspensionStiffness && t.set_m_suspensionStiffness(n);
            }
            if (ReverseSubtractEquation) {
                if (!b_(this, f_, 'f') && !this.hasFinished() && b_(this, c_, 'f') && null != b_(this, u_, 'f')) {
                    const REVISION = new Ammo.btTransform();
                    REVISION.setIdentity(), x_(this, r_, new Vector3(b_(this, u_, 'f').position.x, b_(this, u_, 'f').position.y, b_(this, u_, 'f').position.z), 'f');
                    const t = new Ammo.btVector3(b_(this, r_, 'f').x, b_(this, r_, 'f').y, b_(this, r_, 'f').z);
                    REVISION.setOrigin(t), Ammo.destroy(t), x_(this, a_, new Quaternion(b_(this, u_, 'f').quaternion.x, b_(this, u_, 'f').quaternion.y, b_(this, u_, 'f').quaternion.z, b_(this, u_, 'f').quaternion.w), 'f');
                    const n = new Ammo.btQuaternion(b_(this, a_, 'f').x, b_(this, a_, 'f').y, b_(this, a_, 'f').z, b_(this, a_, 'f').w);
                    REVISION.setRotation(n), Ammo.destroy(n), b_(this, ZA, 'f').setWorldTransform(REVISION), b_(this, JA, 'f').setWorldTransform(REVISION), Ammo.destroy(REVISION);
                    const i = new Ammo.btVector3(0, 0, 0);
                    b_(this, ZA, 'f').setLinearVelocity(i), b_(this, ZA, 'f').setAngularVelocity(i), Ammo.destroy(i), b_(this, KA, 'f').resetSuspension(), b_(this, KA, 'f').getWheelInfo(0).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthFront), b_(this, KA, 'f').getWheelInfo(1).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthFront), b_(this, KA, 'f').getWheelInfo(2).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthRear), b_(this, KA, 'f').getWheelInfo(3).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthRear), b_(this, KA, 'f').setSteeringValue(0, 0), b_(this, KA, 'f').setSteeringValue(0, 1);
                    const r = b_(this, KA, 'f').getNumWheels();
                    for (let REVISION = 0; REVISION < r; REVISION++)
                        b_(this, KA, 'f').updateWheelTransform(REVISION, !0);
                    x_(this, d_, b_(this, u_, 'f').nextCheckpointIndex, 'f');
                }
                x_(this, f_, !0, 'f');
            } else
                x_(this, f_, !1, 'f');
        };
        const S_ = class {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation) {
                jA.add(this), qA.set(this, void 0), YA.set(this, void 0), KA.set(this, void 0), ZA.set(this, void 0), JA.set(this, void 0), $A.set(this, void 0), e_.set(this, void 0), t_.set(this, new Ammo.btTransform()), n_.set(this, new Ammo.btVector3()), i_.set(this, new Vs(new Vector3(), XA.detectorBoxSize.clone())), r_.set(this, void 0), a_.set(this, void 0), s_.set(this, void 0), o_.set(this, 0), l_.set(this, null), c_.set(this, !1), h_.set(this, new Xh()), d_.set(this, 0), u_.set(this, null), f_.set(this, !1), p_.set(this, !1), m_.set(this, null), x_(this, s_, SubtractEquation, 'f'), x_(this, e_, AddEquation, 'f'), x_(this, YA, new Hh(), 'f'), b_(this, YA, 'f').createGroundPlane(), b_(this, YA, 'f').createMountains(REVISION, t), x_(this, qA, new cd(b_(this, YA, 'f'), n, i), 'f');
                const ZeroFactor = new Ammo.btTransform();
                ZeroFactor.setIdentity();
                const OneFactor = new Ammo.btDefaultMotionState(ZeroFactor);
                Ammo.destroy(ZeroFactor);
                const SrcColorFactor = new Ammo.btVector3(0, 0, 0);
                x_(this, $A, b_(this, jA, 'm', g_).call(this, r), 'f'), b_(this, $A, 'f').calculateLocalInertia(400, SrcColorFactor);
                const OneMinusSrcColorFactor = new Ammo.btRigidBodyConstructionInfo(400, OneFactor, b_(this, $A, 'f'), SrcColorFactor), SrcAlphaFactor = new Ammo.btRigidBody(OneMinusSrcColorFactor);
                SrcAlphaFactor.setFriction(1), SrcAlphaFactor.setContactProcessingThreshold(0), Ammo.destroy(OneMinusSrcColorFactor), Ammo.destroy(SrcColorFactor), SrcAlphaFactor.setDamping(0.1, 0.1), SrcAlphaFactor.setActivationState(4), b_(this, YA, 'f').world.addRigidBody(SrcAlphaFactor, 1, 2), x_(this, ZA, SrcAlphaFactor, 'f');
                const OneMinusSrcAlphaFactor = new Ammo.btVehicleTuning(), DstAlphaFactor = new Ammo.btDefaultVehicleRaycaster(b_(this, YA, 'f').world), OneMinusDstAlphaFactor = new Ammo.btRaycastVehicle(OneMinusSrcAlphaFactor, SrcAlphaFactor, DstAlphaFactor);
                OneMinusDstAlphaFactor.setCoordinateSystem(0, 1, 2), b_(this, YA, 'f').world.addAction(OneMinusDstAlphaFactor), x_(this, KA, OneMinusDstAlphaFactor, 'f');
                const DstColorFactor = new Ammo.btVector3(0, -1, 0), OneMinusDstColorFactor = new Ammo.btVector3(-1, 0, 0);
                for (const REVISION of [
                        'WheelFL',
                        'WheelFR',
                        'WheelBL',
                        'WheelBR'
                    ]) {
                    let t;
                    if ('WheelFL' == REVISION)
                        t = new Ammo.btVector3(0.627909, 0.27, 1.3478);
                    else if ('WheelFR' == REVISION)
                        t = new Ammo.btVector3(-0.627909, 0.27, 1.3478);
                    else if ('WheelBL' == REVISION)
                        t = new Ammo.btVector3(0.720832, 0.27, -1.52686);
                    else {
                        if ('WheelBR' != REVISION)
                            throw new Error('Unidentified wheel');
                        t = new Ammo.btVector3(-0.720832, 0.27, -1.52686);
                    }
                    const n = 'WheelFL' == REVISION || 'WheelFR' == REVISION, i = OneMinusDstAlphaFactor.addWheel(t, DstColorFactor, OneMinusDstColorFactor, 0.12, 0.331, OneMinusSrcAlphaFactor, n);
                    Ammo.destroy(t), i.set_m_maxSuspensionTravelCm(1000), i.set_m_maxSuspensionForce(1000000), i.set_m_suspensionStiffness(50), i.set_m_wheelsDampingRelaxation(1.35), i.set_m_wheelsDampingCompression(200), i.set_m_frictionSlip(3), i.set_m_rollInfluence(0.5);
                }
                Ammo.destroy(DstColorFactor), Ammo.destroy(OneMinusDstColorFactor);
                const SrcAlphaSaturateFactor = new Ammo.btTransform();
                SrcAlphaSaturateFactor.setIdentity(), x_(this, r_, new Vector3(ReverseSubtractEquation.position.x, ReverseSubtractEquation.position.y, ReverseSubtractEquation.position.z), 'f');
                const ConstantColorFactor = new Ammo.btVector3(b_(this, r_, 'f').x, b_(this, r_, 'f').y, b_(this, r_, 'f').z);
                SrcAlphaSaturateFactor.setOrigin(ConstantColorFactor), Ammo.destroy(ConstantColorFactor), x_(this, a_, new Quaternion(ReverseSubtractEquation.quaternion.x, ReverseSubtractEquation.quaternion.y, ReverseSubtractEquation.quaternion.z, ReverseSubtractEquation.quaternion.w), 'f');
                const OneMinusConstantColorFactor = new Ammo.btQuaternion(b_(this, a_, 'f').x, b_(this, a_, 'f').y, b_(this, a_, 'f').z, b_(this, a_, 'f').w);
                SrcAlphaSaturateFactor.setRotation(OneMinusConstantColorFactor), Ammo.destroy(OneMinusConstantColorFactor), x_(this, JA, b_(this, ZA, 'f').getMotionState(), 'f'), b_(this, ZA, 'f').setWorldTransform(SrcAlphaSaturateFactor), b_(this, JA, 'f').setWorldTransform(SrcAlphaSaturateFactor), Ammo.destroy(SrcAlphaSaturateFactor), b_(this, KA, 'f').resetSuspension(), b_(this, KA, 'f').getWheelInfo(0).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthFront), b_(this, KA, 'f').getWheelInfo(1).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthFront), b_(this, KA, 'f').getWheelInfo(2).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthRear), b_(this, KA, 'f').getWheelInfo(3).m_raycastInfo.set_m_suspensionLength(XA.suspensionResetLengthRear), b_(this, KA, 'f').setSteeringValue(0, 0), b_(this, KA, 'f').setSteeringValue(0, 1);
                const ConstantAlphaFactor = b_(this, KA, 'f').getNumWheels();
                for (let REVISION = 0; REVISION < ConstantAlphaFactor; REVISION++)
                    b_(this, KA, 'f').updateWheelTransform(REVISION, !0);
            }
            dispose() {
                b_(this, YA, 'f').world.removeRigidBody(b_(this, ZA, 'f')), Ammo.destroy(b_(this, JA, 'f')), Ammo.destroy(b_(this, ZA, 'f')), Ammo.destroy(b_(this, t_, 'f')), Ammo.destroy(b_(this, n_, 'f')), Ammo.destroy(b_(this, $A, 'f')), b_(this, YA, 'f').world.removeAction(b_(this, KA, 'f')), Ammo.destroy(b_(this, KA, 'f')), b_(this, YA, 'f').dispose();
            }
            get physics() {
                return b_(this, YA, 'f');
            }
            get controls() {
                return b_(this, s_, 'f');
            }
            getSpeedKmh() {
                return this.hasStarted() ? b_(this, KA, 'f').getCurrentSpeedKmHour() : 0;
            }
            start() {
                x_(this, c_, !0, 'f');
            }
            hasStarted() {
                return b_(this, c_, 'f');
            }
            hasFinished() {
                return null != b_(this, l_, 'f');
            }
            getFinishTime() {
                return b_(this, l_, 'f');
            }
            getTime() {
                return b_(this, h_, 'f').clone();
            }
            getNextCheckpointIndex() {
                return b_(this, d_, 'f');
            }
            hasCheckpointToRespawnAt() {
                return null != b_(this, u_, 'f');
            }
            isBrakeLightEnabled() {
                return b_(this, p_, 'f');
            }
            getPosition() {
                return b_(this, r_, 'f');
            }
            getQuaternion() {
                return b_(this, a_, 'f');
            }
            getMatrix4() {
                return new Matrix4().compose(this.getPosition(), this.getQuaternion(), new Vector3(1, 1, 1));
            }
            getWheelPosition(REVISION) {
                const t = b_(this, KA, 'f').getWheelTransformWS(REVISION).getOrigin();
                return new Vector3(t.x(), t.y(), t.z());
            }
            getWheelQuaternion(REVISION) {
                const t = b_(this, KA, 'f').getWheelTransformWS(REVISION).getRotation();
                return new Quaternion(t.x(), t.y(), t.z(), t.w());
            }
            getWheelInContact(REVISION) {
                return b_(this, KA, 'f').getWheelInfo(REVISION).m_raycastInfo.m_isInContact;
            }
            getWheelSuspensionVelocity(REVISION) {
                return b_(this, KA, 'f').getWheelInfo(REVISION).m_suspensionRelativeVelocity;
            }
            getWheelSuspensionLength(REVISION) {
                return b_(this, KA, 'f').getWheelInfo(REVISION).m_raycastInfo.m_suspensionLength;
            }
            getWheelRotation(REVISION) {
                return b_(this, KA, 'f').getWheelInfo(REVISION).m_rotation;
            }
            getWheelDeltaRotation(REVISION) {
                return b_(this, KA, 'f').getWheelInfo(REVISION).m_deltaRotation;
            }
            getWheelSkidInfo(REVISION) {
                return b_(this, KA, 'f').getWheelInfo(REVISION).m_skidInfo;
            }
            getWheelContactPosition(REVISION) {
                const t = b_(this, KA, 'f').getWheelInfo(REVISION).m_raycastInfo.m_contactPointWS;
                return new Vector3(t.x(), t.y(), t.z());
            }
            getWheelContactNormal(REVISION) {
                const t = b_(this, KA, 'f').getWheelInfo(REVISION).m_raycastInfo.m_contactNormalWS;
                return new Vector3(t.x(), t.y(), t.z());
            }
            getCollisionImpulses() {
                const REVISION = [], t = b_(this, YA, 'f').dispatcher.getNumManifolds();
                for (let n = 0; n < t; ++n) {
                    const t = b_(this, YA, 'f').dispatcher.getManifoldByIndexInternal(n), i = t.getBody0(), r = t.getBody1();
                    if (i.H == b_(this, ZA, 'f').H || r.H == b_(this, ZA, 'f').H) {
                        const n = t.getNumContacts();
                        for (let i = 0; i < n; ++i) {
                            const n = t.getContactPoint(i);
                            REVISION.push(n.getAppliedImpulse());
                        }
                    }
                }
                return REVISION;
            }
            step() {
                var REVISION;
                if (this.hasStarted() && b_(this, h_, 'f').numberOfFrames < Sh.maxFrames) {
                    const t = 1 / Hh.stepsPerSecond, n = b_(this, r_, 'f'), i = b_(this, a_, 'f');
                    (null == b_(this, m_, 'f') || b_(this, m_, 'f').manhattanDistanceTo(n) > 1.5) && (null == b_(this, m_, 'f') ? x_(this, m_, n.clone(), 'f') : b_(this, m_, 'f').copy(n), b_(this, YA, 'f').activePhysicsAt(n)), b_(this, jA, 'm', w_).call(this), b_(this, jA, 'm', y_).call(this, t, b_(this, s_, 'f')), b_(this, YA, 'f').step();
                    const r = b_(this, t_, 'f');
                    b_(this, JA, 'f').getWorldTransform(r);
                    const AddEquation = r.getOrigin(), SubtractEquation = r.getRotation();
                    if (n.set(AddEquation.x(), AddEquation.y(), AddEquation.z()), i.set(SubtractEquation.x(), SubtractEquation.y(), SubtractEquation.z(), SubtractEquation.w()), !this.hasFinished()) {
                        const t = b_(this, i_, 'f');
                        t.center.copy(XA.detectorBoxCenter).applyQuaternion(i).add(n), t.rotation.elements = [
                            1 - 2 * (i.y * i.y + i.z * i.z),
                            2 * (i.x * i.y + i.z * i.w),
                            2 * (i.x * i.z - i.y * i.w),
                            2 * (i.x * i.y - i.z * i.w),
                            1 - 2 * (i.x * i.x + i.z * i.z),
                            2 * (i.y * i.z + i.x * i.w),
                            2 * (i.x * i.z + i.y * i.w),
                            2 * (i.y * i.z - i.x * i.w),
                            1 - 2 * (i.x * i.x + i.y * i.y)
                        ];
                        const r = b_(this, qA, 'f').getTotalNumberOfCheckpointIndices();
                        if (b_(this, d_, 'f') == r)
                            null != b_(this, qA, 'f').checkFinish(t) && x_(this, l_, b_(this, h_, 'f').clone(), 'f');
                        else {
                            const n = b_(this, qA, 'f').checkCheckpoint(t, b_(this, d_, 'f'));
                            if (null != n && (x_(this, d_, (REVISION = b_(this, d_, 'f'), ++REVISION), 'f'), n.rotationAxis == fd.YPositive)) {
                                const REVISION = b_(this, jA, 'm', v_).call(this);
                                let t = n.rotation * Math.PI / 2;
                                (0 == n.rotation && REVISION.z < 0 || 1 == n.rotation && REVISION.x < 0 || 2 == n.rotation && REVISION.z > 0 || 3 == n.rotation && REVISION.x > 0) && (t += Math.PI);
                                const i = new Quaternion().setFromEuler(new Euler(0, t, 0)), r = new Vector3(0, 0.35, -1.35);
                                r.applyQuaternion(i), n.type != dd.CheckpointWide && n.type != dd.PlaneCheckpointWide || r.sub(new Vector3(-10, 0, 0).applyEuler(new Euler(0, n.rotation * Math.PI / 2, 0))), x_(this, u_, {
                                    position: new Vector3(n.x * cd.partSize + r.x, n.y * cd.partSize + r.y, n.z * cd.partSize + r.z),
                                    quaternion: i,
                                    nextCheckpointIndex: b_(this, d_, 'f')
                                }, 'f');
                            }
                        }
                    }
                }
            }
        };
        var E_ = function (REVISION, t, n, i) {
            return new (n || (n = Promise))(function (r, AddEquation) {
                function SubtractEquation(REVISION) {
                    try {
                        ZeroFactor(i.next(REVISION));
                    } catch (REVISION) {
                        AddEquation(REVISION);
                    }
                }
                function ReverseSubtractEquation(REVISION) {
                    try {
                        ZeroFactor(i.throw(REVISION));
                    } catch (REVISION) {
                        AddEquation(REVISION);
                    }
                }
                function ZeroFactor(REVISION) {
                    var t;
                    REVISION.done ? r(REVISION.value) : (t = REVISION.value, t instanceof n ? t : new n(function (REVISION) {
                        REVISION(t);
                    })).then(SubtractEquation, ReverseSubtractEquation);
                }
                ZeroFactor((i = i.apply(REVISION, t || [])).next());
            });
        };
        const M_ = 2.718281828459045, T_ = 2.302585092994046, C_ = 0.6931471805599453, I_ = 1.4426950408889634, R_ = 0.4342944819032518, P_ = 3.141592653589793, B_ = 0.7071067811865476, D_ = 1.4142135623730951;
        function L_(REVISION) {
            throw new Error(REVISION + ': Waiting for WASM to compile');
        }
        function U_(REVISION) {
            throw new Error(REVISION + ': No deterministic implementation');
        }
        function N_(REVISION) {
            if (!Number.isFinite(REVISION))
                return NaN;
            const t = (REVISION = function (REVISION) {
                    return (REVISION %= 2 * Math.PI) < 0 && (REVISION += 2 * Math.PI), REVISION;
                }(REVISION)) / (2 * Math.PI) * F_.length, n = Math.floor(t), i = (n + 1) % F_.length, r = t - n;
            return F_[n] * (1 - r) + F_[i] * r;
        }
        function k_(REVISION) {
            return Math.sin(REVISION + Math.PI / 2);
        }
        Math = {
            E: M_,
            LN10: T_,
            LN2: C_,
            LOG2E: I_,
            LOG10E: R_,
            PI: P_,
            SQRT1_2: B_,
            SQRT2: D_,
            abs: Math.abs,
            acos: () => L_('acos'),
            asin: () => L_('asin'),
            atan: () => L_('atan'),
            atan2: () => L_('atan2'),
            ceil: Math.ceil,
            cos: k_,
            exp: () => L_('exp'),
            floor: Math.floor,
            log: () => L_('log'),
            max: Math.max,
            min: Math.min,
            pow: () => L_('pow'),
            random: Math.random,
            round: Math.round,
            sin: N_,
            sqrt: () => L_('sqrt'),
            tan: () => L_('tan'),
            clz32: () => U_('clz32'),
            imul: () => U_('imul'),
            sign: Math.sign,
            log10: () => L_('log10'),
            log2: () => L_('log2'),
            log1p: () => U_('log1p'),
            expm1: () => U_('expm1'),
            cosh: () => U_('cosh'),
            sinh: () => U_('sinh'),
            tanh: () => U_('tanh'),
            acosh: () => U_('acosh'),
            asinh: () => U_('asinh'),
            atanh: () => U_('atanh'),
            hypot: () => U_('hypot'),
            trunc: Math.trunc,
            cbrt: () => U_('cbrt'),
            fround: Math.fround,
            [Symbol.toStringTag]: 'Math'
        };
        const F_ = [
            0,
            0.01745240643728351,
            0.03489949670250097,
            0.05233595624294383,
            0.0697564737441253,
            0.08715574274765817,
            0.10452846326765346,
            0.12186934340514748,
            0.13917310096006544,
            0.15643446504023087,
            0.17364817766693033,
            0.1908089953765448,
            0.20791169081775931,
            0.22495105434386498,
            0.24192189559966773,
            0.25881904510252074,
            0.27563735581699916,
            0.2923717047227367,
            0.3090169943749474,
            0.3255681544571567,
            0.3420201433256687,
            0.35836794954530027,
            0.374606593415912,
            0.3907311284892737,
            0.40673664307580015,
            0.42261826174069944,
            0.4383711467890774,
            0.45399049973954675,
            0.4694715627858908,
            0.48480962024633706,
            0.49999999999999994,
            0.5150380749100542,
            0.5299192642332049,
            0.544639035015027,
            0.5591929034707468,
            0.573576436351046,
            0.5877852522924731,
            0.6018150231520483,
            0.6156614753256583,
            0.6293203910498375,
            0.6427876096865393,
            0.6560590289905073,
            0.6691306063588582,
            0.6819983600624985,
            0.6946583704589973,
            0.7071067811865475,
            0.7193398003386511,
            0.7313537016191705,
            0.7431448254773942,
            0.7547095802227719,
            0.766044443118978,
            0.7771459614569708,
            0.7880107536067219,
            0.7986355100472928,
            0.8090169943749475,
            0.8191520442889918,
            0.8290375725550417,
            0.8386705679454239,
            0.848048096156426,
            0.8571673007021122,
            0.8660254037844386,
            0.8746197071393957,
            0.8829475928589269,
            0.8910065241883678,
            0.898794046299167,
            0.9063077870366499,
            0.9135454576426009,
            0.9205048534524404,
            0.9271838545667873,
            0.9335804264972017,
            0.9396926207859083,
            0.9455185755993167,
            0.9510565162951535,
            0.9563047559630354,
            0.9612616959383189,
            0.9659258262890683,
            0.9702957262759965,
            0.9743700647852352,
            0.9781476007338057,
            0.981627183447664,
            0.984807753012208,
            0.9876883405951378,
            0.9902680687415704,
            0.992546151641322,
            0.9945218953682733,
            0.9961946980917455,
            0.9975640502598242,
            0.9986295347545738,
            0.9993908270190958,
            0.9998476951563913,
            1,
            0.9998476951563913,
            0.9993908270190958,
            0.9986295347545738,
            0.9975640502598242,
            0.9961946980917455,
            0.9945218953682734,
            0.9925461516413221,
            0.9902680687415704,
            0.9876883405951377,
            0.984807753012208,
            0.981627183447664,
            0.9781476007338057,
            0.9743700647852352,
            0.9702957262759965,
            0.9659258262890683,
            0.9612616959383189,
            0.9563047559630355,
            0.9510565162951536,
            0.9455185755993168,
            0.9396926207859084,
            0.9335804264972017,
            0.9271838545667874,
            0.9205048534524404,
            0.913545457642601,
            0.90630778703665,
            0.8987940462991669,
            0.8910065241883679,
            0.8829475928589271,
            0.8746197071393959,
            0.8660254037844387,
            0.8571673007021123,
            0.8480480961564261,
            0.8386705679454239,
            0.8290375725550417,
            0.819152044288992,
            0.8090169943749475,
            0.7986355100472927,
            0.788010753606722,
            0.777145961456971,
            0.766044443118978,
            0.7547095802227721,
            0.7431448254773945,
            0.7313537016191706,
            0.7193398003386511,
            0.7071067811865476,
            0.6946583704589975,
            0.6819983600624986,
            0.669130606358858,
            0.6560590289905073,
            0.6427876096865395,
            0.6293203910498374,
            0.6156614753256584,
            0.6018150231520486,
            0.5877852522924732,
            0.5735764363510459,
            0.5591929034707469,
            0.5446390350150273,
            0.5299192642332049,
            0.5150380749100544,
            0.49999999999999994,
            0.48480962024633717,
            0.4694715627858907,
            0.45399049973954686,
            0.4383711467890777,
            0.4226182617406995,
            0.40673664307580004,
            0.39073112848927377,
            0.37460659341591224,
            0.35836794954530066,
            0.3420201433256689,
            0.3255681544571566,
            0.3090169943749475,
            0.29237170472273705,
            0.2756373558169992,
            0.258819045102521,
            0.24192189559966773,
            0.2249510543438652,
            0.20791169081775931,
            0.19080899537654497,
            0.1736481776669307,
            0.15643446504023098,
            0.13917310096006533,
            0.12186934340514755,
            0.10452846326765373,
            0.0871557427476582,
            0.06975647374412552,
            0.05233595624294425,
            0.03489949670250114,
            0.01745240643728344,
            1.2246467991473532e-16,
            -0.017452406437283192,
            -0.0348994967025009,
            -0.052335956242943564,
            -0.06975647374412483,
            -0.08715574274765794,
            -0.1045284632676535,
            -0.12186934340514774,
            -0.13917310096006552,
            -0.15643446504023073,
            -0.17364817766693047,
            -0.19080899537654472,
            -0.20791169081775907,
            -0.22495105434386498,
            -0.2419218955996675,
            -0.25881904510252035,
            -0.2756373558169986,
            -0.29237170472273677,
            -0.30901699437494773,
            -0.32556815445715676,
            -0.34202014332566866,
            -0.35836794954530043,
            -0.374606593415912,
            -0.39073112848927355,
            -0.4067366430757998,
            -0.4226182617406993,
            -0.43837114678907707,
            -0.45399049973954625,
            -0.4694715627858905,
            -0.48480962024633734,
            -0.5000000000000001,
            -0.5150380749100542,
            -0.5299192642332048,
            -0.5446390350150271,
            -0.5591929034707467,
            -0.5735764363510458,
            -0.587785252292473,
            -0.601815023152048,
            -0.6156614753256578,
            -0.6293203910498372,
            -0.6427876096865393,
            -0.6560590289905074,
            -0.6691306063588582,
            -0.6819983600624984,
            -0.6946583704589974,
            -0.7071067811865475,
            -0.7193398003386509,
            -0.7313537016191705,
            -0.743144825477394,
            -0.7547095802227717,
            -0.7660444431189779,
            -0.7771459614569711,
            -0.7880107536067221,
            -0.7986355100472928,
            -0.8090169943749473,
            -0.8191520442889916,
            -0.8290375725550414,
            -0.838670567945424,
            -0.848048096156426,
            -0.8571673007021121,
            -0.8660254037844384,
            -0.8746197071393955,
            -0.882947592858927,
            -0.8910065241883678,
            -0.8987940462991668,
            -0.90630778703665,
            -0.913545457642601,
            -0.9205048534524403,
            -0.9271838545667873,
            -0.9335804264972016,
            -0.9396926207859082,
            -0.9455185755993168,
            -0.9510565162951535,
            -0.9563047559630353,
            -0.961261695938319,
            -0.9659258262890683,
            -0.9702957262759965,
            -0.9743700647852351,
            -0.9781476007338056,
            -0.981627183447664,
            -0.984807753012208,
            -0.9876883405951377,
            -0.9902680687415703,
            -0.992546151641322,
            -0.9945218953682733,
            -0.9961946980917455,
            -0.9975640502598242,
            -0.9986295347545739,
            -0.9993908270190958,
            -0.9998476951563913,
            -1,
            -0.9998476951563913,
            -0.9993908270190958,
            -0.9986295347545739,
            -0.9975640502598243,
            -0.9961946980917455,
            -0.9945218953682733,
            -0.992546151641322,
            -0.9902680687415704,
            -0.9876883405951378,
            -0.9848077530122081,
            -0.9816271834476641,
            -0.9781476007338056,
            -0.9743700647852352,
            -0.9702957262759966,
            -0.9659258262890684,
            -0.961261695938319,
            -0.9563047559630354,
            -0.9510565162951536,
            -0.945518575599317,
            -0.9396926207859083,
            -0.9335804264972017,
            -0.9271838545667874,
            -0.9205048534524405,
            -0.9135454576426011,
            -0.9063077870366503,
            -0.898794046299167,
            -0.8910065241883679,
            -0.8829475928589271,
            -0.8746197071393956,
            -0.8660254037844386,
            -0.8571673007021123,
            -0.8480480961564262,
            -0.8386705679454243,
            -0.8290375725550416,
            -0.8191520442889918,
            -0.8090169943749476,
            -0.798635510047293,
            -0.7880107536067223,
            -0.7771459614569713,
            -0.7660444431189781,
            -0.7547095802227722,
            -0.743144825477394,
            -0.7313537016191703,
            -0.7193398003386512,
            -0.7071067811865477,
            -0.6946583704589976,
            -0.6819983600624989,
            -0.6691306063588588,
            -0.6560590289905074,
            -0.6427876096865396,
            -0.6293203910498372,
            -0.6156614753256582,
            -0.6018150231520483,
            -0.5877852522924734,
            -0.5735764363510465,
            -0.5591929034707473,
            -0.544639035015027,
            -0.529919264233205,
            -0.5150380749100545,
            -0.5000000000000004,
            -0.48480962024633767,
            -0.4694715627858908,
            -0.45399049973954697,
            -0.4383711467890778,
            -0.4226182617406992,
            -0.40673664307580015,
            -0.3907311284892739,
            -0.37460659341591235,
            -0.35836794954530077,
            -0.34202014332566943,
            -0.3255681544571567,
            -0.3090169943749477,
            -0.29237170472273716,
            -0.27563735581699894,
            -0.2588190451025207,
            -0.24192189559966787,
            -0.22495105434386534,
            -0.20791169081775987,
            -0.19080899537654467,
            -0.1736481776669304,
            -0.15643446504023112,
            -0.13917310096006588,
            -0.12186934340514811,
            -0.1045284632676543,
            -0.08715574274765832,
            -0.06975647374412564,
            -0.05233595624294348,
            -0.034899496702500823,
            -0.01745240643728356
        ];
        var O_, z_, H_, W_ = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        z_ = new WeakMap(), O_ = new WeakSet(), H_ = function (REVISION) {
            if (REVISION.length % 9 != 0)
                throw new Error('Physics shape vertices length is not dividable by 9');
            const t = new Box3(), n = new Ammo.btTriangleMesh();
            for (let i = 0; i < REVISION.length; i += 9) {
                const r = REVISION[i + 0], AddEquation = REVISION[i + 1], SubtractEquation = REVISION[i + 2], ReverseSubtractEquation = REVISION[i + 3], ZeroFactor = REVISION[i + 4], OneFactor = REVISION[i + 5], SrcColorFactor = REVISION[i + 6], OneMinusSrcColorFactor = REVISION[i + 7], SrcAlphaFactor = REVISION[i + 8], OneMinusSrcAlphaFactor = new Ammo.btVector3(r, AddEquation, SubtractEquation), DstAlphaFactor = new Ammo.btVector3(ReverseSubtractEquation, ZeroFactor, OneFactor), OneMinusDstAlphaFactor = new Ammo.btVector3(SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor);
                n.addTriangle(OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor), Ammo.destroy(OneMinusSrcAlphaFactor), Ammo.destroy(DstAlphaFactor), Ammo.destroy(OneMinusDstAlphaFactor), t.expandByPoint(new Vector3(r, AddEquation, SubtractEquation)), t.expandByPoint(new Vector3(ReverseSubtractEquation, ZeroFactor, OneFactor)), t.expandByPoint(new Vector3(SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor));
            }
            const i = new Ammo.btBvhTriangleMeshShape(n);
            return i.setMargin(0.01), {
                boundingBox: t,
                shape: i,
                triangleMesh: n
            };
        };
        const V_ = class {
            constructor(REVISION) {
                O_.add(this), z_.set(this, new Map());
                for (const {
                            id: t,
                            vertices: n,
                            detector: i,
                            startOffset: r
                        } of REVISION) {
                    const {
                        boundingBox: REVISION,
                        shape: AddEquation,
                        triangleMesh: SubtractEquation
                    } = W_(this, O_, 'm', H_).call(this, n);
                    W_(this, z_, 'f').set(t, {
                        boundingBox: REVISION,
                        shape: AddEquation,
                        triangleMesh: SubtractEquation,
                        detector: null != i ? {
                            type: i.type,
                            center: new Vector3(i.center[0], i.center[1], i.center[2]),
                            size: new Vector3(i.size[0], i.size[1], i.size[2])
                        } : null,
                        startOffset: null != r ? new Vector3(r[0], r[1], r[2]) : null
                    });
                }
            }
            dispose() {
                for (const {
                            shape: REVISION,
                            triangleMesh: t
                        } of W_(this, z_, 'f').values())
                    Ammo.destroy(REVISION), Ammo.destroy(t);
                W_(this, z_, 'f').clear();
            }
            getPhysicsShape(REVISION) {
                const t = W_(this, z_, 'f').get(REVISION);
                if (null == t)
                    throw new Error('Track part with the id "' + REVISION.toString() + '" has no physics model');
                return {
                    boundingBox: t.boundingBox.clone(),
                    shape: t.shape
                };
            }
            getPartTypesWithDetector(REVISION) {
                const t = [];
                for (const [n, i] of W_(this, z_, 'f').entries())
                    null != i.detector && i.detector.type == REVISION && t.push(n);
                return t;
            }
            getStartPartTypes() {
                const REVISION = [];
                for (const [t, n] of W_(this, z_, 'f').entries())
                    null != n.startOffset && REVISION.push(t);
                return REVISION;
            }
            getPartStartOffset(REVISION) {
                var t, n;
                const i = W_(this, z_, 'f').get(REVISION);
                if (null == i)
                    throw new Error('Track part with the id "' + REVISION.toString() + '" does not exist');
                return null !== (n = null === (t = i.startOffset) || void 0 === t ? void 0 : t.clone()) && void 0 !== n ? n : null;
            }
            getDetector(REVISION) {
                const t = W_(this, z_, 'f').get(REVISION);
                if (null == t)
                    throw new Error('Track part with the id "' + REVISION.toString() + '" does not exist');
                return t.detector;
            }
        };
        var G_;
        !function (REVISION) {
            REVISION[REVISION.Init = 0] = 'Init', REVISION[REVISION.Verify = 1] = 'Verify', REVISION[REVISION.TestDeterminism = 2] = 'TestDeterminism', REVISION[REVISION.CreateCar = 3] = 'CreateCar', REVISION[REVISION.DeleteCar = 4] = 'DeleteCar', REVISION[REVISION.StartCar = 5] = 'StartCar', REVISION[REVISION.ControlCar = 6] = 'ControlCar', REVISION[REVISION.PauseCar = 7] = 'PauseCar', REVISION[REVISION.VerifyResult = 8] = 'VerifyResult', REVISION[REVISION.DeterminismResult = 9] = 'DeterminismResult', REVISION[REVISION.UpdateResult = 10] = 'UpdateResult';
        }(G_ || (G_ = {}));
        const Q_ = G_;
        var X_, j_ = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, q_ = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        X_ = new WeakMap();
        const Y_ = class {
            constructor(REVISION) {
                X_.set(this, void 0), j_(this, X_, REVISION, 'f');
            }
            dispose() {
            }
            getControls(REVISION) {
                return q_(this, X_, 'f').getFrame(REVISION);
            }
        };
        var K_ = n(1312);
        const Z_ = [
                'A',
                'B',
                'C',
                'D',
                'E',
                'F',
                'G',
                'H',
                'I',
                'J',
                'K',
                'L',
                'M',
                'N',
                'O',
                'P',
                'Q',
                'R',
                'S',
                'T',
                'U',
                'V',
                'W',
                'X',
                'Y',
                'Z',
                'a',
                'b',
                'c',
                'd',
                'e',
                'f',
                'g',
                'h',
                'i',
                'j',
                'k',
                'l',
                'm',
                'n',
                'o',
                'p',
                'q',
                'r',
                's',
                't',
                'u',
                'v',
                'w',
                'x',
                'y',
                'z',
                '0',
                '1',
                '2',
                '3',
                '4',
                '5',
                '6',
                '7',
                '8',
                '9'
            ], J_ = [
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51
            ];
        function $_(REVISION) {
            let t = 0, n = '';
            for (; t < 8 * REVISION.length;) {
                const i = tv(REVISION, t);
                let r;
                30 & ~i ? (r = i, t += 6) : (r = 31 & i, t += 5), n += Z_[r];
            }
            return n;
        }
        function ev(REVISION) {
            let t = 0;
            const n = [], i = REVISION.length;
            for (let r = 0; r < i; r++) {
                const AddEquation = REVISION.charCodeAt(r);
                if (AddEquation >= J_.length)
                    return null;
                const SubtractEquation = J_[AddEquation];
                if (-1 == SubtractEquation)
                    return null;
                30 & ~SubtractEquation ? (nv(n, t, 6, SubtractEquation, r == i - 1), t += 6) : (nv(n, t, 5, SubtractEquation, r == i - 1), t += 5);
            }
            return new Uint8Array(n);
        }
        function tv(REVISION, t) {
            if (t >= 8 * REVISION.length)
                throw new Error('Out of range');
            const n = Math.floor(t / 8), i = REVISION[n], r = t - 8 * n;
            if (r <= 2 || n >= REVISION.length - 1)
                return (i & 63 << r) >>> r;
            return (i & 63 << r) >>> r | (REVISION[n + 1] & 63 >>> 8 - r) << 8 - r;
        }
        function nv(REVISION, t, n, i, r) {
            const AddEquation = Math.floor(t / 8);
            for (; AddEquation >= REVISION.length;)
                REVISION.push(0);
            const SubtractEquation = t - 8 * AddEquation;
            if (REVISION[AddEquation] |= i << SubtractEquation & 255, SubtractEquation > 8 - n && !r) {
                const t = AddEquation + 1;
                t >= REVISION.length && REVISION.push(0), REVISION[t] |= i >> 8 - SubtractEquation;
            }
        }
        var iv, rv = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, av = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class sv {
            constructor(REVISION = 28) {
                if (iv.set(this, void 0), !(Number.isSafeInteger(REVISION) && REVISION >= 0 && REVISION < 180))
                    throw new Error('Representation is not a safe integer or is out of range');
                rv(this, iv, REVISION, 'f');
            }
            clone() {
                return new sv(av(this, iv, 'f'));
            }
            toDegrees() {
                return 2 * av(this, iv, 'f');
            }
            static fromDegrees(REVISION) {
                const t = Math.round(REVISION / 2 % 180);
                return new sv(t);
            }
            getSunPosition() {
                const REVISION = 2 * av(this, iv, 'f') * (Math.PI / 180), t = Math.cos(REVISION), n = Math.sin(REVISION);
                return new Vector3(t, 0.78, n).normalize();
            }
            get representation() {
                return av(this, iv, 'f');
            }
        }
        iv = new WeakMap();
        const ov = sv;
        var lv;
        !function (REVISION) {
            REVISION[REVISION.Summer = 0] = 'Summer', REVISION[REVISION.Winter = 1] = 'Winter', REVISION[REVISION.Desert = 2] = 'Desert';
        }(lv || (lv = {}));
        const cv = lv;
        var hv;
        !function (REVISION) {
            REVISION[REVISION.Default = 0] = 'Default', REVISION[REVISION.Summer = 1] = 'Summer', REVISION[REVISION.Winter = 2] = 'Winter', REVISION[REVISION.Desert = 3] = 'Desert', REVISION[REVISION.Custom0 = 32] = 'Custom0', REVISION[REVISION.Custom1 = 33] = 'Custom1', REVISION[REVISION.Custom2 = 34] = 'Custom2', REVISION[REVISION.Custom3 = 35] = 'Custom3', REVISION[REVISION.Custom4 = 36] = 'Custom4', REVISION[REVISION.Custom5 = 37] = 'Custom5', REVISION[REVISION.Custom6 = 38] = 'Custom6', REVISION[REVISION.Custom7 = 39] = 'Custom7', REVISION[REVISION.Custom8 = 40] = 'Custom8';
        }(hv || (hv = {}));
        const dv = hv;
        var uv;
        !function (REVISION) {
            REVISION[REVISION.Special = 0] = 'Special', REVISION[REVISION.Road = 1] = 'Road', REVISION[REVISION.RoadTurns = 2] = 'RoadTurns', REVISION[REVISION.RoadWide = 3] = 'RoadWide', REVISION[REVISION.Plane = 4] = 'Plane', REVISION[REVISION.Block = 5] = 'Block', REVISION[REVISION.WallTrack = 6] = 'WallTrack', REVISION[REVISION.Pillar = 7] = 'Pillar', REVISION[REVISION.Sign = 8] = 'Sign';
        }(uv || (uv = {}));
        const fv = uv;
        var pv, mv = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, gv = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class Av {
            constructor(REVISION) {
                pv.set(this, void 0);
                const t = [];
                for (const [n, i, r] of REVISION)
                    t.push([
                        n,
                        i,
                        r
                    ]);
                mv(this, pv, t, 'f');
            }
            rotated(REVISION, t) {
                const n = t == fd.YNegative || t == fd.XNegative || t == fd.ZNegative;
                return new Av(gv(this, pv, 'f').map(([i, r, AddEquation]) => {
                    if (n)
                        switch (REVISION) {
                        case 0:
                            break;
                        case 1:
                            [i, AddEquation] = [
                                -AddEquation - 1,
                                i
                            ];
                            break;
                        case 2:
                            [i, AddEquation] = [
                                -i - 1,
                                -AddEquation - 1
                            ];
                            break;
                        case 3:
                            [i, AddEquation] = [
                                AddEquation,
                                -i - 1
                            ];
                            break;
                        default:
                            throw new Error('Invalid rotation');
                        }
                    else
                        switch (REVISION) {
                        case 0:
                            break;
                        case 1:
                            [i, AddEquation] = [
                                AddEquation,
                                -i - 1
                            ];
                            break;
                        case 2:
                            [i, AddEquation] = [
                                -i - 1,
                                -AddEquation - 1
                            ];
                            break;
                        case 3:
                            [i, AddEquation] = [
                                -AddEquation - 1,
                                i
                            ];
                            break;
                        default:
                            throw new Error('Invalid rotation');
                        }
                    return t == fd.YPositive || (t == fd.YNegative ? [i, r] = [
                        -i - 1,
                        -r - 1
                    ] : t == fd.XPositive ? [i, r] = [
                        r,
                        -i - 1
                    ] : t == fd.XNegative ? [i, r] = [
                        -r - 1,
                        i
                    ] : t == fd.ZPositive ? [r, AddEquation] = [
                        -AddEquation - 1,
                        r
                    ] : [r, AddEquation] = [
                        AddEquation,
                        -r - 1
                    ]), [
                        i,
                        r,
                        AddEquation
                    ];
                }));
            }
            forEach(REVISION) {
                for (let t = 0; t < gv(this, pv, 'f').length; t++) {
                    const [n, i, r] = gv(this, pv, 'f')[t];
                    REVISION(n, i, r, t);
                }
            }
            get length() {
                return gv(this, pv, 'f').length;
            }
        }
        pv = new WeakMap();
        const _v = Av, vv = [
                {
                    id: dv.Summer,
                    colors: {}
                },
                {
                    id: dv.Winter,
                    colors: {
                        Road: '#5077b2',
                        RoadBarrier: '#898989',
                        RoadEdgeWhite: '#ffffff',
                        RoadEdgeRed: '#1f3d6b',
                        BlockSurface: '#878787',
                        Pillar: '#2b4d7f',
                        PillarEdge: '#071428',
                        WallTrack: '#5077b2',
                        WallTrackBottom: '#878787',
                        WallTrackSides: '#ffffff',
                        PlaneWall: '#1f3d6b',
                        PlaneWallDetail: '#878787',
                        SignYellow: '#1b2a89',
                        SignRed: '#841901',
                        SignBlack: '#5077b2'
                    }
                },
                {
                    id: dv.Desert,
                    colors: {
                        Road: '#997240',
                        RoadBarrier: '#211001',
                        RoadEdgeRed: '#5b2424',
                        RoadEdgeWhite: '#510808',
                        BlockSurface: '#b78f5b',
                        Pillar: '#99713d',
                        PillarEdge: '#1c1105',
                        WallTrack: '#260b0b',
                        WallTrackBottom: '#160606',
                        WallTrackSides: '#75562e',
                        PlaneWall: '#633030',
                        PlaneWallDetail: '#aa8a53',
                        SignYellow: '#997240',
                        SignRed: '#d80202',
                        SignBlack: '#601d1d'
                    }
                }
            ], wv = vv.concat([
                {
                    id: dv.Custom0,
                    colors: { BlockSurface: '#131313' }
                },
                {
                    id: dv.Custom1,
                    colors: { BlockSurface: '#501b1b' }
                },
                {
                    id: dv.Custom2,
                    colors: { BlockSurface: '#7f4d2b' }
                },
                {
                    id: dv.Custom3,
                    colors: { BlockSurface: '#93862d' }
                },
                {
                    id: dv.Custom4,
                    colors: { BlockSurface: '#2a5e30' }
                },
                {
                    id: dv.Custom5,
                    colors: { BlockSurface: '#236363' }
                },
                {
                    id: dv.Custom6,
                    colors: { BlockSurface: '#20244b' }
                },
                {
                    id: dv.Custom7,
                    colors: { BlockSurface: '#592759' }
                },
                {
                    id: dv.Custom8,
                    colors: { BlockSurface: '#302318' }
                }
            ]);
        class yv {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation = null, ReverseSubtractEquation = null) {
                const ZeroFactor = [];
                for (const [REVISION, t] of AddEquation)
                    for (let n = REVISION[0]; n <= t[0]; n++)
                        for (let i = REVISION[1]; i <= t[1]; i++)
                            for (let r = REVISION[2]; r <= t[2]; r++) {
                                if (null != ZeroFactor.find(([REVISION, t, AddEquation]) => REVISION == n && t == i && AddEquation == r))
                                    throw new Error('Duplicate tile in track part');
                                ZeroFactor.push([
                                    n,
                                    i,
                                    r
                                ]);
                            }
                this.checksum = REVISION, this.category = t, this.id = n, this.models = i, this.colors = r, this.tiles = new _v(ZeroFactor), this.detector = SubtractEquation, this.startOffset = ReverseSubtractEquation, Object.freeze(this);
            }
        }
        const xv = [
                new yv('6d94d798abd14dc3bce4e99c180309d993ad43adb5f2c90eef8e350eedafe7cf', fv.Special, dd.Start, [[
                        'Road',
                        'Start'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]], null, new Vector3(0, 0.35, 1.35)),
                new yv('f29e34b2e05e0a4751109ae564b03fe8878a79cc6b26288f1117ed296d09c5bb', fv.Special, dd.StartWide, [[
                        'RoadWide',
                        'StartWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            5,
                            0,
                            1
                        ]
                    ]], null, new Vector3(-10, 0.35, 1.35)),
                new yv('3c304054f415fbede4f73a43517db04302f38b16fa2cd4e587082b37b75e20e5', fv.Special, dd.PlaneStart, [[
                        'Planes',
                        'PlaneStart'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]], null, new Vector3(0, 0.35, 1.35)),
                new yv('f08710416bdaa3d91d0d43f014e45d421fdb4587a334993bad0056f3dbbcb6bb', fv.Special, dd.PlaneStartWide, [[
                        'Planes',
                        'PlaneStartWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            5,
                            0,
                            1
                        ]
                    ]], null, new Vector3(-10, 0.35, 1.35)),
                new yv('223fc87c72bb64b58677062ffa08ab7eafd78071bced7c53233606763cd5316b', fv.Special, dd.Checkpoint, [[
                        'Road',
                        'Checkpoint'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Checkpoint,
                    center: [
                        0,
                        2.2,
                        0
                    ],
                    size: [
                        10.5,
                        3.8,
                        1
                    ]
                }),
                new yv('82d9a9879cee92c04c8d4ba2e16fc31bb1917a31f5802a3bb5177ca9a5cfee01', fv.Special, dd.CheckpointWide, [[
                        'RoadWide',
                        'CheckpointWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            5,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Checkpoint,
                    center: [
                        10,
                        2.2,
                        0
                    ],
                    size: [
                        30.6,
                        3.8,
                        1
                    ]
                }),
                new yv('fe8946d7f09724b5e11f493eb5c2a5b5e3d502b15beaad003f8134ac63558948', fv.Special, dd.PlaneCheckpoint, [[
                        'Planes',
                        'PlaneCheckpoint'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Checkpoint,
                    center: [
                        0,
                        2.2,
                        0
                    ],
                    size: [
                        18.25,
                        3.8,
                        1
                    ]
                }),
                new yv('d486d9b851db35dd44c15f9e0bb3bf582118daf7be514598a19307f61cf46678', fv.Special, dd.PlaneCheckpointWide, [[
                        'Planes',
                        'PlaneCheckpointWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            5,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Checkpoint,
                    center: [
                        10,
                        2.2,
                        0
                    ],
                    size: [
                        38.25,
                        3.8,
                        1
                    ]
                }),
                new yv('c01200d573a3594a6a4cb73ebb600964d653e4a89267d3297f3969220742aa79', fv.Special, dd.Finish, [[
                        'Road',
                        'Finish'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Finish,
                    center: [
                        0,
                        2.2,
                        0
                    ],
                    size: [
                        10.5,
                        3.8,
                        2
                    ]
                }),
                new yv('a9cefdff816e94a643210c58582c2809de0e3e0e0478b8d5baabd7fe81f13e73', fv.Special, dd.FinishWide, [[
                        'RoadWide',
                        'FinishWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            5,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Finish,
                    center: [
                        10,
                        2.2,
                        0
                    ],
                    size: [
                        30.6,
                        3.8,
                        2
                    ]
                }),
                new yv('75e5f09fe8a18ecafaf1fb80929173ef0a7dc0b785596bbe0ccd85a934d79578', fv.Special, dd.PlaneFinish, [[
                        'Planes',
                        'PlaneFinish'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Finish,
                    center: [
                        0,
                        2.2,
                        0
                    ],
                    size: [
                        18.25,
                        3.8,
                        2
                    ]
                }),
                new yv('5801b3268c75809728c63450d06000c5f6fcfd5d72691902f99d7d19d25e1d78', fv.Special, dd.PlaneFinishWide, [[
                        'Planes',
                        'PlaneFinishWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            5,
                            0,
                            1
                        ]
                    ]], {
                    type: qh.Finish,
                    center: [
                        10,
                        2.2,
                        0
                    ],
                    size: [
                        38.25,
                        3.8,
                        2
                    ]
                }),
                new yv('3421096c1986d008da88b5fac64cd4c475603138c9bf8a98ab6d581dda6befa7', fv.Road, dd.Straight, [[
                        'Road',
                        'Straight'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('bdc3bcdafec9bc26835dc76159f7223da7da5babb3a5770129fa11046c748b69', fv.Road, dd.StraightPillarBottom, [
                    [
                        'Road',
                        'Straight'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarBottom'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('2758e984d87b3170f6618c9c689554ef169fd5f80ea7f0df292ffd69792d414e', fv.Road, dd.StraightPillarShort, [
                    [
                        'Road',
                        'Straight'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarShort'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('fb5a81784022cfc2d3d0007a032976c8dfd066e72a3bc92f671c98c5cca36aaa', fv.Road, dd.TurnSharp, [[
                        'Road',
                        'TurnSharp'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('3da2e9a93da06b1376c33486f30a5f02d8c2f125f5b7d8b41166049ecd95f269', fv.Road, dd.TurnSharpPillarBottom, [
                    [
                        'Road',
                        'TurnSharp'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarBottom'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('c642122276547382e37dcb857b130088f4dc0d208dc7fdb6055b2a93080a3ffe', fv.Road, dd.TurnSharpPillarShort, [
                    [
                        'Road',
                        'TurnSharp'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarShort'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('110efb0facc096e1c875e545b075b0effaa1b78d50b97f906aec44796501544b', fv.RoadTurns, dd.TurnShort, [[
                        'Road',
                        'TurnShort'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            2,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            3,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -3
                        ],
                        [
                            5,
                            0,
                            -3
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -4
                        ],
                        [
                            5,
                            0,
                            -4
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -5
                        ],
                        [
                            5,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            3,
                            0,
                            -6
                        ],
                        [
                            5,
                            0,
                            -6
                        ]
                    ]
                ]),
                new yv('20a164840b0e83f3eac96ba9e3650a30e3b3dec4bb635946e3e9e9a1b74820d2', fv.RoadTurns, dd.TurnLong, [[
                        'Road',
                        'TurnLong'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            2,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -3
                        ],
                        [
                            2,
                            0,
                            -3
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -4
                        ],
                        [
                            3,
                            0,
                            -4
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -5
                        ],
                        [
                            4,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -6
                        ],
                        [
                            6,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -7
                        ],
                        [
                            9,
                            0,
                            -7
                        ]
                    ],
                    [
                        [
                            3,
                            0,
                            -8
                        ],
                        [
                            9,
                            0,
                            -8
                        ]
                    ],
                    [
                        [
                            4,
                            0,
                            -9
                        ],
                        [
                            9,
                            0,
                            -9
                        ]
                    ],
                    [
                        [
                            7,
                            0,
                            -10
                        ],
                        [
                            9,
                            0,
                            -10
                        ]
                    ]
                ]),
                new yv('c36dddde35a740c6f01227522bf35e1a450cddbfdd8bde1617873bef0d47c95c', fv.RoadTurns, dd.TurnLong2, [[
                        'Road',
                        'TurnLong2'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -4
                        ],
                        [
                            2,
                            0,
                            -3
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -5
                        ],
                        [
                            3,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -6
                        ],
                        [
                            4,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -7
                        ],
                        [
                            5,
                            0,
                            -7
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -8
                        ],
                        [
                            6,
                            0,
                            -8
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -9
                        ],
                        [
                            7,
                            0,
                            -9
                        ]
                    ],
                    [
                        [
                            3,
                            0,
                            -10
                        ],
                        [
                            9,
                            0,
                            -10
                        ]
                    ],
                    [
                        [
                            4,
                            0,
                            -11
                        ],
                        [
                            13,
                            0,
                            -11
                        ]
                    ],
                    [
                        [
                            5,
                            0,
                            -12
                        ],
                        [
                            13,
                            0,
                            -12
                        ]
                    ],
                    [
                        [
                            7,
                            0,
                            -13
                        ],
                        [
                            13,
                            0,
                            -13
                        ]
                    ],
                    [
                        [
                            10,
                            0,
                            -14
                        ],
                        [
                            13,
                            0,
                            -14
                        ]
                    ]
                ]),
                new yv('0ed20c04a941708c23fe6ced4af3f357c0e435f09278e06f3de2806786d44059', fv.RoadTurns, dd.TurnLong3, [[
                        'Road',
                        'TurnLong3'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -4
                        ],
                        [
                            2,
                            0,
                            -3
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -5
                        ],
                        [
                            2,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -6
                        ],
                        [
                            3,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -7
                        ],
                        [
                            3,
                            0,
                            -7
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -8
                        ],
                        [
                            4,
                            0,
                            -8
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -9
                        ],
                        [
                            5,
                            0,
                            -9
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -10
                        ],
                        [
                            6,
                            0,
                            -10
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -11
                        ],
                        [
                            7,
                            0,
                            -11
                        ]
                    ],
                    [
                        [
                            3,
                            0,
                            -12
                        ],
                        [
                            8,
                            0,
                            -12
                        ]
                    ],
                    [
                        [
                            4,
                            0,
                            -13
                        ],
                        [
                            10,
                            0,
                            -13
                        ]
                    ],
                    [
                        [
                            5,
                            0,
                            -14
                        ],
                        [
                            13,
                            0,
                            -14
                        ]
                    ],
                    [
                        [
                            7,
                            0,
                            -15
                        ],
                        [
                            17,
                            0,
                            -15
                        ]
                    ],
                    [
                        [
                            8,
                            0,
                            -16
                        ],
                        [
                            17,
                            0,
                            -16
                        ]
                    ],
                    [
                        [
                            11,
                            0,
                            -17
                        ],
                        [
                            17,
                            0,
                            -17
                        ]
                    ],
                    [
                        [
                            14,
                            0,
                            -18
                        ],
                        [
                            17,
                            0,
                            -18
                        ]
                    ]
                ]),
                new yv('034ef287319877f2fcc32fbd6f32415539a4c287dfcd620360386a781adad22a', fv.RoadTurns, dd.TurnSLeft, [[
                        'Road',
                        'TurnS',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -3,
                            0,
                            -3
                        ],
                        [
                            0,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -4,
                            0,
                            -4
                        ],
                        [
                            0,
                            0,
                            -4
                        ]
                    ],
                    [
                        [
                            -5,
                            0,
                            -5
                        ],
                        [
                            -1,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            -5,
                            0,
                            -7
                        ],
                        [
                            -2,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            -6,
                            0,
                            -10
                        ],
                        [
                            -3,
                            0,
                            -8
                        ]
                    ]
                ]),
                new yv('0d49e9feb603d0899927c7e5184f4f4fdd4363d2e1fd296f0b7b3cf4dbbf0e8d', fv.RoadTurns, dd.TurnSRight, [[
                        'Road',
                        'TurnS'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -3
                        ],
                        [
                            2,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -4
                        ],
                        [
                            3,
                            0,
                            -4
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -5
                        ],
                        [
                            4,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -7
                        ],
                        [
                            4,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -10
                        ],
                        [
                            5,
                            0,
                            -8
                        ]
                    ]
                ]),
                new yv('26bca19e63867bc0b755ff6fcca65de296c9d1f109f87540103565eb88a0e03d', fv.RoadTurns, dd.TurnShortLeftWide, [[
                        'RoadWide',
                        'TurnShortLeftWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -4
                        ],
                        [
                            5,
                            0,
                            -3
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -5
                        ],
                        [
                            5,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -6
                        ],
                        [
                            5,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -7
                        ],
                        [
                            9,
                            0,
                            -7
                        ]
                    ],
                    [
                        [
                            3,
                            0,
                            -8
                        ],
                        [
                            9,
                            0,
                            -8
                        ]
                    ],
                    [
                        [
                            4,
                            0,
                            -9
                        ],
                        [
                            9,
                            0,
                            -9
                        ]
                    ],
                    [
                        [
                            7,
                            0,
                            -10
                        ],
                        [
                            9,
                            0,
                            -10
                        ]
                    ]
                ]),
                new yv('e3845854f85dafd8cec193bcbecdac6cb79f625066de29524d5c10c5580611c5', fv.RoadTurns, dd.TurnShortRightWide, [[
                        'RoadWide',
                        'TurnShortRightWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            2,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            3,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -6
                        ],
                        [
                            5,
                            0,
                            -3
                        ]
                    ]
                ]),
                new yv('dc6088960a65a55c74353a1e7c8a1ca8ec99e683f6273bf666d6909b288bb84b', fv.RoadTurns, dd.TurnLongLeftWide, [[
                        'RoadWide',
                        'TurnLongLeftWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -5
                        ],
                        [
                            1,
                            0,
                            -3
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -6
                        ],
                        [
                            1,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -7
                        ],
                        [
                            5,
                            0,
                            -7
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -8
                        ],
                        [
                            5,
                            0,
                            -8
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -9
                        ],
                        [
                            5,
                            0,
                            -9
                        ]
                    ],
                    [
                        [
                            3,
                            0,
                            -10
                        ],
                        [
                            5,
                            0,
                            -10
                        ]
                    ],
                    [
                        [
                            4,
                            0,
                            -11
                        ],
                        [
                            13,
                            0,
                            -11
                        ]
                    ],
                    [
                        [
                            5,
                            0,
                            -12
                        ],
                        [
                            13,
                            0,
                            -12
                        ]
                    ],
                    [
                        [
                            7,
                            0,
                            -13
                        ],
                        [
                            13,
                            0,
                            -13
                        ]
                    ],
                    [
                        [
                            10,
                            0,
                            -14
                        ],
                        [
                            13,
                            0,
                            -14
                        ]
                    ]
                ]),
                new yv('0bbb8d6c1e4a325e10643cf45546da725c1ea18e92a3a95f753339629a06ef6c', fv.RoadTurns, dd.TurnLongRightWide, [[
                        'RoadWide',
                        'TurnLongRightWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -3
                        ],
                        [
                            2,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -4
                        ],
                        [
                            3,
                            0,
                            -4
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -5
                        ],
                        [
                            4,
                            0,
                            -5
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -6
                        ],
                        [
                            6,
                            0,
                            -6
                        ]
                    ],
                    [
                        [
                            2,
                            0,
                            -10
                        ],
                        [
                            9,
                            0,
                            -7
                        ]
                    ]
                ]),
                new yv('7d8d1eed719515ba7e48b5ef4a53b6b4bb2bef42496b6b40d2551230435ecb66', fv.Road, dd.SlopeUp, [[
                        'Road',
                        'SlopeUp'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('d6d54dbf283f7209032541fc6b924dc879d914f253e391cf8b34dde8354661be', fv.Road, dd.SlopeUpLong, [[
                        'Road',
                        'SlopeUpLong'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -4
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -5
                        ],
                        [
                            1,
                            1,
                            -4
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -6
                        ],
                        [
                            1,
                            2,
                            -6
                        ]
                    ]
                ]),
                new yv('435e8cf33d28e52f75890cba1cb6529991148afd701f9b40e9ab876c11b2c448', fv.Road, dd.SlopeDown, [[
                        'Road',
                        'SlopeDown'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('01990158f65e5d499030d8c6d0ce80d34c136189ae1a9430d4260ea7a85e91a9', fv.Road, dd.SlopeDownLong, [[
                        'Road',
                        'SlopeDownLong'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            5
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            3
                        ],
                        [
                            1,
                            2,
                            5
                        ]
                    ]
                ]),
                new yv('4afecc8b9bd7a3b074112008831fef6b11f9a55ab8c1e570e3e73c1e92b43c6d', fv.Road, dd.Slope, [[
                        'Road',
                        'Slope'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ]
                ]),
                new yv('27f9b25126b1006514941bd148c8f19dc2d82022b0c1aa2358f36cb711d4b59c', fv.Road, dd.SlopePillar, [
                    [
                        'Road',
                        'Slope'
                    ],
                    [
                        'Pillar',
                        'PillarTopSlope'
                    ]
                ], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('eb236f0ac4bd895c170db53cb518c8df5167a9db5af4bb4f33f73c02deec5265', fv.Road, dd.SlopePillarShort, [
                    [
                        'Road',
                        'Slope'
                    ],
                    [
                        'Pillar',
                        'PillarShortSlope'
                    ]
                ], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('99cb9068cb3f97e7cbfdbb3f1edc1085ea37514f3d5dd8936bc32089cc066a5c', fv.Road, dd.SlopeUpVertical, [[
                        'Road',
                        'SlopeUpVertical'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('63628b23e104a3eb3c2ba8189cd408a10fbb6ebcd6fa4359d981e3c3804c13d8', fv.Road, dd.IntersectionT, [[
                        'Road',
                        'IntersectionT'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('400dc4643653001d283bb13f740593fc2300c547bb4d2a962054ba6aabf3721c', fv.Road, dd.IntersectionTPillarBottom, [
                    [
                        'Road',
                        'IntersectionT'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarBottom'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('60355388650d35fcbddaaac29e0d03bc2ae46db1a05cd23ddd3f2722ec2d409e', fv.Road, dd.IntersectionTPillarShort, [
                    [
                        'Road',
                        'IntersectionT'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarShort'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('74197b3731c2befd03498bf5172859f0b3652f1972c19e43a99bb938769573df', fv.Road, dd.IntersectionCross, [[
                        'Road',
                        'IntersectionCross'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('464e69b5c4f2667c246ade9ed33fd3e50b49438ed0ab787a086dfe74c217ff6c', fv.Road, dd.IntersectionCrossPillarBottom, [
                    [
                        'Road',
                        'IntersectionCross'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarBottom'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('90004caf354627289265314966f11b5656e6879ca7de10507e6c50cd95254b75', fv.Road, dd.IntersectionCrossPillarShort, [
                    [
                        'Road',
                        'IntersectionCross'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarShort'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('2af8aa6050028dd6ee69b7150e83a6d8819e1848a7b1c782848d3f6448c5091a', fv.RoadWide, dd.ToWideMiddle, [[
                        'RoadWide',
                        'ToWideMiddle'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('26341cfe6bec34f46b10ffcd9a7706a8156b9ac41ed2cdfd166f9f8d3e9bc8f3', fv.RoadWide, dd.ToWideLeft, [[
                        'RoadWide',
                        'ToWideSide',
                        { flipX: !0 }
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('3f82ebd6c72110b532a20673f8b54c7b25ae5988a51d3793bf383fea8ffcffc3', fv.RoadWide, dd.ToWideRight, [[
                        'RoadWide',
                        'ToWideSide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('f5cecce9870f41f8cba7a9fbe631c315370a7a82824d04977ec857dbb1dfed29', fv.RoadWide, dd.ToWideDouble, [[
                        'RoadWide',
                        'ToWideDouble'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('99dc726611397f81b47459d32c7bfb8232322d1ca976ba9a3e71cc15451d8cfb', fv.RoadWide, dd.ToWideDiagonal, [[
                        'RoadWide',
                        'ToWideDiagonal'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('47d7e3fb334681911e122babef127881a36a763fb22176854114495802d5ce84', fv.RoadWide, dd.StraightWide, [[
                        'RoadWide',
                        'StraightWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('521adc95ed5a4809eeff7eec872c3d6449e4d6a7e4941d672f1e06a50a6615de', fv.RoadWide, dd.InnerCornerWide, [[
                        'RoadWide',
                        'InnerCornerWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('d82274b362794e3c1772510002d5015dde345f1e72dd675c8bac41cf2331398b', fv.RoadWide, dd.OuterCornerWide, [[
                        'RoadWide',
                        'OuterCornerWide'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('9b1df4dd4687404adb5789f3b90af39ea6fa65ef741a07b116dc436dc14a2aa1', fv.RoadWide, dd.SlopeUpLeftWide, [[
                        'RoadWide',
                        'SlopeUpWide',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('651d4e988913b84359ad10e0c4745965b6a388eaa8c9bfbba4b6a50ae6d4f592', fv.RoadWide, dd.SlopeUpRightWide, [[
                        'RoadWide',
                        'SlopeUpWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('848d9930c58e66152090d7853af87c8bb7971e1771d3c337ac1a50aaa4975a78', fv.RoadWide, dd.SlopeUpLongLeftWide, [[
                        'RoadWide',
                        'SlopeUpLongWide',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -4
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -5
                        ],
                        [
                            1,
                            1,
                            -4
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -6
                        ],
                        [
                            1,
                            2,
                            -6
                        ]
                    ]
                ]),
                new yv('e4d54c6c3b6011a1acfb6766b6b3e7ea0de6f9c6569a5ec88c47968ad4105b2a', fv.RoadWide, dd.SlopeUpLongRightWide, [[
                        'RoadWide',
                        'SlopeUpLongWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -4
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -5
                        ],
                        [
                            1,
                            1,
                            -4
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -6
                        ],
                        [
                            1,
                            2,
                            -6
                        ]
                    ]
                ]),
                new yv('106ad1d4c5aded30cc3ef4cd1bdc40babab84464ce7dbce3b81cc20d55fd615f', fv.RoadWide, dd.SlopeDownLeftWide, [[
                        'RoadWide',
                        'SlopeDownWide',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('23a693633b8453c7a531de9723e6ca14d0676b1d7a4df7f78278914467b90a27', fv.RoadWide, dd.SlopeDownRightWide, [[
                        'RoadWide',
                        'SlopeDownWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('0f2e33a8b68667e30e80ceaefdb890a77643799d63c7f20672ca3185bbc04270', fv.RoadWide, dd.SlopeDownLongLeftWide, [[
                        'RoadWide',
                        'SlopeDownLongWide',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            5
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            3
                        ],
                        [
                            1,
                            2,
                            5
                        ]
                    ]
                ]),
                new yv('164903518c7efa4890a792017ea2b8125a2c3dae76bba4c6f1f56fb0f7e40ebc', fv.RoadWide, dd.SlopeDownLongRightWide, [[
                        'RoadWide',
                        'SlopeDownLongWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            5
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            3
                        ],
                        [
                            1,
                            2,
                            5
                        ]
                    ]
                ]),
                new yv('c20560fd35288c5cc74af61834b9a56efaeacdde55eb793d400b7c5b97904993', fv.RoadWide, dd.SlopeLeftWide, [[
                        'RoadWide',
                        'SlopeWide',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ]
                ]),
                new yv('b6a26eb3cefee53d4deef24544e5b5c1ecd25e8e8bd7c3070c7947ada55c57c2', fv.RoadWide, dd.SlopeRightWide, [[
                        'RoadWide',
                        'SlopeWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ]
                ]),
                new yv('b598ff14bda99600434b24a619132fec4bffcc535483b9b57b0c8c09c1be1f1b', fv.RoadWide, dd.SlopeUpVerticalLeftWide, [[
                        'RoadWide',
                        'SlopeUpVerticalWide'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('4e0275d3a01eaca6ec5118b8b816ed292cb7172710cf9b7801068424ab684b22', fv.RoadWide, dd.SlopeUpVerticalRightWide, [[
                        'RoadWide',
                        'SlopeUpVerticalWide',
                        { flipX: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('896b47675cc2ff58494979168f6fd36c27c43da29aed6a52fdf80f054630166a', fv.Plane, dd.Plane, [[
                        'Planes',
                        'Plane'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('dc9afb98a8bb998d3b76c3563385e58c1749e56ff43fbc7577b1f57ba8360702', fv.Plane, dd.PlanePillarBottom, [
                    [
                        'Planes',
                        'Plane'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarBottom'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('f59ad95edd26814236ab30b73f6f4f68003885ef150201a4ace14b832abcf438', fv.Plane, dd.PlanePillarShort, [
                    [
                        'Planes',
                        'Plane'
                    ],
                    [
                        'Pillar',
                        'SurfacePillarShort'
                    ]
                ], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('48247a66b232461083fa2aa36644e7e8779f5b426d474efd375ee7d21d009c9a', fv.Plane, dd.HalfPlane, [[
                        'Planes',
                        'HalfPlane'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('eac8530d1a025291674bf34b206f75700dc8626012d8d33ed398f7aed746dac8', fv.Plane, dd.QuarterPlane, [[
                        'Planes',
                        'QuarterPlane'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            -2,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('1da4dcad366aa90a5977e1b20c5d79297106ed3b4f664be04b6b3f6370c105b4', fv.Plane, dd.PlaneSlopeUp, [[
                        'Planes',
                        'PlaneSlopeUp'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('3e203219ec0ea114da510b37a4c392b90417af796e2b089da6d996e628c0a323', fv.Plane, dd.PlaneSlopeUpLong, [[
                        'Planes',
                        'PlaneSlopeUpLong'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -4
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -5
                        ],
                        [
                            1,
                            1,
                            -4
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -6
                        ],
                        [
                            1,
                            2,
                            -6
                        ]
                    ]
                ]),
                new yv('053dbf6c03eea5102b67168ccb479d8364233b36c4210aff093928bbb83d859d', fv.Plane, dd.PlaneSlopeDown, [[
                        'Planes',
                        'PlaneSlopeDown'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('d68121a3cb0ee19cab45adb136e0df6145f43ca9ecbde8a417c02a6d4a75a757', fv.Plane, dd.PlaneSlopeDownLong, [[
                        'Planes',
                        'PlaneSlopeDownLong'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            5
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            3
                        ],
                        [
                            1,
                            2,
                            5
                        ]
                    ]
                ]),
                new yv('67ec222e8fe770a8d728bb76ff571377c261d2f232134d4cb328c9ab772cf3ca', fv.Plane, dd.PlaneSlope, [[
                        'Planes',
                        'PlaneSlope'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ]
                ]),
                new yv('a52c09d87d37088b68420db07626f274c74f792cb223764624d887a5ed145a2e', fv.Plane, dd.PlaneSlopePillar, [
                    [
                        'Planes',
                        'PlaneSlope'
                    ],
                    [
                        'Pillar',
                        'PillarTopSlope'
                    ]
                ], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('57df805433e706ec946d767d7ff0881f163c2e36bb1db00b0e3259954a787dec', fv.Plane, dd.PlaneSlopePillarShort, [
                    [
                        'Planes',
                        'PlaneSlope'
                    ],
                    [
                        'Pillar',
                        'PillarShortSlope'
                    ]
                ], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('ba0d6ec33647740bf4c60e542d1758095afa3ef451bdaec76c783dd32116e4cb', fv.Plane, dd.PlaneSlopeVerticalBottom, [[
                        'Planes',
                        'PlaneSlopeVertical'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('78a372de15f3151f901cf7fa7a3983ee6513cf19fa8568f10946e195c5a62515', fv.Plane, dd.PlaneSlopeToVertical, [[
                        'Planes',
                        'PlaneSlopeToVertical'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('5f6d1ece085d450643f1399af53673dcc6bbbf413094d8dd5ee6816d80e1c8ae', fv.Plane, dd.PlaneBridge, [[
                        'Planes',
                        'PlaneBridge'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ]]),
                new yv('32b91fc4cdf95f5b7a490d81058522bae14741601dd44c73cc110121aa1dd6e6', fv.Plane, dd.PlaneBridgeCorner, [[
                        'Planes',
                        'PlaneBridgeCorner'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('2db870b1821fb655437bd0527569d5a6843718fa0775682701437432265a1a88', fv.Plane, dd.PlaneBridgeIntersectionT, [[
                        'Planes',
                        'PlaneBridgeIntersectionT'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('33aa0e7524b74dcdae4aed89856c09d25248c4cab8f70dcc31b347f0a00fcb52', fv.Plane, dd.PlaneBridgeIntersectionCross, [[
                        'Planes',
                        'PlaneBridgeIntersectionCross'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('bd7cc4ab180fc0a6936fef828ae3a91566b3dd621b888fbcc57c9ac11dcb713b', fv.Plane, dd.PlaneWall, [[
                        'Planes',
                        'PlaneWall'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('d92568164028bb2e65799abd9dc6ba66cfe8a28515c09fbe5ac175f5966af66a', fv.Plane, dd.PlaneWallCorner, [[
                        'Planes',
                        'PlaneWallCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('792ab5a6f0e2bf8e556575ef12731ec30755855d4394f98eb4ca7ec8b713933c', fv.Plane, dd.PlaneWallInnerCorner, [[
                        'Planes',
                        'PlaneWallInnerCorner'
                    ]], vv, [[
                        [
                            1,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('de0d588c4b2fe6b32d72a7e0e2984285955f805ccb86d3c269f7155401cd6b20', fv.Block, dd.Block, [[
                        'Blocks',
                        'Block'
                    ]], wv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('1ce6b585c0e99d71877fefe015ff16336ae62eb0caebeca62dd09d836092d7b6', fv.Block, dd.HalfBlock, [[
                        'Blocks',
                        'HalfBlock'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('0d5f0609c3c98f687d55d3a73313225c1642f6285ddaca3ed536db742c85958d', fv.Block, dd.QuarterBlock, [[
                        'Blocks',
                        'QuarterBlock'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            -2,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('18fc1c569c6fc04f95f10174143d19e7a9ea4e387302363f4ae60883c1acd3f0', fv.Block, dd.BlockSlopedDown, [[
                        'Blocks',
                        'BlockSlopedDown'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('22dd5b2804c88994a4d283cb822f47de3c72f82376e4c9332d39feae85206c0f', fv.Block, dd.BlockSlopedDownInnerCorner, [[
                        'Blocks',
                        'BlockSlopedDownInnerCorner'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('81a71b4cc6ef8520f20fd738457abc31b04258c97f9862f70190fd2a0ba91382', fv.Block, dd.BlockSlopedDownOuterCorner, [[
                        'Blocks',
                        'BlockSlopedDownOuterCorner'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            1
                        ]
                    ]
                ]),
                new yv('f4e19d3bc49994a85fecd187b76c21d258e7f30f0506d90bc6f173336e11627d', fv.Block, dd.BlockSlopedUp, [[
                        'Blocks',
                        'BlockSlopedUp'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ]
                ]),
                new yv('fd9309468e97131bbbd1404fac34a7137cb176327789b955c1aea30267e1cded', fv.Block, dd.BlockSlopedUpInnerCorner, [[
                        'Blocks',
                        'BlockSlopedUpInnerCorner'
                    ]], wv, [
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            -1,
                            1,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('1321fb07ece1b80b99dc4671b52673ac028fbf43322e9e652ad633ff6afac21b', fv.Block, dd.BlockSlopedUpOuterCorner, [[
                        'Blocks',
                        'BlockSlopedUpOuterCorner'
                    ]], wv, [
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            -1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('b97c17388fc38139f2f5a98a36d94831095f79db709dd97748ad2904bc54d689', fv.Block, dd.BlockSlopeDown, [[
                        'Blocks',
                        'BlockSlopeDown'
                    ]], wv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('50276826bbfb9fcb11a8519b8dae8a2b1cf82817d5431418d9a376664261be82', fv.Block, dd.BlockSlopeUp, [[
                        'Blocks',
                        'BlockSlopeUp'
                    ]], wv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('63fd3032796397f8e25669c1c1d3fc97b8ec0e5fc88bfcb5c00a2a2c2b517888', fv.Block, dd.BlockSlopeDownLong, [[
                        'Blocks',
                        'BlockSlopeDownLong'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            5
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            5
                        ]
                    ]
                ]),
                new yv('2d29131222a8d891b4350e6a2f335b114e001cf22e4e2f170dc9b86c4b2fd325', fv.Block, dd.BlockSlopeUpLong, [[
                        'Blocks',
                        'BlockSlopeUpLong'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -6
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -6
                        ],
                        [
                            1,
                            1,
                            -4
                        ]
                    ]
                ]),
                new yv('0bbcd96c91b69e6e8005bfae5b64455b0d6510cb1595f3fca7f77c86ddda4560', fv.Block, dd.BlockSlopeVerticalTop, [[
                        'Blocks',
                        'BlockSlopeVertical',
                        { flipY: !0 }
                    ]], wv, [
                    [
                        [
                            -2,
                            3,
                            -2
                        ],
                        [
                            1,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('e81a123c0be3f8f168fb584d53e8aa038785569bbf2cd1c1cead2272889591e0', fv.Block, dd.BlockSlopeVerticalBottom, [[
                        'Blocks',
                        'BlockSlopeVertical'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('94e14468f31af7f39b9d7ba188a364089ae81da2bd6a9db2b8f5b1b8cedce741', fv.Block, dd.BlockSlopeToVertical, [[
                        'Blocks',
                        'BlockSlopeToVertical'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('3a2f05b1c2c2fd976997fa473f1adb3ba14495701dc5a998f8697798384c6946', fv.Block, dd.BlockSlopeVerticalCornerTop, [[
                        'Blocks',
                        'BlockSlopeVerticalCornerBottom',
                        { flipY: !0 }
                    ]], wv, [
                    [
                        [
                            -2,
                            3,
                            -2
                        ],
                        [
                            1,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            0,
                            2,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            1
                        ],
                        [
                            -1,
                            2,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            -1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            -1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            0,
                            1,
                            -2
                        ],
                        [
                            0,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            1,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            1
                        ],
                        [
                            -2,
                            1,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            -2,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('3e4fa43e69aa1dbee584e16451a95a16229bba8d638df2bf6f6c9ffb3a9629c9', fv.Block, dd.BlockInnerCorner, [[
                        'Blocks',
                        'BlockInnerCorner'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            -2,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('cc9c95eef56def4cf013e4ac85b8013a2b4f4b4346f1f5dd41fa017de763ef17', fv.Block, dd.BlockSlopeVerticalCornerBottom, [[
                        'Blocks',
                        'BlockSlopeVerticalCornerBottom'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            0,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            1
                        ],
                        [
                            -1,
                            1,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            -1,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            0
                        ],
                        [
                            -1,
                            2,
                            0
                        ]
                    ],
                    [
                        [
                            0,
                            2,
                            -2
                        ],
                        [
                            0,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            1,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            1
                        ],
                        [
                            -2,
                            2,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            3,
                            -2
                        ],
                        [
                            -1,
                            3,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            3,
                            0
                        ],
                        [
                            -2,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            3,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('e4c82c8e512d52269cb6588fa34b06c179340ea40e71f74cbadadc7e8353f5a2', fv.Block, dd.BlockSlopeVerticalInnerCornerTop, [[
                        'Blocks',
                        'BlockSlopeVerticalInnerCorner',
                        { flipY: !0 }
                    ]], wv, [
                    [
                        [
                            -2,
                            3,
                            -2
                        ],
                        [
                            0,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            3,
                            -2
                        ],
                        [
                            1,
                            3,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            -2,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            2,
                            -2
                        ],
                        [
                            -1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('926fdc6e82ecd709cc535faea6bb8778c6e2e91edb39eb6ae6308076dca2ed18', fv.Block, dd.BlockSlopeVerticalInnerCornerBottom, [[
                        'Blocks',
                        'BlockSlopeVerticalInnerCorner'
                    ]], wv, [
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            -2,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            1,
                            -2
                        ],
                        [
                            -1,
                            1,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            -2,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('1086515ba3c1d8e5ec76b378f0bdbc77fc5a57fc8eba8972f0d5e611be945235', fv.Block, dd.BlockBridge, [[
                        'Blocks',
                        'BlockBridge'
                    ]], wv, [[
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ]]),
                new yv('5426ad4ff64af3f1a0f0794ad30cfc20434dfffdf44d93010f5f98671c246ff3', fv.Block, dd.BlockBridgeCorner, [[
                        'Blocks',
                        'BlockBridgeCorner'
                    ]], wv, [
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('784b9b4459e838e5b8f74f6250769ffa52ec5cc3608abc24c380a2e792c3d338', fv.Block, dd.BlockBridgeIntersectionT, [[
                        'Blocks',
                        'BlockBridgeIntersectionT'
                    ]], wv, [
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('dfbcbc107a3c12217bfa3b224a5757d08e995705d1c122bb2c2665bbb8447b1c', fv.Block, dd.BlockBridgeIntersectionCross, [[
                        'Blocks',
                        'BlockBridgeIntersectionCross'
                    ]], wv, [
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('5fe53442e559418b7cc9483315b0ac45b8797f9630d5ecc4c7604dab4be25584', fv.WallTrack, dd.WallTrackTop, [[
                        'WallTrack',
                        'WallTrackBottom',
                        { flipY: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            3,
                            -1
                        ],
                        [
                            1,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -1
                        ],
                        [
                            1,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ]
                ]),
                new yv('010d187fbfbd399bfe880bbea1b548678c239eba0be2913e5cb8a69fbd17adf7', fv.WallTrack, dd.WallTrackMiddle, [[
                        'WallTrack',
                        'WallTrackMiddle'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]]),
                new yv('33216a4dcb734511a80c5bf70ca6f66de555800426686eae5a2519d4c837090e', fv.WallTrack, dd.WallTrackBottom, [[
                        'WallTrack',
                        'WallTrackBottom'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('1e306d2a6347b68d6e275bf4ccc9c8942e0a633bf625a3bba95fa9f98ecd50ff', fv.WallTrack, dd.WallTrackSlopeToVertical, [[
                        'WallTrack',
                        'WallTrackSlopeToVertical'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('3ed21ddbc756a6644e05f5e1ca78ff8df6d51affc472c2d86e7f23d85911e273', fv.WallTrack, dd.WallTrackTopCorner, [[
                        'WallTrack',
                        'WallTrackBottomCorner',
                        { flipY: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -1
                        ],
                        [
                            -2,
                            1,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            1,
                            -1
                        ],
                        [
                            -1,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            0,
                            1,
                            -1
                        ],
                        [
                            0,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            0
                        ],
                        [
                            -2,
                            2,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            2,
                            1
                        ],
                        [
                            -1,
                            2,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            2,
                            -1
                        ],
                        [
                            0,
                            2,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            2,
                            -1
                        ],
                        [
                            1,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            0,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            0,
                            3,
                            -1
                        ],
                        [
                            1,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            3,
                            0
                        ],
                        [
                            -1,
                            3,
                            1
                        ]
                    ]
                ]),
                new yv('4027a2439cc3e42ceda50ff3d427a31e127b25a6457b55edc2d498b474a296a7', fv.WallTrack, dd.WallTrackMiddleCorner, [[
                        'WallTrack',
                        'WallTrackMiddleCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            -1,
                            0,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]
                ]),
                new yv('498286e062056a537a482ed3385fe0ac0343b399f29d470641df8f74c0532672', fv.WallTrack, dd.WallTrackBottomCorner, [[
                        'WallTrack',
                        'WallTrackBottomCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            3,
                            -1
                        ],
                        [
                            -2,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            3,
                            -1
                        ],
                        [
                            -1,
                            3,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            3,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -1
                        ],
                        [
                            -2,
                            2,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            2,
                            -1
                        ],
                        [
                            -1,
                            2,
                            0
                        ]
                    ],
                    [
                        [
                            0,
                            2,
                            -1
                        ],
                        [
                            0,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -1,
                            2,
                            -2
                        ],
                        [
                            1,
                            2,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            0
                        ],
                        [
                            -2,
                            1,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            1,
                            1
                        ],
                        [
                            -1,
                            1,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            1,
                            -1
                        ],
                        [
                            0,
                            1,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            1,
                            -1
                        ],
                        [
                            1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            0,
                            1,
                            -2
                        ],
                        [
                            1,
                            1,
                            -2
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            0
                        ],
                        [
                            -1,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('ac09cd62c83af376f23d37dd88273614a2a11cc04a04bff6075fd749bb1ff421', fv.WallTrack, dd.WallTrackTopInnerCorner, [[
                        'WallTrack',
                        'WallTrackBottomInnerCorner',
                        { flipY: !0 }
                    ]], vv, [
                    [
                        [
                            -2,
                            3,
                            -1
                        ],
                        [
                            1,
                            3,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            3,
                            -2
                        ],
                        [
                            1,
                            3,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            -1,
                            2,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            1,
                            -2
                        ]
                    ]
                ]),
                new yv('16c9c8ece47c097f60cfc7f8a2daa2f0e7ad0befb0ebfd185402013fd1ec8e0f', fv.WallTrack, dd.WallTrackInnerCorner, [[
                        'WallTrack',
                        'WallTrackInnerCorner'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            -2,
                            0,
                            -2
                        ]
                    ]]),
                new yv('404e7506c2f7e9302acac39c31a659e7e09e7852786e5f0244f9827727a0bf1e', fv.WallTrack, dd.WallTrackBottomInnerCorner, [[
                        'WallTrack',
                        'WallTrackBottomInnerCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ],
                    [
                        [
                            -2,
                            1,
                            -2
                        ],
                        [
                            -1,
                            1,
                            -1
                        ]
                    ],
                    [
                        [
                            -2,
                            2,
                            -2
                        ],
                        [
                            -2,
                            3,
                            -2
                        ]
                    ]
                ]),
                new yv('8b7023471502607ef19109760bee3b954ea3b3883c32f3960f75c6651c912ffd', fv.WallTrack, dd.WallTrackFloor, [[
                        'WallTrack',
                        'WallTrackFloor'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('59e7f31827236c71db8b16f3f1f259c4c82c87a37e4d57a5a097c0d527d128f3', fv.WallTrack, dd.WallTrackFloorCorner, [[
                        'WallTrack',
                        'WallTrackFloorCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('d58e3805b550b70940c845a807086865b21a4c36da74ffddedcfe5ce2d08e093', fv.WallTrack, dd.WallTrackFloorPlaneCorner, [[
                        'WallTrack',
                        'WallTrackFloorPlaneCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('a56b0c1cf964b213a38167cbbac6f33acd403978ad75746eb51bcfd8c6a36148', fv.WallTrack, dd.WallTrackCeiling, [[
                        'WallTrack',
                        'WallTrackCeiling'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ]]),
                new yv('f87b592d02120312e8e93d8a27c02dcda1095ac2f09879c6efafb2ca2b49d127', fv.WallTrack, dd.WallTrackCeilingCorner, [[
                        'WallTrack',
                        'WallTrackCeilingCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('cfce1fe50f8cd26393eadd475783830e02f0b39bad4c0e00f7aa69614b22decc', fv.WallTrack, dd.WallTrackCeilingPlaneCorner, [[
                        'WallTrack',
                        'WallTrackCeilingPlaneCorner'
                    ]], vv, [
                    [
                        [
                            -2,
                            0,
                            1
                        ],
                        [
                            1,
                            0,
                            1
                        ]
                    ],
                    [
                        [
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -1
                        ]
                    ]
                ]),
                new yv('19656d02145f1a4ba07dbf2f236f865d34c86f823741b247b5d444a36d61c316', fv.Pillar, dd.PillarTop, [[
                        'Pillar',
                        'PillarTop'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('dde596d55ffc00f0f00d361667239d9f71c414f03304fecb6a7d11f6f5e702f1', fv.Pillar, dd.PillarMiddle, [[
                        'Pillar',
                        'PillarMiddle'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('dced5202d9373f9dd81a39530a87a1a7036c93ae71604a4e26c3a191abf3c197', fv.Pillar, dd.PillarBottom, [[
                        'Pillar',
                        'PillarBottom'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('af83eebf50c302880377e4f8c1fb3b2ef96ae193e8d03c17e1fd77c73a847e63', fv.Pillar, dd.PillarShort, [[
                        'Pillar',
                        'PillarShort'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -1
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('25b41116fb04b1f3cdd3119f57e0000a6ea8cb12d435718ffd6bb765866c272f', fv.Pillar, dd.PillarBranch1, [[
                        'Pillar',
                        'PillarBranch1'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('05ae39aea4f1ddd818fa57860e688c9cb875544f9b82eafe58a2eb9c19d8d91d', fv.Pillar, dd.PillarBranch1Top, [[
                        'Pillar',
                        'PillarBranch1Top'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('06c29d92e42e0c32050af98d69eecc94ce15adf8ac81dbe53dfb577a83265f4e', fv.Pillar, dd.PillarBranch1Middle, [[
                        'Pillar',
                        'PillarBranch1Middle'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('4a989027e0bd6db264f092bac729d9d450e012a710ea28d199f7ff52efd70fbd', fv.Pillar, dd.PillarBranch1Bottom, [[
                        'Pillar',
                        'PillarBranch1Bottom'
                    ]], vv, [[
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]]),
                new yv('78b2ff83ad71e7f3d692abc35923fa20c2ae14c01e37d44ec430746ca1bac992', fv.Pillar, dd.PillarBranch2, [[
                        'Pillar',
                        'PillarBranch2'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('b22c93bc73ec2da9dbff218da1676d7436527ed284e264f37294e48ef1307301', fv.Pillar, dd.PillarBranch2Top, [[
                        'Pillar',
                        'PillarBranch2Top'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('79a456a8fa3da24bec6c033f6c736fa1c728745f9624ae78ca20b6a4a76afae8', fv.Pillar, dd.PillarBranch2Middle, [[
                        'Pillar',
                        'PillarBranch2Middle'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('3b81b3f965cbc9fda4fe09e830ba25f1b96ce512d87b0146a1192a6cd0d07335', fv.Pillar, dd.PillarBranch2Bottom, [[
                        'Pillar',
                        'PillarBranch2Bottom'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('27727678bbcac9d3b0172b165ca5c92b10f4b4584a3a18fef4c542f3e791f26f', fv.Pillar, dd.PillarBranch3, [[
                        'Pillar',
                        'PillarBranch3'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('50c7ac511d30ab9e065c928b776652f038be7683d948082bbefc419ee049e505', fv.Pillar, dd.PillarBranch3Top, [[
                        'Pillar',
                        'PillarBranch3Top'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('98b3bfe99e7132825f5aa93122e4e5fdec46eb2877c8eb91fa2648f709527b60', fv.Pillar, dd.PillarBranch3Middle, [[
                        'Pillar',
                        'PillarBranch3Middle'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('7326bbb558f8bcc28d5875c43b1b8e3646caadb873a14fde3ab517f779aea345', fv.Pillar, dd.PillarBranch3Bottom, [[
                        'Pillar',
                        'PillarBranch3Bottom'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ]
                ]),
                new yv('0e23c2615cfdb350bb3a700b6169589265a1d1079f61294fb497b8f80191d523', fv.Pillar, dd.PillarBranch4, [[
                        'Pillar',
                        'PillarBranch4'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('e62b55e111dbcb3faefed0a203eac5b55051a2b11911946660310e3df3588da3', fv.Pillar, dd.PillarBranch4Top, [[
                        'Pillar',
                        'PillarBranch4Top'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('4e2cfb89c1c591803a1440532a74c3ace37ec7fe78a526c1b57f6679c620df2e', fv.Pillar, dd.PillarBranch4Middle, [[
                        'Pillar',
                        'PillarBranch4Middle'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('e7807350788e4570c8bb74d4a635639ef731d83e52922fac5bc10f415f73f794', fv.Pillar, dd.PillarBranch4Bottom, [[
                        'Pillar',
                        'PillarBranch4Bottom'
                    ]], vv, [
                    [
                        [
                            -1,
                            0,
                            -2
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            1,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            -2,
                            0,
                            0
                        ]
                    ],
                    [
                        [
                            -1,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            1
                        ]
                    ]
                ]),
                new yv('836bfd12791bfebd99aba70531da4c9bd6e332d16c1e120a8888ea54f59456f9', fv.Pillar, dd.PillarBranch5, [[
                        'Pillar',
                        'PillarBranch5'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]]),
                new yv('ab85228116faf9ae7b1e6cb4a03530cbec808df3d3c1d7883eb41eb7cfe231d7', fv.Pillar, dd.PillarBranch5Top, [[
                        'Pillar',
                        'PillarBranch5Top'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]]),
                new yv('db93d5cea4e523fd67a56f8d928084ab6355331a8e5d1899115c1841866006bb', fv.Pillar, dd.PillarBranch5Middle, [[
                        'Pillar',
                        'PillarBranch5Middle'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]]),
                new yv('dd793efa234159e3a0ff28b064ecb715e6c8bb76e06acfe4bd0d9a2f2b9bba88', fv.Pillar, dd.PillarBranch5Bottom, [[
                        'Pillar',
                        'PillarBranch5Bottom'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -1
                        ],
                        [
                            1,
                            0,
                            0
                        ]
                    ]]),
                new yv('350f7d3591ffd0b2cfb8204d1c6cd0022fd3bda81ea7e950fce3abea7ec89e1a', fv.Sign, dd.SignArrowLeft, [[
                        'Signs',
                        'SignArrowRight',
                        { flipX: !0 }
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]]),
                new yv('22e104e58bba0a609d379578e391ce50ca523c9eee1c3fddebb6d1bb2246a0b9', fv.Sign, dd.SignArrowRight, [[
                        'Signs',
                        'SignArrowRight'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]]),
                new yv('acba0cfe380e625285b973e09344e61740e77d6f8cac8691ef3e0a0b0878040e', fv.Sign, dd.SignArrowUp, [[
                        'Signs',
                        'SignArrowUp'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]]),
                new yv('8d0dbea0a26bdf3addd372f5d9a2fdecfd776a48f31218acdeb036129b248ca5', fv.Sign, dd.SignArrowDown, [[
                        'Signs',
                        'SignArrowUp',
                        { flipY: !0 }
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]]),
                new yv('e5e1b1ca69d7b230331171be07876c4b1bdebba557c19b18ab17d91eee2771d5', fv.Sign, dd.SignWarning, [[
                        'Signs',
                        'SignWarning'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]]),
                new yv('64ed1fba4990a25bc774575ff8835117638d2c3e7c8f41bf0032d219e1083e4c', fv.Sign, dd.SignWrongWay, [[
                        'Signs',
                        'SignWrongWay'
                    ]], vv, [[
                        [
                            -2,
                            0,
                            -2
                        ],
                        [
                            1,
                            0,
                            -2
                        ]
                    ]])
            ], _box = new Map();
        for (const REVISION of xv) {
            if (_box.has(REVISION.id))
                throw new Error('Duplicate track part id ' + REVISION.id.toString());
            _box.set(REVISION.id, REVISION);
        }
        function Sv(REVISION) {
            const t = _box.get(REVISION);
            if (null == t)
                throw new Error('Unknown track part id ' + REVISION.toString());
            return t;
        }
        const Ev = xv.filter(REVISION => {
                var t;
                return (null === (t = REVISION.detector) || void 0 === t ? void 0 : t.type) == qh.Checkpoint;
            }).map(REVISION => REVISION.id), Mv = xv.filter(REVISION => null != REVISION.startOffset).map(REVISION => REVISION.id);
        function Tv(REVISION) {
            const t = REVISION.parts;
            if ('object' != typeof t && null !== t && !Array.isArray(t))
                return null;
            const n = new aw(cv.Summer, new ov()), i = Object.keys(t);
            for (const REVISION of i) {
                const i = parseInt(REVISION, 10);
                if (!(i in dd))
                    return null;
                {
                    const REVISION = t[i];
                    if (!Array.isArray(REVISION))
                        return null;
                    if (REVISION.length % 4 != 0)
                        return null;
                    for (let t = 0; t < REVISION.length; t += 4) {
                        const r = parseInt(REVISION[t + 0], 10), AddEquation = parseInt(REVISION[t + 1], 10), SubtractEquation = parseInt(REVISION[t + 2], 10), ReverseSubtractEquation = parseInt(REVISION[t + 3], 10);
                        if (isNaN(r) || isNaN(AddEquation) || isNaN(SubtractEquation) || isNaN(ReverseSubtractEquation))
                            return null;
                        if (!(ReverseSubtractEquation >= 0 && ReverseSubtractEquation <= 3 && Math.abs(r) <= 1000000000 && AddEquation >= 0 && AddEquation <= 1000000000 && Math.abs(SubtractEquation) <= 1000000000))
                            return null;
                        {
                            if (Ev.includes(i))
                                return null;
                            let REVISION = null;
                            Mv.includes(i) && (REVISION = 0), n.addPart(4 * r, AddEquation, 4 * SubtractEquation, i, ReverseSubtractEquation, fd.YPositive, dv.Default, null, REVISION);
                        }
                    }
                }
            }
            return n;
        }
        function Cv(REVISION) {
            const t = ch(REVISION);
            if (null == t)
                return null;
            const n = new aw(cv.Summer, new ov());
            let i = 0;
            for (; i < t.length;) {
                if (t.length - i < 2)
                    return null;
                const REVISION = t[i + 0] | t[i + 1] << 8;
                if (i += 2, !(REVISION in dd))
                    return null;
                if (t.length - i < 4)
                    return null;
                const r = t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16 | t[i + 3] << 24;
                i += 4;
                for (let AddEquation = 0; AddEquation < r; ++AddEquation) {
                    if (t.length - i < 3)
                        return null;
                    const r = (t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16) - Math.pow(2, 23);
                    if (i += 3, t.length - i < 3)
                        return null;
                    const AddEquation = t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16;
                    if (i += 3, t.length - i < 3)
                        return null;
                    const SubtractEquation = (t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16) - Math.pow(2, 23);
                    if (i += 3, t.length - i < 1)
                        return null;
                    const ReverseSubtractEquation = 3 & t[i + 0];
                    if (i += 1, ReverseSubtractEquation < 0 || ReverseSubtractEquation > 3)
                        return null;
                    if (Ev.includes(REVISION))
                        return null;
                    let ZeroFactor = null;
                    Mv.includes(REVISION) && (ZeroFactor = 0), n.addPart(4 * r, AddEquation, 4 * SubtractEquation, REVISION, ReverseSubtractEquation, fd.YPositive, dv.Default, null, ZeroFactor);
                }
            }
            return n;
        }
        function Iv(REVISION) {
            const t = ev(REVISION);
            if (null == t)
                return null;
            const n = new TYPED_ARRAYS.Inflate();
            if (n.push(t, !0), n.err)
                return null;
            const i = n.result;
            if (!(i instanceof Uint8Array))
                return null;
            const r = new aw(cv.Summer, new ov());
            let AddEquation = 0;
            for (; AddEquation < i.length;) {
                if (i.length - AddEquation < 2)
                    return null;
                const REVISION = i[AddEquation + 0] | i[AddEquation + 1] << 8;
                if (AddEquation += 2, !(REVISION in dd))
                    return null;
                if (i.length - AddEquation < 4)
                    return null;
                const t = i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16 | i[AddEquation + 3] << 24;
                AddEquation += 4;
                for (let n = 0; n < t; ++n) {
                    if (i.length - AddEquation < 3)
                        return null;
                    const t = (i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16) - Math.pow(2, 23);
                    if (AddEquation += 3, i.length - AddEquation < 3)
                        return null;
                    const n = i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16;
                    if (AddEquation += 3, i.length - AddEquation < 3)
                        return null;
                    const SubtractEquation = (i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16) - Math.pow(2, 23);
                    if (AddEquation += 3, i.length - AddEquation < 1)
                        return null;
                    const ReverseSubtractEquation = i[AddEquation + 0];
                    if (AddEquation += 1, ReverseSubtractEquation < 0 || ReverseSubtractEquation > 3)
                        return null;
                    let ZeroFactor = null;
                    if (Ev.includes(REVISION)) {
                        if (i.length - AddEquation < 2)
                            return null;
                        ZeroFactor = i[AddEquation + 0] | i[AddEquation + 1] << 8, AddEquation += 2;
                    }
                    let OneFactor = null;
                    Mv.includes(REVISION) && (OneFactor = 0), r.addPart(4 * t, n, 4 * SubtractEquation, REVISION, ReverseSubtractEquation, fd.YPositive, dv.Default, ZeroFactor, OneFactor);
                }
            }
            return r;
        }
        function Rv(REVISION) {
            const t = ev(REVISION);
            if (null == t)
                return null;
            const n = new TYPED_ARRAYS.Inflate();
            if (n.push(t, !0), n.err)
                return null;
            const i = n.result;
            if (!(i instanceof Uint8Array))
                return null;
            const r = new aw(cv.Summer, new ov());
            let AddEquation = 0;
            for (; AddEquation < i.length;) {
                if (i.length - AddEquation < 2)
                    return null;
                let REVISION = i[AddEquation + 0] | i[AddEquation + 1] << 8;
                AddEquation += 2;
                let t = dv.Default;
                if (REVISION >= 134 && REVISION <= 178)
                    switch (REVISION) {
                    case 134:
                        REVISION = dd.Block, t = dv.Custom1;
                        break;
                    case 135:
                        REVISION = dd.HalfBlock, t = dv.Custom1;
                        break;
                    case 136:
                        REVISION = dd.QuarterBlock, t = dv.Custom1;
                        break;
                    case 137:
                        REVISION = dd.BlockSlopedDown, t = dv.Custom1;
                        break;
                    case 138:
                        REVISION = dd.BlockSlopedDownInnerCorner, t = dv.Custom1;
                        break;
                    case 139:
                        REVISION = dd.BlockSlopedDownOuterCorner, t = dv.Custom1;
                        break;
                    case 140:
                        REVISION = dd.BlockSlopedUp, t = dv.Custom1;
                        break;
                    case 141:
                        REVISION = dd.BlockSlopedUpInnerCorner, t = dv.Custom1;
                        break;
                    case 142:
                        REVISION = dd.BlockSlopedUpOuterCorner, t = dv.Custom1;
                        break;
                    case 143:
                        REVISION = dd.BlockSlopeDown, t = dv.Custom1;
                        break;
                    case 144:
                        REVISION = dd.BlockSlopeUp, t = dv.Custom1;
                        break;
                    case 145:
                        REVISION = dd.BlockBridge, t = dv.Custom1;
                        break;
                    case 146:
                        REVISION = dd.BlockBridgeCorner, t = dv.Custom1;
                        break;
                    case 147:
                        REVISION = dd.BlockBridgeIntersectionT, t = dv.Custom1;
                        break;
                    case 148:
                        REVISION = dd.BlockBridgeIntersectionCross, t = dv.Custom1;
                        break;
                    case 149:
                        REVISION = dd.Block, t = dv.Custom6;
                        break;
                    case 150:
                        REVISION = dd.HalfBlock, t = dv.Custom6;
                        break;
                    case 151:
                        REVISION = dd.QuarterBlock, t = dv.Custom6;
                        break;
                    case 152:
                        REVISION = dd.BlockSlopedDown, t = dv.Custom6;
                        break;
                    case 153:
                        REVISION = dd.BlockSlopedDownInnerCorner, t = dv.Custom6;
                        break;
                    case 154:
                        REVISION = dd.BlockSlopedDownOuterCorner, t = dv.Custom6;
                        break;
                    case 155:
                        REVISION = dd.BlockSlopedUp, t = dv.Custom6;
                        break;
                    case 156:
                        REVISION = dd.BlockSlopedUpInnerCorner, t = dv.Custom6;
                        break;
                    case 157:
                        REVISION = dd.BlockSlopedUpOuterCorner, t = dv.Custom6;
                        break;
                    case 158:
                        REVISION = dd.BlockSlopeDown, t = dv.Custom6;
                        break;
                    case 159:
                        REVISION = dd.BlockSlopeUp, t = dv.Custom6;
                        break;
                    case 160:
                        REVISION = dd.BlockBridge, t = dv.Custom6;
                        break;
                    case 161:
                        REVISION = dd.BlockBridgeCorner, t = dv.Custom6;
                        break;
                    case 162:
                        REVISION = dd.BlockBridgeIntersectionT, t = dv.Custom6;
                        break;
                    case 163:
                        REVISION = dd.BlockBridgeIntersectionCross, t = dv.Custom6;
                        break;
                    case 164:
                        REVISION = dd.Block, t = dv.Custom0;
                        break;
                    case 165:
                        REVISION = dd.HalfBlock, t = dv.Custom0;
                        break;
                    case 166:
                        REVISION = dd.QuarterBlock, t = dv.Custom0;
                        break;
                    case 167:
                        REVISION = dd.BlockSlopedDown, t = dv.Custom0;
                        break;
                    case 168:
                        REVISION = dd.BlockSlopedDownInnerCorner, t = dv.Custom0;
                        break;
                    case 169:
                        REVISION = dd.BlockSlopedDownOuterCorner, t = dv.Custom0;
                        break;
                    case 170:
                        REVISION = dd.BlockSlopedUp, t = dv.Custom0;
                        break;
                    case 171:
                        REVISION = dd.BlockSlopedUpInnerCorner, t = dv.Custom0;
                        break;
                    case 172:
                        REVISION = dd.BlockSlopedUpOuterCorner, t = dv.Custom0;
                        break;
                    case 173:
                        REVISION = dd.BlockSlopeDown, t = dv.Custom0;
                        break;
                    case 174:
                        REVISION = dd.BlockSlopeUp, t = dv.Custom0;
                        break;
                    case 175:
                        REVISION = dd.BlockBridge, t = dv.Custom0;
                        break;
                    case 176:
                        REVISION = dd.BlockBridgeCorner, t = dv.Custom0;
                        break;
                    case 177:
                        REVISION = dd.BlockBridgeIntersectionT, t = dv.Custom0;
                        break;
                    case 178:
                        REVISION = dd.BlockBridgeIntersectionCross, t = dv.Custom0;
                    }
                let n = null, SubtractEquation = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                if (79 == REVISION)
                    n = dd.WallTrackFloorPlaneCorner;
                else if (81 == REVISION)
                    n = dd.WallTrackCeilingPlaneCorner, SubtractEquation = {
                        x: 0,
                        y: 3,
                        z: 0
                    };
                else if (REVISION >= 87 && REVISION <= 98)
                    switch (REVISION) {
                    case 87:
                        REVISION = dd.Slope, n = dd.BlockSlopedUp;
                        break;
                    case 88:
                        REVISION = dd.SlopeUp, n = dd.BlockSlopeUp;
                        break;
                    case 89:
                        REVISION = dd.SlopeDown, n = dd.BlockSlopeDown;
                        break;
                    case 90:
                        REVISION = dd.SlopeUpLeftWide, n = dd.BlockSlopeUp;
                        break;
                    case 91:
                        REVISION = dd.SlopeUpRightWide, n = dd.BlockSlopeUp;
                        break;
                    case 92:
                        REVISION = dd.SlopeDownLeftWide, n = dd.BlockSlopeDown;
                        break;
                    case 93:
                        REVISION = dd.SlopeDownRightWide, n = dd.BlockSlopeDown;
                        break;
                    case 94:
                        REVISION = dd.SlopeLeftWide, n = dd.BlockSlopedUp;
                        break;
                    case 95:
                        REVISION = dd.SlopeRightWide, n = dd.BlockSlopedUp;
                        break;
                    case 96:
                        REVISION = dd.PlaneSlopeUp, n = dd.BlockSlopeUp;
                        break;
                    case 97:
                        REVISION = dd.PlaneSlopeDown, n = dd.BlockSlopeDown;
                        break;
                    case 98:
                        REVISION = dd.PlaneSlope, n = dd.BlockSlopedUp;
                        break;
                    default:
                        throw new Error('Invalid track part id');
                    }
                if (!(REVISION in dd))
                    return null;
                if (i.length - AddEquation < 4)
                    return null;
                const ReverseSubtractEquation = i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16 | i[AddEquation + 3] << 24;
                AddEquation += 4;
                for (let ZeroFactor = 0; ZeroFactor < ReverseSubtractEquation; ++ZeroFactor) {
                    if (i.length - AddEquation < 3)
                        return null;
                    const ReverseSubtractEquation = (i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16) - Math.pow(2, 23);
                    if (AddEquation += 3, i.length - AddEquation < 3)
                        return null;
                    const ZeroFactor = i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16;
                    if (AddEquation += 3, i.length - AddEquation < 3)
                        return null;
                    const OneFactor = (i[AddEquation + 0] | i[AddEquation + 1] << 8 | i[AddEquation + 2] << 16) - Math.pow(2, 23);
                    if (AddEquation += 3, i.length - AddEquation < 1)
                        return null;
                    const SrcColorFactor = i[AddEquation + 0];
                    if (AddEquation += 1, SrcColorFactor < 0 || SrcColorFactor > 3)
                        return null;
                    let OneMinusSrcColorFactor = null;
                    if (Ev.includes(REVISION)) {
                        if (i.length - AddEquation < 2)
                            return null;
                        OneMinusSrcColorFactor = i[AddEquation + 0] | i[AddEquation + 1] << 8, AddEquation += 2;
                    }
                    let SrcAlphaFactor = null;
                    Mv.includes(REVISION) && (SrcAlphaFactor = 0), null != n && r.addPart(4 * ReverseSubtractEquation + SubtractEquation.x, ZeroFactor + SubtractEquation.y, 4 * OneFactor + SubtractEquation.z, n, SrcColorFactor, fd.YPositive, dv.Default, null, SrcAlphaFactor), r.addPart(4 * ReverseSubtractEquation, ZeroFactor, 4 * OneFactor, REVISION, SrcColorFactor, fd.YPositive, t, OneMinusSrcColorFactor, SrcAlphaFactor);
                }
            }
            return r;
        }
        function Pv(REVISION, t) {
            let n = REVISION;
            if (t.length - n < 1)
                return null;
            const i = t[n];
            if (n += 1, !(i in cv))
                return null;
            if (t.length - n < 1)
                return null;
            const r = t[n];
            if (n += 1, !Number.isSafeInteger(r) || r < 0 || r >= 180)
                return null;
            const AddEquation = new aw(i, new ov(r));
            if (t.length - n < 9)
                return null;
            const SubtractEquation = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
            n += 4;
            const ReverseSubtractEquation = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
            n += 4;
            const ZeroFactor = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
            n += 4;
            const OneFactor = 3 & t[n], SrcColorFactor = t[n] >> 2 & 3, OneMinusSrcColorFactor = t[n] >> 4 & 3;
            if (n += 1, OneFactor < 1 || OneFactor > 4 || SrcColorFactor < 1 || SrcColorFactor > 4 || OneMinusSrcColorFactor < 1 || OneMinusSrcColorFactor > 4)
                return null;
            for (; n < t.length;) {
                if (t.length - n < 1)
                    return null;
                const REVISION = t[n + 0];
                if (n += 1, !(REVISION in dd))
                    return null;
                if (t.length - n < 4)
                    return null;
                const i = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                for (let r = 0; r < i; ++r) {
                    if (t.length - n < OneFactor)
                        return null;
                    let i = 0;
                    for (let REVISION = 0; REVISION < OneFactor; ++REVISION)
                        i |= t[n + REVISION] << 8 * REVISION;
                    if (i += SubtractEquation, n += OneFactor, t.length - n < SrcColorFactor)
                        return null;
                    let r = 0;
                    for (let REVISION = 0; REVISION < SrcColorFactor; ++REVISION)
                        r |= t[n + REVISION] << 8 * REVISION;
                    if (r += ReverseSubtractEquation, n += SrcColorFactor, t.length - n < OneMinusSrcColorFactor)
                        return null;
                    let SrcAlphaFactor = 0;
                    for (let REVISION = 0; REVISION < OneMinusSrcColorFactor; ++REVISION)
                        SrcAlphaFactor |= t[n + REVISION] << 8 * REVISION;
                    if (SrcAlphaFactor += ZeroFactor, n += OneMinusSrcColorFactor, t.length - n < 1)
                        return null;
                    const OneMinusSrcAlphaFactor = t[n + 0];
                    if (n += 1, OneMinusSrcAlphaFactor < 0 || OneMinusSrcAlphaFactor > 3)
                        return null;
                    if (t.length - n < 1)
                        return null;
                    const DstAlphaFactor = t[n + 0];
                    if (n += 1, !(DstAlphaFactor in fd))
                        return null;
                    if (t.length - n < 1)
                        return null;
                    const OneMinusDstAlphaFactor = t[n + 0];
                    if (n += 1, !(OneMinusDstAlphaFactor in dv))
                        return null;
                    let DstColorFactor = null;
                    if (Ev.includes(REVISION)) {
                        if (t.length - n < 2)
                            return null;
                        DstColorFactor = t[n + 0] | t[n + 1] << 8, n += 2;
                    }
                    let OneMinusDstColorFactor = null;
                    if (Mv.includes(REVISION)) {
                        if (t.length - n < 4)
                            return null;
                        OneMinusDstColorFactor = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24, n += 4;
                    }
                    AddEquation.addPart(i, r, SrcAlphaFactor, REVISION, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor);
                }
            }
            return AddEquation;
        }
        class StereoCamera extends InstancedMesh {
            constructor(REVISION, t) {
                const n = new Si({
                    color: t,
                    depthWrite: !1
                });
                super(REVISION.geometry, n, REVISION.count);
                for (let t = 0; t < REVISION.count; ++t) {
                    const n = new Matrix4();
                    REVISION.getMatrixAt(t, n), this.setMatrixAt(t, n);
                }
                this.meshMatrix = REVISION.matrixWorld, this.frustumCulled = !1, this.matrixAutoUpdate = !1, this.renderOrder = -1;
            }
            update(REVISION, t) {
                var n = new Matrix4(), i = REVISION.normal.x * t.x + REVISION.normal.y * t.y + REVISION.normal.z * t.z + -REVISION.constant * t.w, r = n.elements;
                r[0] = i - t.x * REVISION.normal.x, r[4] = -t.x * REVISION.normal.y, r[8] = -t.x * REVISION.normal.z, r[12] = -t.x * -REVISION.constant, r[1] = -t.y * REVISION.normal.x, r[5] = i - t.y * REVISION.normal.y, r[9] = -t.y * REVISION.normal.z, r[13] = -t.y * -REVISION.constant, r[2] = -t.z * REVISION.normal.x, r[6] = -t.z * REVISION.normal.y, r[10] = i - t.z * REVISION.normal.z, r[14] = -t.z * -REVISION.constant, r[3] = -t.w * REVISION.normal.x, r[7] = -t.w * REVISION.normal.y, r[11] = -t.w * REVISION.normal.z, r[15] = i - t.w * -REVISION.constant, this.matrix.multiplyMatrices(n, this.meshMatrix);
            }
        }
        var Dv, Lv, Uv, Nv, kv, Fv, Ov, zv, Hv, Wv, Vv, Gv, Qv, Xv, jv = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, qv = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        class Yv {
            constructor(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) {
                if (this.checkpointOrder = null, this.startOrder = null, this.x = REVISION, this.y = t, this.z = n, this.rotation = i, this.rotationAxis = r, this.color = AddEquation, this.type = SubtractEquation, this.matrix = ReverseSubtractEquation, this.checkpointOrder = ZeroFactor, this.startOrder = OneFactor, null != SubtractEquation.configuration.detector && SubtractEquation.configuration.detector.type == qh.Checkpoint) {
                    if (null == ZeroFactor)
                        throw new Error('Checkpoint has no checkpoint order');
                } else if (null != ZeroFactor)
                    throw new Error('Non-checkpoint has checkpoint order');
                if (null != SubtractEquation.configuration.startOffset && null == OneFactor)
                    throw new Error('Start part has no start order');
                if (null == SubtractEquation.configuration.startOffset && null != OneFactor)
                    throw new Error('Non-start part has start order');
            }
        }
        class Kv {
            constructor(REVISION, t, n) {
                Dv.add(this), Lv.set(this, void 0), Uv.set(this, void 0), Nv.set(this, void 0), this.environment = cv.Summer, kv.set(this, new ov()), Fv.set(this, []), Ov.set(this, new Map()), zv.set(this, new Map()), Hv.set(this, {
                    min: new Vector2(0, 0),
                    max: new Vector2(0, 0)
                }), Wv.set(this, null), Vv.set(this, []), jv(this, Lv, REVISION, 'f'), jv(this, Uv, t, 'f'), jv(this, Nv, n, 'f');
            }
            get sunDirection() {
                return qv(this, kv, 'f');
            }
            set sunDirection(REVISION) {
                jv(this, kv, REVISION.clone(), 'f');
            }
            getID() {
                return qv(this, Wv, 'f');
            }
            clear() {
                jv(this, Wv, null, 'f'), qv(this, Fv, 'f').length = 0, qv(this, Ov, 'f').clear(), qv(this, zv, 'f').clear(), qv(this, Dv, 'm', Gv).call(this);
            }
            getPartsAt(REVISION, t, n) {
                const i = qv(this, Ov, 'f').get(REVISION.toString() + '|' + t.toString() + '|' + n.toString());
                return null == i ? [] : i.map(REVISION => ({
                    id: REVISION.type.configuration.id,
                    x: REVISION.x,
                    y: REVISION.y,
                    z: REVISION.z,
                    rotation: REVISION.rotation,
                    rotationAxis: REVISION.rotationAxis,
                    color: REVISION.color,
                    checkpointOrder: REVISION.checkpointOrder,
                    startOrder: REVISION.startOrder
                }));
            }
            setPart(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor) {
                const OneFactor = qv(this, Nv, 'f').getPart(i);
                if (SubtractEquation != dv.Default && !OneFactor.colors.has(SubtractEquation))
                    throw new Error('Track part color does not exist');
                const SrcColorFactor = Kh(r, AddEquation), OneMinusSrcColorFactor = new Vector3(REVISION * Kv.partSize, t * Kv.partSize, n * Kv.partSize), SrcAlphaFactor = new Matrix4().compose(OneMinusSrcColorFactor, SrcColorFactor, new Vector3(1, 1, 1)), OneMinusSrcAlphaFactor = new Yv(REVISION, t, n, r, AddEquation, SubtractEquation, OneFactor, SrcAlphaFactor, ReverseSubtractEquation, ZeroFactor);
                qv(this, Fv, 'f').push(OneMinusSrcAlphaFactor);
                OneFactor.configuration.tiles.rotated(r, AddEquation).forEach((i, r, AddEquation) => {
                    const SubtractEquation = (REVISION + i).toString() + '|' + (t + r).toString() + '|' + (n + AddEquation).toString();
                    if (t + r < 0)
                        throw new Error('Track part below ground');
                    {
                        const REVISION = qv(this, Ov, 'f').get(SubtractEquation);
                        null == REVISION ? qv(this, Ov, 'f').set(SubtractEquation, [OneMinusSrcAlphaFactor]) : REVISION.push(OneMinusSrcAlphaFactor);
                    }
                });
                const DstAlphaFactor = qv(this, zv, 'f').get(i);
                null == DstAlphaFactor ? qv(this, zv, 'f').set(i, [OneMinusSrcAlphaFactor]) : DstAlphaFactor.push(OneMinusSrcAlphaFactor);
            }
            deleteSpecificPart(REVISION, t, n, i, r, AddEquation) {
                for (const SubtractEquation of qv(this, Fv, 'f'))
                    if (SubtractEquation.type.configuration.id == REVISION && SubtractEquation.x == t && SubtractEquation.y == n && SubtractEquation.z == i && SubtractEquation.rotation == r && SubtractEquation.rotationAxis == AddEquation)
                        return qv(this, Dv, 'm', Qv).call(this, SubtractEquation), !0;
                return !1;
            }
            getBounds() {
                return qv(this, Hv, 'f');
            }
            generateMeshes() {
                qv(this, Dv, 'm', Gv).call(this);
                const REVISION = qv(this, kv, 'f').getSunPosition(), t = new Vector4(REVISION.x, REVISION.y, REVISION.z, 0);
                let n, i = null;
                if (2 == qv(this, Uv, 'f').getSettingInteger(dm.ShadowQuality))
                    switch (this.environment) {
                    case cv.Summer:
                        i = new Color(2511171);
                        break;
                    case cv.Winter:
                        i = new Color(7904713);
                        break;
                    case cv.Desert:
                        i = new Color(7958351);
                    }
                switch (this.environment) {
                case cv.Summer:
                    n = dv.Summer;
                    break;
                case cv.Winter:
                    n = dv.Winter;
                    break;
                case cv.Desert:
                    n = dv.Desert;
                }
                const r = qv(this, Lv, 'f').isTrackShadowsEnabled();
                for (const REVISION of qv(this, Nv, 'f').getAllParts())
                    for (const [AddEquation, SubtractEquation] of REVISION.colors) {
                        const ReverseSubtractEquation = [];
                        for (const t of qv(this, Fv, 'f')) {
                            let i = t.color;
                            i == dv.Default && (i = n), t.type == REVISION && i == AddEquation && ReverseSubtractEquation.push(t);
                        }
                        if (ReverseSubtractEquation.length > 0) {
                            if (null == SubtractEquation)
                                throw new Error('Mesh is not loaded');
                            const REVISION = new InstancedMesh(SubtractEquation.geometry, SubtractEquation.material, ReverseSubtractEquation.length);
                            REVISION.frustumCulled = !1, REVISION.castShadow = r, REVISION.receiveShadow = !0;
                            for (let t = 0; t < ReverseSubtractEquation.length; ++t)
                                REVISION.setMatrixAt(t, ReverseSubtractEquation[t].matrix);
                            if (qv(this, Lv, 'f').scene.add(REVISION), qv(this, Vv, 'f').push(REVISION), null != i) {
                                const n = new StereoCamera(REVISION, i);
                                n.update(new Plane(new Vector3(0, 1, 0), 0), t), qv(this, Lv, 'f').scene.add(n), qv(this, Vv, 'f').push(n);
                            }
                        }
                    }
                qv(this, Dv, 'm', Xv).call(this);
            }
            getCheckpoints() {
                let REVISION = [];
                const t = qv(this, Nv, 'f').getPartTypesWithDetector(qh.Checkpoint);
                for (const n of t) {
                    const t = qv(this, zv, 'f').get(n);
                    null != t && (REVISION = REVISION.concat(t));
                }
                return REVISION.map(REVISION => {
                    if (null == REVISION.checkpointOrder)
                        throw new Error('Checkpoint has no checkpoint order');
                    if (null == REVISION.type.configuration.detector)
                        throw new Error('Checkpoint has no detector');
                    return {
                        x: REVISION.x,
                        y: REVISION.y,
                        z: REVISION.z,
                        rotation: REVISION.rotation,
                        rotationAxis: REVISION.rotationAxis,
                        type: REVISION.type.configuration.id,
                        checkpointOrder: REVISION.checkpointOrder,
                        detector: REVISION.type.configuration.detector
                    };
                });
            }
            getCheckpointOrders() {
                let REVISION = [];
                const t = qv(this, Nv, 'f').getPartTypesWithDetector(qh.Checkpoint);
                for (const n of t) {
                    const t = qv(this, zv, 'f').get(n);
                    null != t && (REVISION = REVISION.concat(t));
                }
                return REVISION.map(REVISION => {
                    if (null == REVISION.checkpointOrder)
                        throw new Error('Checkpoint has no checkpoint order');
                    if (null == REVISION.type.configuration.detector)
                        throw new Error('Checkpoint has no detector');
                    return REVISION.checkpointOrder;
                });
            }
            getTotalNumberOfCheckpointIndices() {
                let REVISION = [];
                const t = qv(this, Nv, 'f').getPartTypesWithDetector(qh.Checkpoint);
                for (const n of t) {
                    const t = qv(this, zv, 'f').get(n);
                    null != t && (REVISION = REVISION.concat(t));
                }
                return REVISION.map(REVISION => REVISION.checkpointOrder).filter((REVISION, t, n) => n.indexOf(REVISION) == t).length;
            }
            getStart() {
                let REVISION = -1 / 0, t = null;
                for (const [n, i] of qv(this, zv, 'f')) {
                    const r = qv(this, Nv, 'f').getPartStartOffset(n);
                    if (i.length > 0 && null != r)
                        for (const n of i) {
                            if (null == n.startOrder)
                                throw new Error('Start part has no start order');
                            n.startOrder >= REVISION && (REVISION = n.startOrder, t = {
                                part: n,
                                startOffset: r
                            });
                        }
                }
                return null != t ? {
                    x: t.part.x,
                    y: t.part.y,
                    z: t.part.z,
                    rotation: t.part.rotation,
                    rotationAxis: t.part.rotationAxis,
                    startOffset: t.startOffset
                } : null;
            }
            getStartTransform() {
                const REVISION = this.getStart();
                if (null != REVISION) {
                    const t = Kh(REVISION.rotation, REVISION.rotationAxis).multiply(new Quaternion().setFromEuler(new Euler(0, Math.PI, 0))), n = REVISION.startOffset;
                    return n.applyQuaternion(t), {
                        position: new Vector3(REVISION.x * Kv.partSize + n.x, REVISION.y * Kv.partSize + n.y, REVISION.z * Kv.partSize + n.z),
                        quaternion: t
                    };
                }
                return null;
            }
            getNextStartOrder() {
                let REVISION = 0;
                for (const [t, n] of qv(this, zv, 'f')) {
                    const i = qv(this, Nv, 'f').getPartStartOffset(t);
                    if (n.length > 0 && null != i)
                        for (const t of n) {
                            if (null == t.startOrder)
                                throw new Error('Start part has no start order');
                            REVISION = Math.max(REVISION, t.startOrder + 1);
                        }
                }
                return REVISION;
            }
            getTrackData() {
                const REVISION = new aw(this.environment, qv(this, kv, 'f'));
                for (const t of qv(this, Fv, 'f'))
                    REVISION.addPart(t.x, t.y, t.z, t.type.configuration.id, t.rotation, t.rotationAxis, t.color, t.checkpointOrder, t.startOrder);
                return REVISION;
            }
            loadTrackData(REVISION, t = !0) {
                return this.clear(), jv(this, Wv, t ? REVISION.getId() : null, 'f'), this.environment = REVISION.environment, this.sunDirection = REVISION.sunDirection.clone(), REVISION.forEachPart((REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor) => {
                    this.setPart(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor);
                }), !0;
            }
        }
        Lv = new WeakMap(), Uv = new WeakMap(), Nv = new WeakMap(), kv = new WeakMap(), Fv = new WeakMap(), Ov = new WeakMap(), zv = new WeakMap(), Hv = new WeakMap(), Wv = new WeakMap(), Vv = new WeakMap(), Dv = new WeakSet(), Gv = function () {
            for (const REVISION of qv(this, Vv, 'f'))
                qv(this, Lv, 'f').scene.remove(REVISION);
            qv(this, Vv, 'f').length = 0;
        }, Qv = function (REVISION) {
            const t = qv(this, Fv, 'f').indexOf(REVISION);
            if (!(t >= 0))
                throw new Error('Track part missing from parts list');
            qv(this, Fv, 'f').splice(t, 1);
            REVISION.type.configuration.tiles.rotated(REVISION.rotation, REVISION.rotationAxis).forEach((t, n, i) => {
                const r = (REVISION.x + t).toString() + '|' + (REVISION.y + n).toString() + '|' + (REVISION.z + i).toString(), AddEquation = qv(this, Ov, 'f').get(r);
                if (null == AddEquation)
                    throw new Error('Track part section missing');
                {
                    const t = AddEquation.indexOf(REVISION);
                    if (!(t >= 0))
                        throw new Error('Track part missing from parts by position map');
                    AddEquation.splice(t, 1), 0 == AddEquation.length && qv(this, Ov, 'f').delete(r);
                }
            });
            const n = qv(this, zv, 'f').get(REVISION.type.configuration.id);
            if (null == n)
                throw new Error('Track part type is missing from parts by type map');
            for (let t = 0; t < n.length; ++t) {
                if (n[t] == REVISION) {
                    n.splice(t, 1);
                    break;
                }
                if (t == n.length - 1)
                    throw new Error('Track part is missing from parts by type map');
            }
        }, Xv = function () {
            let REVISION = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const r of qv(this, Fv, 'f'))
                REVISION = Math.min(r.x, REVISION), t = Math.min(r.z, t), n = Math.max(r.x, n), i = Math.max(r.z, i);
            Number.isFinite(REVISION) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? jv(this, Hv, {
                min: new Vector2(REVISION, t),
                max: new Vector2(n, i)
            }, 'f') : jv(this, Hv, {
                min: new Vector2(),
                max: new Vector2()
            }, 'f');
        }, Kv.partSize = 5;
        const Zv = Kv;
        var Jv, $v, ew, tw, nw, iw = function (REVISION, t, n, i, r) {
                if ('m' === i)
                    throw new TypeError('Private method is not writable');
                if ('a' === i && !r)
                    throw new TypeError('Private accessor was defined without a setter');
                if ('function' == typeof t ? REVISION !== t || !r : !t.has(REVISION))
                    throw new TypeError('Cannot write private member to an object whose class did not declare it');
                return 'a' === i ? r.call(REVISION, n) : r ? r.value = n : t.set(REVISION, n), n;
            }, rw = function (REVISION, t, n, i) {
                if ('a' === n && !i)
                    throw new TypeError('Private accessor was defined without a getter');
                if ('function' == typeof t ? REVISION !== t || !i : !t.has(REVISION))
                    throw new TypeError('Cannot read private member from an object whose class did not declare it');
                return 'm' === n ? i : 'a' === n ? i.call(REVISION) : i ? i.value : t.get(REVISION);
            };
        $v = new WeakMap(), ew = new WeakMap(), Jv = new WeakSet(), tw = function () {
            let REVISION = -1 / 0, t = null;
            for (const [n, i] of rw(this, ew, 'f')) {
                const r = Sv(n).startOffset;
                if (i.length > 0 && null != r)
                    for (const n of i) {
                        if (null == n.startOrder)
                            throw new Error('Start part has no start order');
                        n.startOrder >= REVISION && (REVISION = n.startOrder, t = {
                            part: n,
                            startOffset: r
                        });
                    }
            }
            return null != t ? {
                x: t.part.x,
                y: t.part.y,
                z: t.part.z,
                rotation: t.part.rotation,
                rotationAxis: t.part.rotationAxis,
                startOffset: t.startOffset.clone()
            } : null;
        }, nw = function () {
            const REVISION = [];
            REVISION.push(this.environment), REVISION.push(rw(this, $v, 'f').representation);
            let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, AddEquation = -1 / 0, SubtractEquation = -1 / 0;
            for (const [, REVISION] of rw(this, ew, 'f'))
                for (const ReverseSubtractEquation of REVISION)
                    t = Math.min(ReverseSubtractEquation.x, t), n = Math.min(ReverseSubtractEquation.y, n), i = Math.min(ReverseSubtractEquation.z, i), r = Math.max(ReverseSubtractEquation.x, r), AddEquation = Math.max(ReverseSubtractEquation.y, AddEquation), SubtractEquation = Math.max(ReverseSubtractEquation.z, SubtractEquation);
            Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r) && Number.isFinite(AddEquation) && Number.isFinite(SubtractEquation) || (t = 0, n = 0, i = 0, r = 0, AddEquation = 0, SubtractEquation = 0);
            const ReverseSubtractEquation = r - t + 1, ZeroFactor = AddEquation - n + 1, OneFactor = SubtractEquation - i + 1, SrcColorFactor = Math.max(1, Math.min(4, Math.ceil(Math.log2(ReverseSubtractEquation + 1) / 8))), OneMinusSrcColorFactor = Math.max(1, Math.min(4, Math.ceil(Math.log2(ZeroFactor + 1) / 8))), SrcAlphaFactor = Math.max(1, Math.min(4, Math.ceil(Math.log2(OneFactor + 1) / 8)));
            REVISION.push(255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255, 255 & n, n >>> 8 & 255, n >>> 16 & 255, n >>> 24 & 255, 255 & i, i >>> 8 & 255, i >>> 16 & 255, i >>> 24 & 255, 255 & (SrcColorFactor | OneMinusSrcColorFactor << 2 | SrcAlphaFactor << 4));
            for (const [r, AddEquation] of rw(this, ew, 'f')) {
                if (r < 0 || r > 255)
                    throw new Error('Type id is out of range');
                const SubtractEquation = AddEquation.length;
                REVISION.push(255 & r, 255 & SubtractEquation, SubtractEquation >>> 8 & 255, SubtractEquation >>> 16 & 255, SubtractEquation >>> 24 & 255);
                for (const SubtractEquation of AddEquation) {
                    const AddEquation = SubtractEquation.x - t, ReverseSubtractEquation = SubtractEquation.y - n, ZeroFactor = SubtractEquation.z - i;
                    if (1 == SrcColorFactor ? REVISION.push(255 & AddEquation) : 2 == SrcColorFactor ? REVISION.push(255 & AddEquation, AddEquation >>> 8 & 255) : 3 == SrcColorFactor ? REVISION.push(255 & AddEquation, AddEquation >>> 8 & 255, AddEquation >>> 16 & 255) : 4 == SrcColorFactor && REVISION.push(255 & AddEquation, AddEquation >>> 8 & 255, AddEquation >>> 16 & 255, AddEquation >>> 24 & 255), 1 == OneMinusSrcColorFactor ? REVISION.push(255 & ReverseSubtractEquation) : 2 == OneMinusSrcColorFactor ? REVISION.push(255 & ReverseSubtractEquation, ReverseSubtractEquation >>> 8 & 255) : 3 == OneMinusSrcColorFactor ? REVISION.push(255 & ReverseSubtractEquation, ReverseSubtractEquation >>> 8 & 255, ReverseSubtractEquation >>> 16 & 255) : 4 == OneMinusSrcColorFactor && REVISION.push(255 & ReverseSubtractEquation, ReverseSubtractEquation >>> 8 & 255, ReverseSubtractEquation >>> 16 & 255, ReverseSubtractEquation >>> 24 & 255), 1 == SrcAlphaFactor ? REVISION.push(255 & ZeroFactor) : 2 == SrcAlphaFactor ? REVISION.push(255 & ZeroFactor, ZeroFactor >>> 8 & 255) : 3 == SrcAlphaFactor ? REVISION.push(255 & ZeroFactor, ZeroFactor >>> 8 & 255, ZeroFactor >>> 16 & 255) : 4 == SrcAlphaFactor && REVISION.push(255 & ZeroFactor, ZeroFactor >>> 8 & 255, ZeroFactor >>> 16 & 255, ZeroFactor >>> 24 & 255), REVISION.push(3 & SubtractEquation.rotation, 7 & SubtractEquation.rotationAxis, 255 & SubtractEquation.color), Ev.includes(r)) {
                        if (null == SubtractEquation.checkpointOrder)
                            throw new Error('Checkpoint has no checkpoint order');
                        REVISION.push(255 & SubtractEquation.checkpointOrder, SubtractEquation.checkpointOrder >>> 8 & 255);
                    }
                    if (Mv.includes(r)) {
                        if (null == SubtractEquation.startOrder)
                            throw new Error('Start has no start order');
                        REVISION.push(255 & SubtractEquation.startOrder, SubtractEquation.startOrder >>> 8 & 255, SubtractEquation.startOrder >>> 16 & 255, SubtractEquation.startOrder >>> 24 & 255);
                    }
                }
            }
            return new Uint8Array(REVISION);
        };
        const aw = class {
            constructor(REVISION, t) {
                Jv.add(this), $v.set(this, void 0), ew.set(this, new Map()), this.environment = REVISION, iw(this, $v, t.clone(), 'f');
            }
            get sunDirection() {
                return rw(this, $v, 'f').clone();
            }
            set sunDirection(REVISION) {
                iw(this, $v, REVISION.clone(), 'f');
            }
            addPart(REVISION, t, n, i, r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor) {
                const OneFactor = {
                        x: REVISION,
                        y: t,
                        z: n,
                        rotation: r,
                        rotationAxis: AddEquation,
                        color: SubtractEquation,
                        checkpointOrder: ReverseSubtractEquation,
                        startOrder: ZeroFactor
                    }, SrcColorFactor = rw(this, ew, 'f').get(i);
                null != SrcColorFactor ? SrcColorFactor.push(OneFactor) : rw(this, ew, 'f').set(i, [OneFactor]);
            }
            forEachPart(REVISION) {
                for (const [t, n] of rw(this, ew, 'f'))
                    for (const i of n)
                        REVISION(i.x, i.y, i.z, t, i.rotation, i.rotationAxis, i.color, i.checkpointOrder, i.startOrder);
            }
            getId() {
                return (0, K_.sha256)(rw(this, Jv, 'm', nw).call(this));
            }
            getBounds() {
                let REVISION = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0;
                return this.forEachPart((r, AddEquation, SubtractEquation) => {
                    REVISION = Math.min(r, REVISION), t = Math.min(SubtractEquation, t), n = Math.max(r, n), i = Math.max(SubtractEquation, i);
                }), Number.isFinite(REVISION) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? {
                    min: new Vector2(REVISION, t),
                    max: new Vector2(n, i)
                } : {
                    min: new Vector2(),
                    max: new Vector2()
                };
            }
            hasStartingPoint() {
                return null != rw(this, Jv, 'm', tw).call(this);
            }
            getStartTransform() {
                const REVISION = rw(this, Jv, 'm', tw).call(this);
                if (null != REVISION) {
                    const t = Kh(REVISION.rotation, REVISION.rotationAxis).multiply(new Quaternion().setFromEuler(new Euler(0, Math.PI, 0))), n = REVISION.startOffset;
                    return n.applyQuaternion(t), {
                        position: new Vector3(REVISION.x * Zv.partSize + n.x, REVISION.y * Zv.partSize + n.y, REVISION.z * Zv.partSize + n.z),
                        quaternion: t
                    };
                }
                return null;
            }
            toSaveString() {
                const REVISION = rw(this, Jv, 'm', nw).call(this), t = new TYPED_ARRAYS.Deflate({
                        level: 9,
                        windowBits: 9,
                        memLevel: 9
                    });
                t.push(REVISION, !0);
                const n = $_(t.result), i = new TYPED_ARRAYS.Deflate({
                        level: 9,
                        windowBits: 15,
                        memLevel: 9
                    });
                return i.push(n, !0), $_(i.result);
            }
            toExportString(REVISION) {
                const t = new TextEncoder().encode(REVISION.name);
                let n, i;
                null != REVISION.author ? (i = new TextEncoder().encode(REVISION.author), n = i.length) : (i = null, n = 0);
                const r = new Uint8Array(1 + t.length + 1 + n);
                r[0] = t.length, r.set(t, 1), r[1 + t.length] = n, null != i && r.set(i, 1 + t.length + 1);
                const AddEquation = rw(this, Jv, 'm', nw).call(this), SubtractEquation = new TYPED_ARRAYS.Deflate({
                        level: 9,
                        windowBits: 9,
                        memLevel: 9
                    });
                SubtractEquation.push(r, !1), SubtractEquation.push(AddEquation, !0);
                const ReverseSubtractEquation = $_(SubtractEquation.result), ZeroFactor = new TYPED_ARRAYS.Deflate({
                        level: 9,
                        windowBits: 15,
                        memLevel: 9
                    });
                return ZeroFactor.push(ReverseSubtractEquation, !0), 'PolyTrack1' + $_(ZeroFactor.result);
            }
            static fromSaveString(REVISION) {
                const t = function (REVISION) {
                    const t = ev(REVISION);
                    if (null == t)
                        return null;
                    const n = new TYPED_ARRAYS.Inflate({ to: 'string' });
                    if (n.push(t, !0), n.err)
                        return null;
                    const i = n.result;
                    if ('string' != typeof i)
                        return null;
                    const r = ev(i);
                    if (null == r)
                        return null;
                    const AddEquation = new TYPED_ARRAYS.Inflate();
                    if (AddEquation.push(r, !0), AddEquation.err)
                        return null;
                    const SubtractEquation = AddEquation.result;
                    return SubtractEquation instanceof Uint8Array ? Pv(0, SubtractEquation) : null;
                }(REVISION);
                if (null != t)
                    return t;
                const n = Rv(REVISION);
                if (null != n)
                    return n;
                const i = Iv(REVISION);
                if (null != i)
                    return i;
                const r = Cv(REVISION);
                if (null != r)
                    return r;
                const AddEquation = Tv(REVISION);
                return null != AddEquation ? AddEquation : null;
            }
            static fromExportString(REVISION) {
                const t = REVISION.replace(/\s+/g, ''), n = function (REVISION) {
                        const t = 'PolyTrack1';
                        if (!REVISION.startsWith(t))
                            return null;
                        const n = ev(REVISION.substring(10));
                        if (null == n)
                            return null;
                        const i = new TYPED_ARRAYS.Inflate({ to: 'string' });
                        if (i.push(n, !0), i.err)
                            return null;
                        const r = i.result;
                        if ('string' != typeof r)
                            return null;
                        const AddEquation = ev(r);
                        if (null == AddEquation)
                            return null;
                        const SubtractEquation = new TYPED_ARRAYS.Inflate();
                        if (SubtractEquation.push(AddEquation, !0), SubtractEquation.err)
                            return null;
                        const ReverseSubtractEquation = SubtractEquation.result;
                        if (!(ReverseSubtractEquation instanceof Uint8Array))
                            return null;
                        const ZeroFactor = ReverseSubtractEquation[0];
                        if (ReverseSubtractEquation.length < 1 + ZeroFactor)
                            return null;
                        const OneFactor = new TextDecoder('utf-8').decode(ReverseSubtractEquation.subarray(1, 1 + ZeroFactor)), SrcColorFactor = ReverseSubtractEquation[1 + ZeroFactor];
                        if (ReverseSubtractEquation.length < 1 + ZeroFactor + 1 + SrcColorFactor)
                            return null;
                        let OneMinusSrcColorFactor;
                        OneMinusSrcColorFactor = SrcColorFactor > 0 ? new TextDecoder('utf-8').decode(ReverseSubtractEquation.subarray(1 + ZeroFactor + 1, 1 + ZeroFactor + 1 + SrcColorFactor)) : null;
                        const SrcAlphaFactor = Pv(1 + ZeroFactor + 1 + SrcColorFactor, ReverseSubtractEquation);
                        return null == SrcAlphaFactor ? null : {
                            trackMetadata: {
                                name: OneFactor,
                                author: OneMinusSrcColorFactor
                            },
                            trackData: SrcAlphaFactor
                        };
                    }(t);
                if (null != n)
                    return n;
                const i = function (REVISION) {
                    if (!REVISION.startsWith('v3'))
                        return null;
                    const t = ev(REVISION.substring(2, 4));
                    if (null == t)
                        return null;
                    if (1 != t.length)
                        return null;
                    const n = t[0], i = ev(REVISION.substring(4, 4 + n));
                    if (null == i)
                        return null;
                    let r;
                    try {
                        r = new TextDecoder('utf-8').decode(i);
                    } catch (REVISION) {
                        return null;
                    }
                    const AddEquation = Rv(REVISION.substring(4 + n));
                    return null == AddEquation ? null : {
                        trackMetadata: {
                            name: r,
                            author: null
                        },
                        trackData: AddEquation
                    };
                }(t);
                if (null != i)
                    return i;
                const r = function (REVISION) {
                    if (!REVISION.startsWith('v2'))
                        return null;
                    const t = ev(REVISION.substring(2, 4));
                    if (null == t)
                        return null;
                    if (1 != t.length)
                        return null;
                    const n = t[0], i = Math.ceil(n / 3 * 4), r = ev(REVISION.substring(4, 4 + i));
                    if (null == r)
                        return null;
                    let AddEquation;
                    try {
                        AddEquation = new TextDecoder('utf-8').decode(r);
                    } catch (REVISION) {
                        return null;
                    }
                    const SubtractEquation = Iv(REVISION.substring(4 + i));
                    return null == SubtractEquation ? null : {
                        trackMetadata: {
                            name: AddEquation,
                            author: null
                        },
                        trackData: SubtractEquation
                    };
                }(t);
                if (null != r)
                    return r;
                const AddEquation = function (REVISION) {
                    if (!REVISION.startsWith('v1n'))
                        return null;
                    const t = ch(REVISION.substring(3, 5));
                    if (null == t)
                        return null;
                    if (1 != t.length)
                        return null;
                    const n = t[0], i = REVISION.substring(5, 5 + n);
                    let r;
                    try {
                        r = decodeURIComponent(i);
                    } catch (REVISION) {
                        return console.warn(REVISION), null;
                    }
                    const AddEquation = Cv(REVISION.substring(5 + n));
                    return null == AddEquation ? null : {
                        trackMetadata: {
                            name: r,
                            author: null
                        },
                        trackData: AddEquation
                    };
                }(t);
                if (null != AddEquation)
                    return AddEquation;
                const SubtractEquation = function (REVISION) {
                    let t, n;
                    try {
                        t = JSON.parse(REVISION);
                    } catch (REVISION) {
                        return console.warn(REVISION), null;
                    }
                    if ('string' != typeof t.name)
                        return null;
                    if ('string' != typeof t.track)
                        return null;
                    try {
                        n = JSON.parse(t.track);
                    } catch (REVISION) {
                        return console.warn(REVISION), null;
                    }
                    const i = Tv(n);
                    return null == i ? null : {
                        trackMetadata: {
                            name: t.name,
                            author: null
                        },
                        trackData: i
                    };
                }(REVISION);
                return null != SubtractEquation ? SubtractEquation : null;
            }
            createThumbnail() {
                let REVISION = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0;
                this.forEachPart((r, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor) => {
                    Sv(ReverseSubtractEquation).tiles.rotated(ZeroFactor, OneFactor).forEach((AddEquation, ReverseSubtractEquation, ZeroFactor) => {
                        REVISION = Math.min(REVISION, Math.floor((r + AddEquation - 2) / 4)), t = Math.min(t, Math.floor((SubtractEquation + ZeroFactor - 2) / 4)), n = Math.max(n, Math.floor((r + AddEquation - 2) / 4)), i = Math.max(i, Math.floor((SubtractEquation + ZeroFactor - 2) / 4));
                    });
                }), Number.isFinite(REVISION) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) || (REVISION = 0, t = 0, n = 0, i = 0);
                const r = 10, AddEquation = n - REVISION + 1;
                AddEquation <= r && (n += Math.ceil((r - AddEquation) / 2), REVISION -= Math.ceil((r - AddEquation) / 2));
                const SubtractEquation = i - t + 1;
                SubtractEquation <= r && (i += Math.ceil((r - SubtractEquation) / 2), t -= Math.ceil((r - SubtractEquation) / 2));
                const ReverseSubtractEquation = document.createElement('canvas');
                ReverseSubtractEquation.width = Math.min(1024, n - REVISION + 1), ReverseSubtractEquation.height = Math.min(1024, i - t + 1);
                const ZeroFactor = ReverseSubtractEquation.getContext('2d');
                if (null == ZeroFactor)
                    throw new Error('Failed to get canvas context');
                const OneFactor = ZeroFactor.createImageData(ReverseSubtractEquation.width, ReverseSubtractEquation.height), SrcColorFactor = [], OneMinusSrcColorFactor = [], SrcAlphaFactor = [];
                let OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor;
                switch (this.environment) {
                case cv.Summer:
                    OneMinusSrcAlphaFactor = 255, DstAlphaFactor = 255, OneMinusDstAlphaFactor = 255;
                    break;
                case cv.Winter:
                    OneMinusSrcAlphaFactor = 190, DstAlphaFactor = 216, OneMinusDstAlphaFactor = 247;
                    break;
                case cv.Desert:
                    OneMinusSrcAlphaFactor = 237, DstAlphaFactor = 226, OneMinusDstAlphaFactor = 175;
                }
                this.forEachPart((n, i, r, AddEquation, SubtractEquation, ZeroFactor) => {
                    const DstColorFactor = Sv(AddEquation);
                    DstColorFactor.tiles.rotated(SubtractEquation, ZeroFactor).forEach((i, AddEquation, SubtractEquation) => {
                        const ZeroFactor = Math.floor((n + i - 2) / 4) - REVISION, OneMinusDstColorFactor = Math.floor((r + SubtractEquation - 2) / 4) - t, SrcAlphaSaturateFactor = 4 * (ZeroFactor + OneMinusDstColorFactor * ReverseSubtractEquation.width);
                        OneFactor.data[SrcAlphaSaturateFactor + 0] = OneMinusSrcAlphaFactor, OneFactor.data[SrcAlphaSaturateFactor + 1] = DstAlphaFactor, OneFactor.data[SrcAlphaSaturateFactor + 2] = OneMinusDstAlphaFactor, OneFactor.data[SrcAlphaSaturateFactor + 3] = 255, null != DstColorFactor.startOffset ? OneMinusSrcColorFactor.push([
                            ZeroFactor,
                            OneMinusDstColorFactor
                        ]) : null != DstColorFactor.detector && DstColorFactor.detector.type == qh.Checkpoint ? SrcColorFactor.push([
                            ZeroFactor,
                            OneMinusDstColorFactor
                        ]) : null != DstColorFactor.detector && DstColorFactor.detector.type == qh.Finish && SrcAlphaFactor.push([
                            ZeroFactor,
                            OneMinusDstColorFactor
                        ]);
                    });
                });
                for (const [REVISION, t] of SrcColorFactor)
                    OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 0] = 226, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 1] = 192, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 2] = 38, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 3] = 255;
                for (const [REVISION, t] of OneMinusSrcColorFactor)
                    OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 0] = 51, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 1] = 140, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 2] = 224, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 3] = 255;
                for (const [REVISION, t] of SrcAlphaFactor)
                    OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 0] = 209, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 1] = 41, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 2] = 41, OneFactor.data[4 * (REVISION + t * ReverseSubtractEquation.width) + 3] = 255;
                return ZeroFactor.putImageData(OneFactor, 0, 0), ReverseSubtractEquation;
            }
        };
        const sw = class {
            constructor() {
                this.up = !1, this.right = !1, this.down = !1, this.left = !1, this.reset = !1;
            }
            dispose() {
            }
            getControls() {
                return {
                    up: this.up,
                    right: this.right,
                    down: this.down,
                    left: this.left,
                    reset: this.reset
                };
            }
        };
        var ow = function (REVISION, t, n, i) {
            return new (n || (n = Promise))(function (r, AddEquation) {
                function SubtractEquation(REVISION) {
                    try {
                        ZeroFactor(i.next(REVISION));
                    } catch (REVISION) {
                        AddEquation(REVISION);
                    }
                }
                function ReverseSubtractEquation(REVISION) {
                    try {
                        ZeroFactor(i.throw(REVISION));
                    } catch (REVISION) {
                        AddEquation(REVISION);
                    }
                }
                function ZeroFactor(REVISION) {
                    var t;
                    REVISION.done ? r(REVISION.value) : (t = REVISION.value, t instanceof n ? t : new n(function (REVISION) {
                        REVISION(t);
                    })).then(SubtractEquation, ReverseSubtractEquation);
                }
                ZeroFactor((i = i.apply(REVISION, t || [])).next());
            });
        };
        importScripts('lib/ammo.wasm.js');
        const lw = [];
        onmessage = REVISION => {
            lw.push(REVISION);
        }, Ammo().then(function (REVISION) {
            return ow(this, void 0, void 0, function* () {
                yield function () {
                    return E_(this, void 0, void 0, function* () {
                        const REVISION = Uint8Array.from(atob('AGFzbQEAAAABJAZgAXwBfGACfHwBfGACf38AYAJ/fABgBH9/f38Bf2ACfH8BfAMcGwQDAQAAAAAAAAAAAQACBQIBAQAAAAAAAAAAAAUDAQARBgkBfwFBgIDAAAsHVQwGbWVtb3J5AgAEYWNvcwASBGFzaW4AEwRhdGFuABQFYXRhbjIAEANleHAAFQNsb2cAFgNwb3cAEQRzcXJ0ABcDdGFuABgEbG9nMgAZBWxvZzEwABoKsG4bqxsDHH8BfgR8IwBBwARrIgckACAHQQhqQaABEA8gB0GoAWpBoAEQDyAHQcgCakGgARAPIAdB6ANqQdAAEA9BhIDAACgCACIKIAFBf2oiC2ohBSADQX1qQRhtIgRBACAEQQBKGyIPIAtrIQQgD0ECdCABQQJ0a0GUgMAAaiEJQQAhAQNAIAdBCGogAUEDdGogBEEASAR8RAAAAAAAAAAABSAJKAIAtws5AwAgASAFSQRAIAlBBGohCSAEQQFqIQQgASABIAVJaiIBIAVNDQELCyADQWhqIQVBACEEA0AgBCALaiENIAQgCkkhBkQAAAAAAAAAACEhQQAhAQNAAkAgISAAIAFBA3RqKwMAIAdBCGogDSABa0EDdGorAwCioCEhIAEgC08NACABIAEgC0lqIgEgC00NAQsLIAdByAJqIARBA3RqICE5AwAgBCAKSQRAIAQgBmoiBCAKTQ0BCwtEAAAAAAAA8H9EAAAAAAAA4H8gBSAPQWhsIhdqIgZB/g9LIhIbRAAAAAAAAAAARAAAAAAAAGADIAZBuXBJIhMbRAAAAAAAAPA/IAZBgnhIIhQbIAZB/wdKIhUbIAZB/RcgBkH9F0gbQYJwaiAGQYF4aiASGyIYIAZB8GggBkHwaEobQZIPaiAGQckHaiATGyIZIAYgFBsgFRtB/wdqrUI0hr+iISMgB0HkA2oiECAKQQJ0aiENQRcgBmtBH3EhGkEYIAZrQR9xIRYgB0HAAmohGyAGQX9qIRwgCiEEAkADQCAHQcgCaiAEIgVBA3RqKwMAISECQCAFRQ0AIAdB6ANqIQggBSEBA0AgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhBCAhQQBB/////wcgIplEAAAAAAAA4EFjBH8gIqoFQYCAgIB4C0GAgICAeCAEGyAiRAAAwP///99BZBsgIiAiYhu3IiJEAAAAAAAAcMGioCIhRAAAAAAAAODBZiEEIAhBAEH/////BwJ/ICGZRAAAAAAAAOBBYwRAICGqDAELQYCAgIB4C0GAgICAeCAEGyAhRAAAwP///99BZBsgISAhYhs2AgAgGyABQQN0aisDACAioCEhIAFBAkkiBA0BIAhBBGohCEEBIAFBf2ogBBsiAQ0ACwsCfwJAIBVFBEAgFA0BIAYMAgsgIUQAAAAAAADgf6IiIUQAAAAAAADgf6IgISASGyEhIBgMAQsgIUQAAAAAAABgA6IiIUQAAAAAAABgA6IgISATGyEhIBkLIQECQCAhIAFB/wdqrUI0hr+iIiREAAAAAAAAwD+iIiFEAAAAAAAAAABhDQAgIb0iIEI0iKdB/w9xIgFBsghLDQACQAJAICBCAFkEQCAHICFEAAAAAAAAMEOgRAAAAAAAADDDoCAhoSIiOQO4BCABQf8HTw0BIAcrA7gEGkQAAAAAAAAAACEhDAMLIAcgIUQAAAAAAAAww6BEAAAAAAAAMEOgICGhIiI5A7gEIAFB/wdJDQELICEgIqAiIUQAAAAAAADwv6AgISAiRAAAAAAAAAAAZBshIQwBCyAHKwO4BBpEAAAAAAAA8L8hIQsgJCAhRAAAAAAAACDAoqAiIUQAAAAAAADgwWYhASAhQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggARsgIUQAAMD////fQWQbICEgIWIbIg63oSEhAn8CQAJAAkACQAJ/IAZBAEoiHUUEQCAGRQRAIBAgBUECdGooAgBBF3UMAgtBAiEMQQAgIUQAAAAAAADgP2ZFDQYaDAILIBAgBUECdGoiASABKAIAIgEgASAWdSIBIBZ0ayIENgIAIAEgDmohDiAEIBp1CyIMQQFIDQELIAUNAUEAIQgMAgsgDAwCC0EAIRFBACEIIAVBAUcEQCAFQR5xIR4gB0HoA2ohAQNAIAEoAgAhBEH///8HIQkCfwJAIAgNAEGAgIAIIQkgBA0AQQEMAQsgASAJIARrNgIAQQALIQkgAUEEaiIfKAIAIQhB////ByEEAn8CQCAJRQ0AQYCAgAghBCAIDQBBAAwBCyAfIAQgCGs2AgBBAQshCCABQQhqIQEgHiARQQJqIhFHDQALCyAFQQFxRQ0AIAdB6ANqIBFBAnRqIgkoAgAhAUH///8HIQQCQCAIDQBBgICACCEEIAENAEEAIQgMAQsgCSAEIAFrNgIAQQEhCAsCQCAdRQ0AQf///wMhAQJAAkAgHA4CAQACC0H///8BIQELIBAgBUECdGoiBCAEKAIAIAFxNgIACyAOQQFqIQ4gDCAMQQJHDQAaRAAAAAAAAPA/ICGhICNEAAAAAAAAAAAgCBuhISFBAgshDCAhRAAAAAAAAAAAYQRAIA0hASAFIQQCQCAKIAVBf2oiCEsNAEEAIQkDQAJAIAdB6ANqIAhBAnRqKAIAIAlyIQkgCiAITw0AIAogCCAKIAhJayIITQ0BCwsgBSEEIAlFDQAgBUECdCAHakHkA2ohAQNAIAVBf2ohBSAGQWhqIQYgASgCACABQXxqIQFFDQALDAMLA0AgBEEBaiEEIAEoAgAgAUF8aiEBRQ0ACyAFIARPDQEgBUEBaiEJA0AgB0EIaiAJIAtqIgVBA3RqIAkgD2pBAnRBkIDAAGooAgC3OQMAQQAhAUQAAAAAAAAAACEhA0ACQCAhIAAgAUEDdGorAwAgB0EIaiAFIAFrQQN0aisDAKKgISEgASALTw0AIAEgASALSWoiASALTQ0BCwsgB0HIAmogCUEDdGogITkDACAJIARPDQIgCSAESSAJaiIBIQkgASAETQ0ACwwBCwsCQAJAAkBBACAGayIBQf8HTARAIAFBgnhODQMgIUQAAAAAAABgA6IhISABQbhwTQ0BQckHIAZrIQEMAwsgIUQAAAAAAADgf6IhISABQf4PSw0BQYF4IAZrIQEMAgsgIUQAAAAAAABgA6IhISABQfBoIAFB8GhKG0GSD2ohAQwBCyAhRAAAAAAAAOB/oiEhIAFB/RcgAUH9F0gbQYJwaiEBCyAhIAFB/wdqrUI0hr+iIiFEAAAAAAAAcEFmBEAgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhACAhQQBB/////wcCfyAimUQAAAAAAADgQWMEQCAiqgwBC0GAgICAeAtBgICAgHggABsgIkQAAMD////fQWQbICIgImIbtyIhRAAAAAAAAHDBoqAiIkQAAAAAAADgwWYhACAHQegDaiAFQQJ0akEAQf////8HAn8gIplEAAAAAAAA4EFjBEAgIqoMAQtBgICAgHgLQYCAgIB4IAAbICJEAADA////30FkGyAiICJiGzYCACADIBdqIQYgBUEBaiEFCyAhRAAAAAAAAODBZiEAIAdB6ANqIAVBAnRqQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggABsgIUQAAMD////fQWQbICEgIWIbNgIACwJ8AkACQCAGQf8HTARARAAAAAAAAPA/IAZBgnhODQMaIAZBuHBNDQEgBkHJB2ohBkQAAAAAAABgAwwDCyAGQf4PSw0BIAZBgXhqIQZEAAAAAAAA4H8MAgsgBkHwaCAGQfBoShtBkg9qIQZEAAAAAAAAAAAMAQsgBkH9FyAGQf0XSBtBgnBqIQZEAAAAAAAA8H8LIAZB/wdqrUI0hr+iISEgBUEBcQR/IAUFIAdByAJqIAVBA3RqICEgB0HoA2ogBUECdGooAgC3ojkDACAhRAAAAAAAAHA+oiEhIAVBf2oLIQAgBQRAIABBA3QgB2pBwAJqIQEgAEECdCAHakHkA2ohBANAIAEgIUQAAAAAAABwPqIiIiAEKAIAt6I5AwAgAUEIaiAhIARBBGooAgC3ojkDACABQXBqIQEgBEF4aiEEICJEAAAAAAAAcD6iISEgAEEBRyAAQX5qIQANAAsLIAVBAWohBiAHQcgCaiAFQQN0aiEIIAUhAQNAAkAgCiAFIAEiAGsiAyAKIANJGyINRQRAQQAhBEQAAAAAAAAAACEhDAELIA1BAWpBfnEhCUQAAAAAAAAAACEhQQAhAUEAIQQDQCAhIAFBmILAAGorAwAgASAIaiILKwMAoqAgAUGggsAAaisDACALQQhqKwMAoqAhISABQRBqIQEgCSAEQQJqIgRHDQALCyAHQagBaiADQQN0aiANQQFxBHwgIQUgISAEQQN0QZiCwABqKwMAIAdByAJqIAAgBGpBA3RqKwMAoqALOQMAIAhBeGohCCAAQX9qIQEgAA0ACwJAIAZBA3EiAEUEQEQAAAAAAAAAACEhIAUhBAwBCyAHQagBaiAFQQN0aiEBRAAAAAAAAAAAISEgBSEEA0AgBEF/aiEEICEgASsDAKAhISABQXhqIQEgAEF/aiIADQALCyAFQQNPBEAgBEEDdCAHakGQAWohAQNAICEgAUEYaisDAKAgAUEQaisDAKAgAUEIaisDAKAgASsDAKAhISABQWBqIQEgBEEDRyAEQXxqIQQNAAsLIAIgIZogISAMGzkDACAHKwOoASAhoSEhAkAgBUUNAEEBIQEDQCAhIAdBqAFqIAFBA3RqKwMAoCEhIAEgBU8NASABIAEgBUlqIgEgBU0NAAsLIAIgIZogISAMGzkDCCAHQcAEaiQAIA5BB3ELtxIDA38BfgR8IwBBMGsiBCQAAkACQAJAAkACQCABvSIFQiCIpyIDQf////8HcSICQfvUvYAETwRAIAJBvIzxgARPBEAgBEEAQf////8HAn8CQCACQfvD5IkETwRAIAJB//+//wdLDQUgBUL/////////B4NCgICAgICAgLDBAIS/IgFEAAAAAAAA4MFmIQMgAZlEAAAAAAAA4EFjRQ0BIAGqDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwIC0GAgICAeAtBgICAgHggAxsgAUQAAMD////fQWQbIAEgAWIbtyIHOQMAIAEgB6FEAAAAAAAAcEGiIgFEAAAAAAAA4MFmIQMgBEEAQf////8HAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLQYCAgIB4IAMbIAFEAADA////30FkGyABIAFiGyIDtyIHOQMIIAQgASAHoUQAAAAAAABwQaIiATkDECAEQShqQgA3AwAgBEEgakIANwMAIARCADcDGCAEQQJBASADG0EDIAFEAAAAAAAAAABhGyAEQRhqIAJBFHZB6ndqEAAhAiAFQn9VBEAgACACNgIIIAAgBCsDIDkDECAAIAQrAxg5AwAMBwsgAEEAIAJrNgIIIAAgBCsDIJo5AxAgACAEKwMYmjkDAAwGCyACQb3714AETwRAIAJB+8PkgARGBEACQCABIAFEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiBkQAAEBU+yH5v6KgIgEgBkQxY2IaYbTQPaIiCaEiCL1CgICAgICAgPj/AINC/////////4c/Vg0AIAEgBkQAAGAaYbTQPaIiCKEiByAGRHNwAy6KGaM7oiABIAehIAihoSIJoSIIvUKAgICAgICAgP8Ag0L//////////zxWBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwHCyAFQgBZBEAgAEEENgIIIAAgAUQAAEBU+yEZwKAiAUQxY2IaYbTwvaAiBzkDACAAIAEgB6FEMWNiGmG08L2gOQMQDAcLIABBfDYCCCAAIAFEAABAVPshGUCgIgFEMWNiGmG08D2gIgc5AwAgACABIAehRDFjYhphtPA9oDkDEAwGCyACQfyyy4AERg0EIAVCAFkEQCAAQQM2AgggACABRAAAMH982RLAoCIBRMqUk6eRDum9oCIHOQMAIAAgASAHoUTKlJOnkQ7pvaA5AxAMBgsgAEF9NgIIIAAgAUQAADB/fNkSQKAiAUTKlJOnkQ7pPaAiBzkDACAAIAEgB6FEypSTp5EO6T2gOQMQDAULIANB//8/cUH7wyRGDQIgAkH9souABE8EQCAFQn9VBEAgAEECNgIIIAAgAUQAAEBU+yEJwKAiAUQxY2IaYbTgvaAiBzkDACAAIAEgB6FEMWNiGmG04L2gOQMQDAYLIABBfjYCCCAAIAFEAABAVPshCUCgIgFEMWNiGmG04D2gIgc5AwAgACABIAehRDFjYhphtOA9oDkDEAwFCyAFQn9VDQEgAEF/NgIIIAAgAUQAAEBU+yH5P6AiAUQxY2IaYbTQPaAiBzkDACAAIAEgB6FEMWNiGmG00D2gOQMQDAQLIABBADYCCCAAIAEgAaEiATkDECAAIAE5AwAMAwsgAEEBNgIIIAAgAUQAAEBU+yH5v6AiAUQxY2IaYbTQvaAiBzkDACAAIAEgB6FEMWNiGmG00L2gOQMQDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwBCwJAIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUKAgICAgICA+P8Ag0L/////////hz9WDQAgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QoCAgICAgICA/wCDQv//////////PFYEQCAHIQEMAQsgByAGRAAAAC6KGaM7oiIIoSIBIAZEwUkgJZqDezmiIAcgAaEgCKGhIgmhIQgLIAAgCDkDACAAIAEgCKEgCaE5AxAgBkQAAAAAAADgwWYhAyAAQQBB/////wcCfyAGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAtBgICAgHggAxsgBkQAAMD////fQWQbIAYgBmIbNgIICyAEQTBqJAALzA8DCX8CfgV8RAAAAAAAAPA/IQ0CQAJAAkACQCABvSILQiCIpyIIQf////8HcSICIAunIgZyRQ0AIAC9IgxCIIinIQQgDKciCUVBACAEQYCAwP8DRhsNAAJAAkACQAJAAkACQCAEQf////8HcSIFQYCAwP8HSw0AAkAgBUGAgMD/B0YEQCAJIAJBgIDA/wdLcg0CDAELIAJBgYDA/wdPDQELIAJBgIDA/wdHDQEgBg0AIAVBgIDAgHxqIAlyRQ0GIAVB//+//wNLDQJEAAAAAAAAAAAgAZogC0J/VRsPCyAAIAGgDwsgDEIAUw0BIAYNAyACQYCAwP8DRw0CDAULIAFEAAAAAAAAAAAgC0J/VRsPC0ECIQMCQAJAIAJB////mQRLDQBBACEDIAJBgIDA/wNJDQAgAkEUdiEHIAJB////iQRNBEAgBg0EIAJBEyAHayIGdiIHIAZ0IAJHDQJBAiAHQQFxayEDDAILIAZBEyAHayIHdiIKIAd0IAZHDQBBAiAKQQFxayEDIAYNAwwBCyAGDQILIAJBgIDA/wNGDQMLIAhBgICA/wNHBEAgCEGAgICABEcNASAAIACiDwsgDEIAUw0AIAAQBA8LIACZIQ0CQAJAIAkNACAEQX9MBEAgBEGAgICAeEYgBEGAgMD/e0ZyDQIgBEGAgEBHDQEMAgsgBEUgBEGAgMD/A0ZyIARBgIDA/wdGcg0BC0QAAAAAAADwPyEPAkAgDEIAWQ0AAkACQCADDgIAAQILIAAgAKEiACAAow8LRAAAAAAAAPC/IQ8LAkAgAkGAgICPBE0EQCANRAAAAAAAAEBDoiIAIA0gBUGAgMAASSICGyENIAC9QiCIpyAFIAIbIgVB//8/cSIDQYCAwP8DciEEIAVBFHVBzHdBgXggAhtqIQVBACECAkAgA0GPsQ5JDQAgA0H67C5JBEBBASECDAELIANBgICA/wNyIQQgBUEBaiEFCyACQQN0IgNBqIPAAGorAwBEAAAAAAAA8D8gA0GYg8AAaisDACIAIA29Qv////8PgyAErUIghoS/IhCgoyINIBAgAKEiDiACQRJ0IARBAXZqQYCAoIACaq1CIIa/IhEgDiANoiIOvUKAgICAcIO/Ig2ioSAQIBEgAKGhIA2ioaIiACANIA2iIhBEAAAAAAAACECgIAAgDiANoKIgDiAOoiIAIACiIAAgACAAIAAgAETvTkVKKH7KP6JEZdvJk0qGzT+gokQBQR2pYHTRP6CiRE0mj1FVVdU/oKJE/6tv27Zt2z+gokQDMzMzMzPjP6CioCIRoL1CgICAgHCDvyIAoiAOIBEgAEQAAAAAAAAIwKAgEKGhoqAiDiAOIA0gAKIiDaC9QoCAgIBwg78iACANoaFE/QM63AnH7j+iIABE9QFbFOAvPr6ioKAiDSADQbiDwABqKwMAIg4gDSAARAAAAOAJx+4/oiINoKAgBbciEKC9QoCAgIBwg78iACAQoSAOoSANoaEhDgwBCwJAAkAgAkGAgMCfBE0EQCAFQf//v/8DSQ0CIAVBgIDA/wNLDQEgDUQAAAAAAADwv6AiAERE3134C65UPqIgACAAokQAAAAAAADgPyAAIABEAAAAAAAA0L+iRFVVVVVVVdU/oKKhokT+gitlRxX3v6KgIg0gDSAARAAAAGBHFfc/oiINoL1CgICAgHCDvyIAIA2hoSEODAMLIAVB//+//wNNBEBEAAAAAAAA8H9EAAAAAAAAAAAgC0IAUxsPC0QAAAAAAADwf0QAAAAAAAAAACAIQQBKGw8LIAhBAEwNBQwGCyALQgBZDQQMBQsgACALQoCAgIBwg78iEKIiDSAOIAGiIAEgEKEgAKKgIgCgIgG9IgunIQICQCALQiCIpyIDQf//v4QETARAIANBgPj//wdxQf+Xw4QETQ0BIANBgOi8+wNqIAJyDQUgACABIA2hZUUNAQwFCyADQYCAwPt7aiACcg0FIABE/oIrZUcVlzygIAEgDaFkRQ0ADAULQQAhAiAPAnwgA0H/////B3FBgICA/wNLBH5BAEGAgMAAIANBFHZBAmp2IANqIgNB//8/cUGAgMAAckETIANBFHYiBGt2IgJrIAIgC0IAUxshAiAAIA1BgIBAIARBAWp1IANxrUIghr+hIg2gvQUgCwtCgICAgHCDvyIBRAAAAABDLuY/oiIOIAAgASANoaFE7zn6/kIu5j+iIAFEOWyoDGFcIL6ioCINoCIAIAAgACAAIACiIgEgASABIAEgAUTQpL5yaTdmPqJE8WvSxUG9u76gokQs3iWvalYRP6CiRJO9vhZswWa/oKJEPlVVVVVVxT+goqEiAaIgAUQAAAAAAAAAwKCjIA0gACAOoaEiASAAIAGioKGhRAAAAAAAAPA/oCIAvSILQiCIpyACQRR0aiIDQYCAwABOBEAgC0L/////D4MgA61CIIaEvwwBCyAAIAIQDguiIQ0MAQtEAAAAAAAA8D8gDaMgDSALQgBTGyENIAxCf1UNACADIAVBgIDAgHxqckUEQCANIA2hIgAgAKMPCyANmiANIANBAUYbDwsgDQ8LIAtCf1UEQCAADwtEAAAAAAAA8D8gAKMPCyAPRFnz+MIfbqUBokRZ8/jCH26lAaIPCyAPRJx1AIg85Dd+okScdQCIPOQ3fqILswcDBH8BfgN8IwBBIGsiAiQAAkACQAJ8AkACQCAAvSIFQiCIp0H/////B3EiAUH8w6T/A08EQCABQf//v/8HTQRAIAJBCGogABABIAIoAhAhAyACKwMYIQggAisDCCIHvSIFQoCAgICA/////wCDQoCAgIDwhOXyP1YiBA0CDAULIAAgAKEhAAwFCyABQYCAgPIDTwRAIAVCgICAgID/////AINCgICAgPCE5fI/ViIBDQIgAAwDCyACIABEAAAAAAAAcDiiIABEAAAAAAAAcEegIAFBgIDAAEkbOQMIIAIrAwgaDAQLRBgtRFT7Iek/IAcgB5ogBUJ/VSIBG6FEB1wUMyamgTwgCCAImiABG6GgIQdEAAAAAAAAAAAhCAwCC0QYLURU+yHpPyAAmiAAIAVCAFMboUQHXBQzJqaBPKALIgcgByAHIAeiIgaiIgBEY1VVVVVV1T+iIAYgACAGIAaiIgAgACAAIAAgAERzU2Dby3XzvqJEppI3oIh+FD+gokQBZfLy2ERDP6CiRCgDVskibW0/oKJEN9YGhPRklj+gokR6/hARERHBP6AgBiAAIAAgACAAIABE1Hq/dHAq+z6iROmn8DIPuBI/oKJEaBCNGvcmMD+gokQVg+D+yNtXP6CiRJOEbunjJoI/oKJE/kGzG7qhqz+goqCiRAAAAAAAAAAAoKJEAAAAAAAAAACgoCIGoCEAIAFFDQFEAAAAAAAA8D8gByAGIAAgAKIgAEQAAAAAAADwP6CjoaAiACAAoKEiAJogACAFQgBTGyEADAELIANBAXEhASAHIAcgByAHoiIGoiIARGNVVVVVVdU/oiAIIAYgCCAAIAYgBqIiACAAIAAgACAARHNTYNvLdfO+okSmkjegiH4UP6CiRAFl8vLYREM/oKJEKANWySJtbT+gokQ31gaE9GSWP6CiRHr+EBEREcE/oCAGIAAgACAAIAAgAETUer90cCr7PqJE6afwMg+4Ej+gokRoEI0a9yYwP6CiRBWD4P7I21c/oKJEk4Ru6eMmgj+gokT+QbMbuqGrP6CioKKgoqCgIgigIQAgBEUEQCABRQ0BRAAAAAAAAPC/IACjIgYgAL1CgICAgHCDvyIAIAa9QoCAgIBwg78iBqJEAAAAAAAA8D+gIAggACAHoaEgBqKgoiAGoCEADAELRAAAAAAAAPA/IAG3IgYgBqChIgYgByAIIAAgAKIgBiAAoKOhoCIAIACgoSIAmiAAIAVCAFMbIQALIAJBIGokACAAC9UEAgl/AX4gAL0iCkIgiKciAUGAgMD/B3FBgIDA/wdGBEAgACAAoiAAoA8LIAqnIQICfwJ/AkACQAJAAkAgAUEATARAIAFB/////wdxIAJyRQ0CIApCf1cNAQsgAUEUdSABQf//P0sNBRpBASEEIAEEQCACIQMMBAsgAiEDA0AgBEFraiEEIAMiAkEVdCEDIAJBgBBJDQALDAILIAAgAKEiACAAoyEACyAADwsgAkELdiIBIAJBAEgNARoLIAFBFCABZ0Efc2siBXQLIQEgAyAFdCECIANBACAFa3YgAXIhASAEIAVrCyABQf//P3FBgIDAAHIhA0GBeGoiCUEBcQRAIANBAXQgAkEfdnIhAyACQQF0IQILIANBAXQgAkEfdnIhBCACQQF0IQNBgICAASEBQQAhAgNAIAIgASACaiIFIAFqIAUgBEoiBhshAiAEQQAgBSAGG2tBAXQgA0EfdnIhBCADQQF0IQNBACABIAYbIAdqIQcgAUEBSyABQQF2IQENAAtBgICAgHghBUEAIQYDQCAEIAJMQQAgAiAERyADIAggBSIBaiIFSXIbRQRAIAQgAmsgAyAFSWshBCACIAVBAEggASAFaiIIQX9KcWohAiABIAZqIQYgAyAFayEDCyAEQQF0IANBH3ZyIQQgAUEBdiEFIANBAXQhAyABQQJPDQALAkAgAyAEckUNACAGQX9GBEAgB0EBaiEHQQAhBgwBCyAGQQFxIAZqIQYLIAdBH3QgBkEBdnKtIAlBE3RBgIBAcSAHQQF1akGAgID/A2qtQiCGhL8LrQUDA38BfgJ8IwBBEGshASAAvSIEQj+IpyECAkACfCAAAn8CQAJAAkACQCAEQiCIp0H/////B3EiA0GrxpiEBE8EQCAAIABiBEAgAA8LIABE7zn6/kIuhkBkDQIgAETSvHrdKyOGwGNFDQEgAUQAAAAAAACgtiAAo7Y4AgQgASoCBBogAERRMC3VEEmHwGNFDQEMBwsgA0HC3Nj+A00EQCADQYCAwPEDTQ0DQQAhASAADAYLIANBscXC/wNNDQMLIABE/oIrZUcV9z+iIAJBA3RBiIPAAGorAwCgIgVEAAAAAAAA4MFmIQJBAEH/////BwJ/IAWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C0GAgICAeCACGyAFRAAAwP///99BZBsgBSAFYhsMAwsgAEQAAAAAAADgf6IPCyABIABEAAAAAAAA4H+gOQMIIAErAwgaIABEAAAAAAAA8D+gDwsgAkEBcyACawsiAbciBUQAAOD+Qi7mv6KgIgAgBUR2PHk17znqPaIiBqELIQUgACAFIAUgBSAFoiIAIAAgACAAIABE0KS+cmk3Zj6iRPFr0sVBvbu+oKJELN4lr2pWET+gokSTvb4WbMFmv6CiRD5VVVVVVcU/oKKhIgCiRAAAAAAAAABAIAChoyAGoaBEAAAAAAAA8D+gIQUgAUUNAAJAAkACQCABQf8HTARAIAFBgnhODQMgBUQAAAAAAABgA6IhBSABQbhwTQ0BIAFByQdqIQEMAwsgBUQAAAAAAADgf6IhBSABQf4PSw0BIAFBgXhqIQEMAgsgBUQAAAAAAABgA6IhBSABQfBoIAFB8GhKG0GSD2ohAQwBCyAFRAAAAAAAAOB/oiEFIAFB/RcgAUH9F0gbQYJwaiEBCyAFIAFB/wdqrUI0hr+iIQULIAULygUDAX8BfgF8AkAgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEAgAUGAgID/A08EQCACQn9VBEBEAAAAAAAA8D8gAKFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyAAEAQiA6IgACADvUKAgICAcIO/IgAgAKKhIAMgAKCjoCAAoCIAIACgDwtEGC1EVPsh+T8gAEQAAAAAAADwP6BEAAAAAAAA4D+iIgAQBCIDIAMgACAAIAAgACAAIABECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiAAIAAgACAARIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjokQHXBQzJqaRvKCgoSIAIACgIQMMAgtEGC1EVPsh+T8hAyABQYGAgOMDSQ0BRAdcFDMmppE8IAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACioSAAoUQYLURU+yH5P6APCyACpyABQYCAwIB8anIEQEQAAAAAAAAAACAAIAChow8LRAAAAAAAAAAARBgtRFT7IQlAIAJCf1UbDwsgAwvJBAMBfwF+A3wgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEACQAJ8AkAgAUGAgID/A08EQEQAAAAAAADwPyAAmaFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyEFIAAQBCEDIAFBsua8/wNLDQFEGC1EVPsh6T8gA71CgICAgHCDvyIEIASgoUQHXBQzJqaRPCAAIAQgBKKhIAMgBKCjIgAgAKChIAUgAyADoKKhoEQYLURU+yHpP6AMAgsgAUGAgEBqQYCAgPIDSQ0CIAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACiIACgDwtEGC1EVPsh+T8gAyAFIAOioCIAIACgRAdcFDMmppG8oKELIgCaIAAgAkIAUxshAAsgAA8LIAKnIAFBgIDAgHxqcgRARAAAAAAAAAAAIAAgAKGjDwsgAEQYLURU+yH5P6JEAAAAAAAAcDigC48EAwJ/AX4DfCMAQRBrIQICQAJ/AkACQAJAIAC9IgNCIIinQf////8HcSIBQf//v6AETQRAIAFBgIDw/gNJDQEgAJkhACABQYCAzP8DSQ0DIAFBgICOgARJDQJEAAAAAAAA8L8gAKMhAEEDDAQLIAAgAGINBEQYLURU+yH5PyAApg8LQX8gAUGAgIDyA08NAhogAUGAgMAATw0DIAIgALY4AgwgAioCDBogAA8LIABEAAAAAAAA+L+gIABEAAAAAAAA+D+iRAAAAAAAAPA/oKMhAEECDAELIAFBgICY/wNPBEAgAEQAAAAAAADwv6AgAEQAAAAAAADwP6CjIQBBAQwBCyAAIACgRAAAAAAAAPC/oCAARAAAAAAAAABAoKMhAEEACyECIAAgAKIiBSAFoiIEIAQgBCAEIAREL2xqLES0or+iRJr93lIt3q2/oKJEbZp0r/Kws7+gokRxFiP+xnG8v6CiRMTrmJmZmcm/oKIhBiAFIAQgBCAEIAQgBEQR2iLjOq2QP6JE6w12JEt7qT+gokRRPdCgZg2xP6CiRG4gTMXNRbc/oKJE/4MAkiRJwj+gokQNVVVVVVXVP6CiIQQgAUGAgPD+A08EQCACQQN0IgFByIPAAGorAwAgACAGIASgoiABQeiDwABqKwMAoSAAoaEiAJogACADQgBTGw8LIAAgACAGIASgoqEhAAsgAAvnAwMDfwF+BnwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyACQeK+JWoiAUEUdiADarciB0QAYJ9QE0TTP6IiCCAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAAgAEQAAAAAAADgP6KiIgWhvUKAgICAcIO/IgZEAAAgFXvL2z+iIgmgIgogCSAIIAqhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACAVe8vbP6IgB0Q2K/ER8/5ZPaIgACAGoETVrZrKOJS7PaKgoKCgDwsgACAAoUQAAAAAAAAAAKMhAAsgAAvOAwMDfwF+BXwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyAEQv////8PgyACQeK+JWoiAUH//z9xQZ7Bmv8Daq1CIIaEv0QAAAAAAADwv6AiACAAIABEAAAAAAAA4D+ioiIFob1CgICAgHCDvyIGRAAAIGVHFfc/oiIHIAFBFHYgA2q3IgigIgkgByAIIAmhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACBlRxX3P6IgACAGoEQAou8u/AXnPaKgoKAPCyAAIAChRAAAAAAAAAAAoyEACyAAC6UDAgV/AX4gASABYSAAIABhcUUEQCAAIAGgDwsgAb0iB0IgiKciAkGAgMCAfGogB6ciBXJFBEAgABAIDwsgAkEedkECcSIGIAC9IgdCP4inciEDAkACQAJAIAdCIIinQf////8HcSIEIAenckUEQEQYLURU+yEJwCEBAkACQCADDgMAAAEDCyAADwtEGC1EVPshCUAPCyACQf////8HcSICIAVyRQ0CAkAgAkGAgMD/B0YEQCAEQYCAwP8HRw0BRNIhM3982QLAIQEgA0EDRg0CIANBA3RB2ILAAGorAwAPCyAEQYCAwP8HRiACQYCAgCBqIARJcg0CAnwgBgRARAAAAAAAAAAAIARBgICAIGogAkkNARoLIAAgAaOZEAgLIQECQAJAAkAgAw4DBAECAAsgAUQHXBQzJqahvKBEGC1EVPshCcCgDwsgAZoPC0QYLURU+yEJQCABRAdcFDMmpqG8oKEPC0QYLURU+yEJwCEBIANBA0YNACADQQN0QfCCwABqKwMAIQELIAEPC0QYLURU+yH5PyAApg8LRBgtRFT7Ifk/IACmC54DAwN/AX4CfAJAAkACQAJAIAC9IgRCAFMNACAEQiCIpyIBQYCAwABJDQAgAUH//7//B0sNA0GAgMD/AyECQYF4IQMgAUGAgMD/A0cEQCABIQIMAgsgBKcNAUQAAAAAAAAAAA8LIAC9Qv///////////wCDUARARAAAAAAAAPC/IAAgAKKjDwsgBEIAUw0BIABEAAAAAAAAUEOivSIEQiCIpyECQct3IQMLIAJB4r4laiIBQRR2IANqtyIFRAAA4P5CLuY/oiAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAVEdjx5Ne856j2iIAAgAEQAAAAAAAAAQKCjIgUgACAARAAAAAAAAOA/oqIiBiAFIAWiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAgBqGgoA8LIAAgAKFEAAAAAAAAAACjIQALIAALjgEBAn8gAUEQTwRAIABBACAAa0EDcSIDaiECIAMEQANAIABBADoAACAAQQFqIgAgAkkNAAsLIAIgASADayIBQXxxIgNqIQAgA0EBTgRAA0AgAkEANgIAIAJBBGoiAiAASQ0ACwsgAUEDcSEBCyABBEAgACABaiEBA0AgAEEAOgAAIABBAWoiACABSQ0ACwsLrAEAAkACQAJAIAFB/wdMBEAgAUGCeE4NAyAARAAAAAAAAGADoiEAIAFBuHBNDQEgAUHJB2ohAQwDCyAARAAAAAAAAOB/oiEAIAFB/g9LDQEgAUGBeGohAQwCCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEobQZIPaiEBDAELIABEAAAAAAAA4H+iIQAgAUH9FyABQf0XSBtBgnBqIQELIAAgAUH/B2qtQjSGv6ILCAAgACABEA0LCAAgACABEAsLCAAgACABEAILBgAgABAGCwYAIAAQBwsGACAAEAgLBgAgABAFCwYAIAAQDAsGACAAEAQLBgAgABADCwYAIAAQCgsGACAAEAkLC+YKBQBBgIDAAAvwAgMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAAAABA+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k1GC1EVPsh6T8YLURU+yHpv9IhM3982QJAAEH/gsAACymAGC1EVPshCUAAAAAAAADgPwAAAAAAAOC/AAAAAAAA8D8AAAAAAAD4PwBBsIPAAAsIBtDPQ+v9TD4AQcODwAALmQdAA7jiP0+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTxMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAAgCEAAqAAAAQzpcVXNlcnNcSm9uYXRoYW5cLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxvbmNlX2NlbGwtMS4yMC4yXHNyYy9saWIucnMAADwCEABiAAAACAMAABkAAAByZWVudHJhbnQgaW5pdAAAsAIQAA4AAAA8AhAAYgAAAHoCAAANAAAABAAAAAwAAAAEAAAABQAAAAYAAAAHAAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAPACEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADwAhAAKQAAAK4EAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAmAMQABUAAACtAxAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc8wDEAAYAAAAZAEAAAkAAAAEAAAADAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAACQAAAAAAAAAIAAAABAAAAAoAAAALAAAADAAAAA0AAAAOAAAAEAAAAAQAAAAPAAAAEAAAABEAAAASAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAABMBBAAEQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNoBBAAHAAAABkAAAAFAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAQfSKwAALAQEAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuODEuMCAoZWViOTBjZGExIDIwMjQtMDktMDQpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0'), REVISION => REVISION.charCodeAt(0)), t = yield WebAssembly.compile(REVISION), n = (yield WebAssembly.instantiate(t)).exports;
                        Math = {
                            E: M_,
                            LN10: T_,
                            LN2: C_,
                            LOG2E: I_,
                            LOG10E: R_,
                            PI: P_,
                            SQRT1_2: B_,
                            SQRT2: D_,
                            abs: Math.abs,
                            acos: n.acos,
                            asin: n.asin,
                            atan: n.atan,
                            atan2: n.atan2,
                            ceil: Math.ceil,
                            cos: k_,
                            exp: n.exp,
                            floor: Math.floor,
                            log: n.log,
                            max: Math.max,
                            min: Math.min,
                            pow: n.pow,
                            random: Math.random,
                            round: Math.round,
                            sin: N_,
                            sqrt: n.sqrt,
                            tan: n.tan,
                            clz32: () => U_('clz32'),
                            imul: () => U_('imul'),
                            sign: Math.sign,
                            log10: n.log10,
                            log2: n.log2,
                            log1p: () => U_('log1p'),
                            expm1: () => U_('expm1'),
                            cosh: () => U_('cosh'),
                            sinh: () => U_('sinh'),
                            tanh: () => U_('tanh'),
                            acosh: () => U_('acosh'),
                            asinh: () => U_('asinh'),
                            atanh: () => U_('atanh'),
                            hypot: () => U_('hypot'),
                            trunc: Math.trunc,
                            cbrt: () => U_('cbrt'),
                            fround: Math.fround,
                            [Symbol.toStringTag]: 'Math'
                        };
                    });
                }();
                let t = new V_([]);
                const n = [];
                function i(REVISION) {
                    switch (REVISION.data.messageType) {
                    case Q_.Init: {
                            const n = REVISION.data.isRealtime;
                            t = new V_(REVISION.data.trackParts), function (REVISION) {
                                if (REVISION)
                                    if (self.requestAnimationFrame) {
                                        function t() {
                                            ZeroFactor(), self.requestAnimationFrame(t);
                                        }
                                        t();
                                    } else
                                        setInterval(ZeroFactor, 1000 / 60);
                                else
                                    setInterval(OneFactor);
                            }(n);
                            break;
                        }
                    case Q_.Verify:
                        !function (REVISION) {
                            const n = aw.fromSaveString(REVISION.data.trackData);
                            if (null == n)
                                throw new Error('Failed to load track');
                            const i = Sh.deserialize(REVISION.data.carRecording);
                            if (null == i)
                                throw new Error('Failed to deserialize recording');
                            const r = n.getStartTransform();
                            if (null == r)
                                throw new Error('Track has no starting point');
                            const AddEquation = REVISION.data.carId, SubtractEquation = new S_(REVISION.data.mountainVertices, new Vector3(REVISION.data.mountainOffset.x, REVISION.data.mountainOffset.y, REVISION.data.mountainOffset.z), t, n, REVISION.data.carCollisionShapeVertices, REVISION.data.carMassOffset, new Y_(i), r);
                            SubtractEquation.start();
                            const ReverseSubtractEquation = new Xh(REVISION.data.targetFrames);
                            for (; !SubtractEquation.hasFinished() && SubtractEquation.getTime().lessOrEqual(ReverseSubtractEquation);)
                                SubtractEquation.step();
                            const ZeroFactor = SubtractEquation.hasFinished() && SubtractEquation.getTime().equals(ReverseSubtractEquation);
                            postMessage({
                                messageType: Q_.VerifyResult,
                                carId: AddEquation,
                                result: ZeroFactor
                            }), SubtractEquation.dispose();
                        }(REVISION);
                        break;
                    case Q_.TestDeterminism:
                        postMessage({
                            messageType: Q_.DeterminismResult,
                            isDeterminstic: r()
                        });
                        break;
                    case Q_.CreateCar:
                        !function (REVISION) {
                            const i = aw.fromSaveString(REVISION.data.trackData);
                            if (null == i)
                                throw new Error('Failed to load track');
                            let r, AddEquation = null;
                            const SubtractEquation = REVISION.data.carRecording;
                            if (null == SubtractEquation)
                                r = new sw(), AddEquation = [];
                            else {
                                const REVISION = Sh.deserialize(SubtractEquation);
                                if (null == REVISION)
                                    throw new Error('Failed to deserialize recording');
                                r = new Y_(REVISION);
                            }
                            const ReverseSubtractEquation = i.getStartTransform();
                            if (null == ReverseSubtractEquation)
                                throw new Error('Track has no starting point');
                            const ZeroFactor = REVISION.data.carId, OneFactor = new S_(REVISION.data.mountainVertices, new Vector3(REVISION.data.mountainOffset.x, REVISION.data.mountainOffset.y, REVISION.data.mountainOffset.z), t, i, REVISION.data.carCollisionShapeVertices, REVISION.data.carMassOffset, r, ReverseSubtractEquation);
                            n.push({
                                id: ZeroFactor,
                                model: OneFactor,
                                userControls: AddEquation,
                                targetSimulationTime: null,
                                isPaused: !1
                            });
                        }(REVISION);
                        break;
                    case Q_.DeleteCar:
                        !function (REVISION) {
                            const t = REVISION.data.carId;
                            for (let REVISION = 0; REVISION < n.length; REVISION++) {
                                const i = n[REVISION];
                                if (i.id == t) {
                                    i.model.controls.dispose(), i.model.dispose(), n.splice(REVISION, 1);
                                    break;
                                }
                            }
                        }(REVISION);
                        break;
                    case Q_.StartCar:
                        !function (REVISION) {
                            const t = REVISION.data.carId;
                            for (const i of n)
                                if (i.id == t) {
                                    i.model.start();
                                    const t = REVISION.data.targetSimulationTimeFrames;
                                    i.targetSimulationTime = null != t ? new Xh(t) : null;
                                    break;
                                }
                        }(REVISION);
                        break;
                    case Q_.ControlCar:
                        !function (REVISION) {
                            const t = performance.now(), i = REVISION.data.carId;
                            for (const r of n)
                                if (r.id == i) {
                                    if (null == r.userControls)
                                        throw new Error('Tried to control uncontrollable car');
                                    const n = Math.max(0, t - SubtractEquation);
                                    let i = r.model.getTime().numberOfFrames + n;
                                    if (r.model.hasStarted() || (i = 0), 0 == r.userControls.length)
                                        r.userControls.push({
                                            frame: i,
                                            up: REVISION.data.up,
                                            right: REVISION.data.right,
                                            down: REVISION.data.down,
                                            left: REVISION.data.left,
                                            reset: REVISION.data.reset
                                        });
                                    else {
                                        const t = r.userControls[r.userControls.length - 1].frame;
                                        i == t ? r.userControls[r.userControls.length - 1] = {
                                            frame: i,
                                            up: REVISION.data.up,
                                            right: REVISION.data.right,
                                            down: REVISION.data.down,
                                            left: REVISION.data.left,
                                            reset: REVISION.data.reset
                                        } : i > t && r.userControls.push({
                                            frame: i,
                                            up: REVISION.data.up,
                                            right: REVISION.data.right,
                                            down: REVISION.data.down,
                                            left: REVISION.data.left,
                                            reset: REVISION.data.reset
                                        });
                                    }
                                    break;
                                }
                        }(REVISION);
                        break;
                    case Q_.PauseCar:
                        !function (REVISION) {
                            const t = REVISION.data.carId;
                            for (const i of n)
                                if (i.id == t) {
                                    i.isPaused = REVISION.data.isPaused;
                                    break;
                                }
                        }(REVISION);
                    }
                }
                for (const REVISION of lw)
                    i(REVISION);
                function r() {
                    if (3.141592653589793 != Math.PI)
                        return console.error('Determinism check failed: Math.PI'), !1;
                    if (1.4142135623730951 != Math.SQRT2)
                        return console.error('Determinism check failed: Math.SQRT2'), !1;
                    if (0.8325082155867481 != Math.cos(0.587123751237))
                        return console.error('Determinism check failed: Math.cos'), !1;
                    if (0.530868917654027 != Math.sin(2.581961285))
                        return console.error('Determinism check failed: Math.sin'), !1;
                    if (3678159.3874182813 != Math.pow(123, Math.PI))
                        return console.error('Determinism check failed: Math.pow'), !1;
                    if (123 * Math.PI != 386.41589639154455)
                        return console.error('Determinism check failed: Multiply'), !1;
                    if (123 / Math.PI != 39.152116000606256)
                        return console.error('Determinism check failed: Division'), !1;
                    const t = new Vector3(-0.6827400326728821, 0.11212741583585739, 2.6956899166107178), n = new Quaternion(-0.615668535232544, 0.03904851898550987, 0.7859793305397034, 0.04079177975654602), i = new Hh();
                    i.createGroundPlane(), i.activePhysicsAt(new Vector3(0, 0, 0));
                    const r = new REVISION.btTransform();
                    r.setIdentity();
                    const AddEquation = new REVISION.btDefaultMotionState(r);
                    REVISION.destroy(r);
                    const SubtractEquation = new REVISION.btVector3(0, 0, 0), ReverseSubtractEquation = new REVISION.btVector3(0.1, 0.1, 0.1), ZeroFactor = new REVISION.btBoxShape(ReverseSubtractEquation);
                    ZeroFactor.calculateLocalInertia(400, SubtractEquation), REVISION.destroy(ReverseSubtractEquation);
                    const OneFactor = new REVISION.btRigidBodyConstructionInfo(400, AddEquation, ZeroFactor, SubtractEquation), SrcColorFactor = new REVISION.btRigidBody(OneFactor);
                    REVISION.destroy(SubtractEquation), REVISION.destroy(OneFactor), SrcColorFactor.setActivationState(4), i.world.addRigidBody(SrcColorFactor);
                    const OneMinusSrcColorFactor = new REVISION.btVehicleTuning(), SrcAlphaFactor = new REVISION.btDefaultVehicleRaycaster(i.world), OneMinusSrcAlphaFactor = new REVISION.btRaycastVehicle(OneMinusSrcColorFactor, SrcColorFactor, SrcAlphaFactor);
                    OneMinusSrcAlphaFactor.setCoordinateSystem(0, 1, 2), i.world.addAction(OneMinusSrcAlphaFactor);
                    const DstAlphaFactor = new REVISION.btVector3(0, -1, 0), OneMinusDstAlphaFactor = new REVISION.btVector3(-1, 0, 0);
                    for (const t of [
                            'WheelFL',
                            'WheelFR',
                            'WheelBL',
                            'WheelBR'
                        ]) {
                        let n;
                        if ('WheelFL' == t)
                            n = new REVISION.btVector3(0.627909, 0.27, 1.3478);
                        else if ('WheelFR' == t)
                            n = new REVISION.btVector3(-0.627909, 0.27, 1.3478);
                        else if ('WheelBL' == t)
                            n = new REVISION.btVector3(0.720832, 0.27, -1.52686);
                        else {
                            if ('WheelBR' != t)
                                throw new Error('Unidentified wheel');
                            n = new REVISION.btVector3(-0.720832, 0.27, -1.52686);
                        }
                        const i = 'WheelFL' == t || 'WheelFR' == t;
                        OneMinusSrcAlphaFactor.addWheel(n, DstAlphaFactor, OneMinusDstAlphaFactor, 0.12, 0.331, OneMinusSrcColorFactor, i), REVISION.destroy(n);
                    }
                    REVISION.destroy(DstAlphaFactor), REVISION.destroy(OneMinusDstAlphaFactor);
                    const DstColorFactor = new REVISION.btTransform();
                    DstColorFactor.setIdentity(), SrcColorFactor.setWorldTransform(DstColorFactor), SrcColorFactor.getMotionState().setWorldTransform(DstColorFactor), REVISION.destroy(DstColorFactor), OneMinusSrcAlphaFactor.resetSuspension(), OneMinusSrcAlphaFactor.setSteeringValue(0, 0), OneMinusSrcAlphaFactor.setSteeringValue(0, 1);
                    const OneMinusDstColorFactor = new REVISION.btTransform();
                    OneMinusDstColorFactor.setIdentity();
                    const SrcAlphaSaturateFactor = new REVISION.btDefaultMotionState(OneMinusDstColorFactor);
                    REVISION.destroy(OneMinusDstColorFactor);
                    const ConstantColorFactor = new REVISION.btVector3(0, 0, 0), OneMinusConstantColorFactor = new REVISION.btVector3(0.1, 0.1, 0.1), ConstantAlphaFactor = new REVISION.btBoxShape(OneMinusConstantColorFactor);
                    ConstantAlphaFactor.calculateLocalInertia(100, ConstantColorFactor), REVISION.destroy(OneMinusConstantColorFactor);
                    const OneMinusConstantAlphaFactor = new REVISION.btRigidBodyConstructionInfo(100, SrcAlphaSaturateFactor, ConstantAlphaFactor, ConstantColorFactor), b = new REVISION.btRigidBody(OneMinusConstantAlphaFactor);
                    REVISION.destroy(ConstantColorFactor), REVISION.destroy(OneMinusConstantAlphaFactor), b.setActivationState(4), i.world.addRigidBody(b);
                    const aspect = 100000;
                    OneMinusSrcAlphaFactor.applyEngineForce(aspect, 2), OneMinusSrcAlphaFactor.applyEngineForce(aspect, 3);
                    for (let REVISION = 0; REVISION < 999; REVISION++)
                        i.step();
                    const CullFaceFront = new REVISION.btTransform();
                    SrcColorFactor.getMotionState().getWorldTransform(CullFaceFront);
                    const LessEqualDepth = CullFaceFront.getOrigin(), MultiplyBlending = CullFaceFront.getRotation();
                    REVISION.destroy(CullFaceFront);
                    const CustomBlending = t.equals(new Vector3(LessEqualDepth.x(), LessEqualDepth.y(), LessEqualDepth.z())), GreaterDepth = n.equals(new Quaternion(MultiplyBlending.x(), MultiplyBlending.y(), MultiplyBlending.z(), MultiplyBlending.w()));
                    i.dispose(), REVISION.destroy(ZeroFactor), REVISION.destroy(SrcColorFactor), REVISION.destroy(OneMinusSrcAlphaFactor), REVISION.destroy(ConstantAlphaFactor), REVISION.destroy(b);
                    const NotEqualDepth = CustomBlending || GreaterDepth;
                    return NotEqualDepth || console.error('Determinism check failed: Simulation'), NotEqualDepth;
                }
                function AddEquation(REVISION) {
                    var t, n;
                    const i = REVISION.id, r = REVISION.model, AddEquation = r.controls.getControls(r.getTime().numberOfFrames);
                    r.step();
                    const SubtractEquation = r.getPosition(), ReverseSubtractEquation = r.getQuaternion(), ZeroFactor = r.getWheelPosition(0), OneFactor = r.getWheelPosition(1), SrcColorFactor = r.getWheelPosition(2), OneMinusSrcColorFactor = r.getWheelPosition(3), SrcAlphaFactor = r.getWheelQuaternion(0), OneMinusSrcAlphaFactor = r.getWheelQuaternion(1), DstAlphaFactor = r.getWheelQuaternion(2), OneMinusDstAlphaFactor = r.getWheelQuaternion(3);
                    let DstColorFactor = null;
                    if (r.getWheelInContact(0)) {
                        DstColorFactor = {
                            position: r.getWheelContactPosition(0),
                            normal: r.getWheelContactNormal(0)
                        };
                    }
                    let OneMinusDstColorFactor = null;
                    if (r.getWheelInContact(1)) {
                        OneMinusDstColorFactor = {
                            position: r.getWheelContactPosition(1),
                            normal: r.getWheelContactNormal(1)
                        };
                    }
                    let SrcAlphaSaturateFactor = null;
                    if (r.getWheelInContact(2)) {
                        SrcAlphaSaturateFactor = {
                            position: r.getWheelContactPosition(2),
                            normal: r.getWheelContactNormal(2)
                        };
                    }
                    let ConstantColorFactor = null;
                    if (r.getWheelInContact(3)) {
                        ConstantColorFactor = {
                            position: r.getWheelContactPosition(3),
                            normal: r.getWheelContactNormal(3)
                        };
                    }
                    return {
                        id: i,
                        frames: r.getTime().numberOfFrames,
                        speedKmh: r.getSpeedKmh(),
                        hasStarted: r.hasStarted(),
                        finishFrames: null !== (n = null === (t = r.getFinishTime()) || void 0 === t ? void 0 : t.numberOfFrames) && void 0 !== n ? n : null,
                        nextCheckpointIndex: r.getNextCheckpointIndex(),
                        hasCheckpointToRespawnAt: r.hasCheckpointToRespawnAt(),
                        position: {
                            x: SubtractEquation.x,
                            y: SubtractEquation.y,
                            z: SubtractEquation.z
                        },
                        quaternion: {
                            x: ReverseSubtractEquation.x,
                            y: ReverseSubtractEquation.y,
                            z: ReverseSubtractEquation.z,
                            w: ReverseSubtractEquation.w
                        },
                        collisionImpulses: r.getCollisionImpulses(),
                        wheelContact: [
                            DstColorFactor,
                            OneMinusDstColorFactor,
                            SrcAlphaSaturateFactor,
                            ConstantColorFactor
                        ],
                        wheelSuspensionLength: [
                            r.getWheelSuspensionLength(0),
                            r.getWheelSuspensionLength(1),
                            r.getWheelSuspensionLength(2),
                            r.getWheelSuspensionLength(3)
                        ],
                        wheelSuspensionVelocity: [
                            r.getWheelSuspensionVelocity(0),
                            r.getWheelSuspensionVelocity(1),
                            r.getWheelSuspensionVelocity(2),
                            r.getWheelSuspensionVelocity(3)
                        ],
                        wheelRotation: [
                            r.getWheelRotation(0),
                            r.getWheelRotation(1),
                            r.getWheelRotation(2),
                            r.getWheelRotation(3)
                        ],
                        wheelDeltaRotation: [
                            r.getWheelDeltaRotation(0),
                            r.getWheelDeltaRotation(1),
                            r.getWheelDeltaRotation(2),
                            r.getWheelDeltaRotation(3)
                        ],
                        wheelSkidInfo: [
                            r.getWheelSkidInfo(0),
                            r.getWheelSkidInfo(1),
                            r.getWheelSkidInfo(2),
                            r.getWheelSkidInfo(3)
                        ],
                        wheelPosition: [
                            {
                                x: ZeroFactor.x,
                                y: ZeroFactor.y,
                                z: ZeroFactor.z
                            },
                            {
                                x: OneFactor.x,
                                y: OneFactor.y,
                                z: OneFactor.z
                            },
                            {
                                x: SrcColorFactor.x,
                                y: SrcColorFactor.y,
                                z: SrcColorFactor.z
                            },
                            {
                                x: OneMinusSrcColorFactor.x,
                                y: OneMinusSrcColorFactor.y,
                                z: OneMinusSrcColorFactor.z
                            }
                        ],
                        wheelQuaternion: [
                            {
                                x: SrcAlphaFactor.x,
                                y: SrcAlphaFactor.y,
                                z: SrcAlphaFactor.z,
                                w: SrcAlphaFactor.w
                            },
                            {
                                x: OneMinusSrcAlphaFactor.x,
                                y: OneMinusSrcAlphaFactor.y,
                                z: OneMinusSrcAlphaFactor.z,
                                w: OneMinusSrcAlphaFactor.w
                            },
                            {
                                x: DstAlphaFactor.x,
                                y: DstAlphaFactor.y,
                                z: DstAlphaFactor.z,
                                w: DstAlphaFactor.w
                            },
                            {
                                x: OneMinusDstAlphaFactor.x,
                                y: OneMinusDstAlphaFactor.y,
                                z: OneMinusDstAlphaFactor.z,
                                w: OneMinusDstAlphaFactor.w
                            }
                        ],
                        brakeLightEnabled: r.isBrakeLightEnabled(),
                        controls: AddEquation
                    };
                }
                lw.length = 0, onmessage = i;
                let SubtractEquation = performance.now(), ReverseSubtractEquation = 0;
                function ZeroFactor() {
                    const REVISION = performance.now();
                    ReverseSubtractEquation += Math.max(0, Math.min(0.1, (REVISION - SubtractEquation) / 1000)), SubtractEquation = REVISION;
                    const t = [];
                    for (; ReverseSubtractEquation > 0.001;) {
                        ReverseSubtractEquation -= 0.001;
                        for (const REVISION of n) {
                            if (null != REVISION.targetSimulationTime)
                                throw new Error('Realtime simulation does not support targetSimulationTime');
                            const n = REVISION.model.getTime().numberOfFrames;
                            if (REVISION.model.hasStarted() && n < Sh.maxFrames && !REVISION.isPaused) {
                                if (null != REVISION.userControls)
                                    for (; REVISION.userControls.length > 0 && REVISION.userControls[0].frame <= n;) {
                                        const t = REVISION.userControls.shift();
                                        if (null != t) {
                                            const n = REVISION.model.controls;
                                            if (!(n instanceof sw))
                                                throw new Error('Tried to control uncontrollable car');
                                            n.up = t.up, n.right = t.right, n.down = t.down, n.left = t.left, n.reset = t.reset;
                                        }
                                    }
                                t.push(AddEquation(REVISION));
                            }
                        }
                    }
                    t.length > 0 && postMessage({
                        messageType: Q_.UpdateResult,
                        carStates: t
                    });
                }
                function OneFactor() {
                    const REVISION = performance.now(), t = [];
                    if (n.length > 0) {
                        let i;
                        do {
                            i = !0;
                            for (let REVISION = 0; REVISION < Math.max(1, Math.ceil(100 / n.length)); REVISION++) {
                                for (const REVISION of n)
                                    if (REVISION.model.hasStarted()) {
                                        if (null == REVISION.targetSimulationTime)
                                            throw new Error('Non-realtime simulation requires targetSimulationTime');
                                        REVISION.model.getTime().numberOfFrames < Sh.maxFrames && REVISION.model.getTime().lessThan(REVISION.targetSimulationTime) && !REVISION.isPaused && (t.push(AddEquation(REVISION)), i = !1);
                                    }
                                if (i)
                                    break;
                            }
                        } while (Math.max(0, performance.now() - REVISION) / 1000 < 0.01 && !i);
                    }
                    postMessage({
                        messageType: Q_.UpdateResult,
                        carStates: t
                    });
                }
            });
        });
    })();
})();